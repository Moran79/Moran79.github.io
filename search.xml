<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo心得体会</title>
    <url>/2020/07/01/Hexo%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/</url>
    <content><![CDATA[<p>Hexo是一个博客编写的框架，这个网站就采用了这个。网上有太多的资料了，这里只列出来我在学习的时候发现的有趣点，整理下来。</p>
<a id="more"></a>

<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><blockquote>
<p>部署Hexo + GithubPages</p>
</blockquote>
<ul>
<li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">参考1</a></li>
<li><a href="https://michael728.github.io/2019/05/19/hexo-blog-full-note/" target="_blank" rel="noopener">参考2</a></li>
</ul>
<blockquote>
<p>如何只显示缩略内容？</p>
</blockquote>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">在md文件中加入<span class="xml"><span class="comment">&lt;!--more--&gt;</span></span> 即可实现手动分割。前面的内容变成了description</span><br></pre></td></tr></table></figure>



<h1 id="Bugs解决"><a href="#Bugs解决" class="headerlink" title="Bugs解决"></a>Bugs解决</h1><blockquote>
<p>hexo deploy 之后github上面的文件更新了，但是网页没有更新。</p>
</blockquote>
<p>最后的解决方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ rm -rf .deploy</span><br><span class="line">$$ hexo generate</span><br><span class="line">$$ hexo deploy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于博文发布</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ hexo clean</span><br><span class="line">$$ hexo deploy -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>博文发布之后，发现和本地预览的结果不一样，总转圈，加载不出来。</p>
</blockquote>
<p>大佬说是CSS样式的问题，不过我等了一会他自己就好了。。。</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Java心得</title>
    <url>/2020/07/02/Java%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>开始学这个是因为普林斯顿的算法，第一课我看了半天，结果也没学写出来。气馁并放弃。</p>
<a id="more"></a>



<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>A sequence of instructions that solves a problem is called an <strong>algorithm</strong>.</p>
<p>A simple Java program contains:</p>
<ul>
<li>A program starts in main(), executing the statements within main’s braces { }, one at a time.</li>
<li>Each statement typically appears alone on a line, and <u>ends with a semicolon</u>, like English sentences end with a period.</li>
</ul>
<p>单行注释与一大块注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.这是单行注释，两个斜杠</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">2.这是多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这样也可以，后面的双斜杠会被忽略 //</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Java supports a third type of comment, known as a JavaDoc comment (discussed elsewhere), which is a specially formatted multi-line comment that can be converted to program documentation in HTML.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>关于输入空格使得代码美观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yetAnotherVar = myFirstVar;        <span class="comment">// Aligned = operators</span></span><br><span class="line">thirdVar      = yetAnotherVar + <span class="number">1</span>; <span class="comment">//相关联的语句等号也要对齐</span></span><br></pre></td></tr></table></figure>

<p>如果编译器在第五行报错，那么错误肯定会发生在第五行/<u>第五行以前</u></p>
<p>Some errors create an upsettingly long list of error messages. <u>Good practice</u> is to focus on fixing <u>just the first error</u> reported by the compiler, and then re-compiling.</p>
<p><u>A logic error, also called a bug/runtime error</u>, is an error that occurs while a program runs.</p>
<p>In fact, many programmers recommend the good practice of configuring compilers to print even more warnings. For example, javac can be run as <code>javac -Xlint yourfile.java</code></p>
<p>A bit can only have the value of 0 or 1.</p>
<p>Some programmers <u>warn against using floating-point for money</u>, as in 14.53 representing 14 dollars and 53 cents, because money is a countable item</p>
<p>NaN: Not a number</p>
<p><u>public</u> indicates the method may be called from any class in the program, and <u>static</u> indicates the method only uses values that are passed to the method; </p>
<h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>A <u>Scanner</u> is a text parser that can get numbers, words, or phrases from an input source such as the keyboard. Getting input is achieved by first creating a Scanner object via the statement:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner scnr = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>System.in corresponds to <u>keyboard input</u>. Then, given Scanner object scnr, the following statement gets an input value and assigns x with that value:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = scnr.nextInt();</span><br></pre></td></tr></table></figure>

<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p><u>System.out.print</u> 正常打印. <u>System.out.println</u> (note the ln at the end, short for “line”)在打印结束之后自动开始新的一行。Outputting a blank line is achieved by: System.out.println().</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepCalm</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Keep calm"</span>);<span class="comment">// println starts new line after output</span></span><br><span class="line">      System.out.print(<span class="string">"and"</span>);       <span class="comment">// Note: Does NOT print on new output line</span></span><br><span class="line">      System.out.println(<span class="string">"carry on"</span>); <span class="comment">//字符要用双引号括起来，单引号不行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想用一个print打印多个数据，可以用加号连接(默认没有空格直接连接)。</p>
<p>可以采用“\n”来创建新的一行，但是更好的操作是 to use println to output a newline when possible, as println has some technical advantages not mentioned here.</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量类型和变量赋值可以放到同一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> abc = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><u>变量名identifier</u>:</p>
<ul>
<li>must be a sequence of letters (a-z, A-Z), underscore (_), dollar signs ($), and digits (0-9)</li>
<li>must start with a letter, underscore, or dollar sign</li>
<li>case sensitive</li>
</ul>
<p>两种命名哲学：</p>
<ol>
<li>Lower camel case，除了第一个单词之外其他的首字母大写：numApples or peopleOnBus</li>
<li>Underscore separated，用下划线连接：num_apples or people_on_bus</li>
</ol>
<p><u>A good practice</u> followed by many Java programmers is to not use _ or $ in programmer-created identifiers.</p>
<p>变量类型有: int, double, </p>
<p>定义不会更改的变量（Constant/final Variable）：A common convention, or <u>good practice</u>, is to name constant variables using upper case letters with words separated by underscores, to make constant variables clearly visible in code.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> SPEED_OF_SOUND   = <span class="number">761.207</span>;</span><br></pre></td></tr></table></figure>

<p>Because of implicit conversion, statements like </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double someDoubleVar &#x3D; 0;</span><br><span class="line">someDoubleVar &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>are allowed, but discouraged. Using 0.0 or 5.0 is preferable.</p>
<p>变量类型转换：A programmer can precede an expression with <code>(type)</code> to convert the expression’s value to the indicated type.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">avgKidsPerFamily = (<span class="keyword">double</span>)(kidsInFamily1 / kidsInFamily2)</span><br><span class="line"><span class="comment">//但是这样的问题在于没啥子用，应该把double加在两个数字中的一个，而不是加在最外面。</span></span><br></pre></td></tr></table></figure>

<p>整数类型：8-16-32-64 bits对应着byte-short-int-long<br>浮点类型：32-64 bits对应着float-double. Overflow with floating-point results in infinity.</p>
<h1 id="函数-Method"><a href="#函数-Method" class="headerlink" title="函数-Method"></a>函数-Method</h1><p>函数里面的变量在定义的时候被称为参数parameter，在调用时被称为argument</p>
<p>A method can only return one item, not two or more.<br>A void return type means the method returns no value. </p>
<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><p><strong>Math:</strong> Sqrt(x), pow(x,y), abs(x), import java.lang.Math; </p>
<h1 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h1><p>If a program needs a floating-point result from dividing two integers, then <u>at least one of the integers needs to be converted</u> to double so floating-point division is performed.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">""</span>+...) 以防止将...以数字的形式打印</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Latex心得</title>
    <url>/2020/07/02/Latex%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>老罗曾说Latex Book 和 S Book 是他看过写的最好的两本书。那我得跟上啊！</p>
<a id="more"></a>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>\docunmentclass{book/report/letter/article} 确定文件类型</li>
<li>\begin{document}文章开始</li>
<li>\end{document} 文章结束</li>
<li>\title{} 添加题目</li>
<li>\author{}添加作者</li>
<li>\maketitle 制作封面-如果不在begin{document}后面加这句话，其他话都白写了</li>
<li>\tableofcontents 加入目录，包括页码</li>
<li>层次结构：part-chapter-section-subsection 用法: \part{}</li>
<li>无序列表：\begin{itemize}  换行\item ***  换行\end{itemize}</li>
<li>自定义列表：将itemize变成enumerate。默认是数字，可以加其他宏包</li>
<li>输入一些\alpha这种特殊字符要在句子前后各加一个$</li>
<li>一般字符需要用\来转义：{, }, %, $, &amp;,#, ~, ^, _ 但是反斜杠需要用\textbackslash</li>
</ul>
<p>换行 \\</p>
<ul>
<li><a href="https://www.latex-tutorial.com/tutorials/figures/" target="_blank" rel="noopener">添加图片</a> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;enumerate&#125; </span><br><span class="line">\item 带编号的列表</span><br><span class="line">\end&#123;enumerate&#125; </span><br><span class="line"></span><br><span class="line">\begin&#123;itemize&#125; </span><br><span class="line">\item 不带编号的列表</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure>








<p>##环境：</p>
<p>  \begin{环境名}[可选参数]{参数}。document可以被看成最大的环境。</p>
<p>常用环境：</p>
<ul>
<li>居中：center</li>
<li>左对齐/右对齐：flushleft/flushright</li>
<li>verbatim：抄录环境内的字符，忽视tex命令。verbatim* 将空格以␣␣的形式标注出来。行内抄录\verb+内容+和\verb*+内容+</li>
<li>定理类环境：<br>\newtheorem{Theorem}{ 定 理 }[section]<br>\newtheorem{Proposition}[Theorem]{命题}<br>\newtheorem{Lemma}[Theorem]{引理}<br>\newtheorem{Definition}[Theorem]{定义}<br>最后加上：<br>\begin{Theorem} \label{thm:math}<br>定理内容。<br>\end{Theorem}</li>
</ul>
<h2 id="间距："><a href="#间距：" class="headerlink" title="间距："></a>间距：</h2><ul>
<li>.\\表示一行的结束 相当于换行符</li>
<li>\hskip(vskip) 长度 或 \hspace{长度} 或 hspace*{长度}</li>
<li>长度单位sp&lt;&lt;pt&lt;=bp&lt;mm&lt;cm&lt;in 还有em表示字母m的宽度，ex表示字母x的高度</li>
<li>不可换行的水平间距：\enspace =0.5em   , =1/6em    \!=-1/6em  ~=空格</li>
<li>可换行的水平间距：\quad=1em  \qquad=2em  \enskip=0.5em \空格=空格 </li>
</ul>
<h2 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h2><ul>
<li>\section{} \subsection … 可以在中括号前面加个星号，避免自动标号</li>
</ul>
<h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><ul>
<li>行内公式用$…$连接</li>
<li>行间公式：\[…\] 连接 \mbox添加有空格的文字。\mathrm添加没空格的文字</li>
<li>为数字a戴上帽子：hat{a}或者hat a 其他符号：\tilde波浪线，\bar一条横线，\vec向量</li>
<li>三种矩阵：中括号bmatrix，圆括号pmatrix，竖线vmatrix。行间公式—\begin{bmatrix}—a_ {1,1}&amp;\dots&amp;a_ {1,n}\\</li>
<li>带编号的表达式：\begin{equation}\label{eq:ex1}</li>
<li>不带编号的多行表达式：\begin{eqnarray*}  都是用\\换行</li>
<li>带编号多行表达式：\begin{eqnarray} 没有标号的行用\nonumber \\换行 最后一行\label{eq:a2}</li>
<li>大算子号：迭代指标写在求和号上下的情况用行间公式括起来。迭代指标写在求和号右侧的用行间公式连接起来。如$\sum_{i=1}^n a_i^2$</li>
<li>其他大算子：连乘\prod 积分\int 环路积分\oint 交集\bigcap 并集\bigcup</li>
<li>圆括号和大括号大小：\Bigg( &gt;bigg &gt;Big &gt;big&gt;什么都不加就是一个(</li>
<li>像分段函数之类的东西，要用\left\{\begin{array}{ll} 配合 \right</li>
<li>不等号 \not=  或者 \ne </li>
<li>元素不属于\not\in 集合不属于 \not\subset</li>
<li>不小于等于 \not\le  不大于等于\not\ge</li>
<li>^上标 _下标</li>
<li>\stackrel{i.i.d}{\sim}  波浪线上添加iid</li>
<li>偏导数用frac + \partial</li>
<li>正比于 \propto</li>
<li>hat如果不够大的话还有widehat reallywidehat….</li>
<li>二项式系数：\binom 或者直接 C_3^2</li>
</ul>
<h2 id="字体与字号："><a href="#字体与字号：" class="headerlink" title="字体与字号："></a>字体与字号：</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>影响字形的参数有：fontencoding-fontfamily-fontseries-fontshape 用花括号括起来</p>
<p>常用的有:</p>
<ul>
<li>缺省\rmfamily  打印机字体\ttfamily 无衬线字体\sffamily</li>
<li>缺省\mdseries 粗体\bfseries</li>
<li>缺省\upshape 意大利体\itshape 斜体\slshape 小号大写字体\scshape</li>
</ul>
<p>还可以通过{\fontspec{Times New Roman} 文本}来特定某一种字体</p>
<p>还可以通过\textbf \textsf \textit{文本}…的方式</p>
<p>\mathcal{花体字} 、mathbb{实数集R}</p>
<h3 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h3><p>格式：{\tiny 文本}</p>
<p>从小到大：tiny-footnotesize-small-normalsize-large-Large-LARGE-huge=Huge</p>
<ul>
<li>还可以固定宽度高度{\fontsize{120}{160} \selectfont 文本}</li>
<li>不过一般来说，TEX文件正文中不需要设置字体/字号</li>
</ul>
<h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><p>\begin{tabular}[pos]{table spec}<br>…<br>\end{tabular}</p>
<ul>
<li>table spec定义了表格的格式:| l | c | rcl | 竖线就是竖线，lrc分别是左/右对齐和居中，还可以用p{width}来创建一个段落单元格</li>
<li>tabular环境中，用&amp;分隔列，\\开始新的一行</li>
<li>\hline 添加一个水平线 \cline{i-j}添加一个第i列到第j列的水平线</li>
</ul>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul>
<li>alt+delete 迅速删除一行t</li>
</ul>
<h1 id="犯过的错误"><a href="#犯过的错误" class="headerlink" title="犯过的错误"></a>犯过的错误</h1><p>使用\\来进行换行操作的时候报错，解决方法：<a href="https://tex.stackexchange.com/questions/4690/error-message-theres-no-line-here-to-end" target="_blank" rel="noopener">https://tex.stackexchange.com/questions/4690/error-message-theres-no-line-here-to-end</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~\\ 使用它来代替 \\</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>Laioffer笔记</title>
    <url>/2020/07/02/Laioffer%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参加了Laioffer 2018年底11月的Data班，整理了一下学习笔记。Laioffer学费不菲，但是提供的思路还行。像其他网课一样，我一如既往的虎头蛇尾，兴趣全无。</p>
<a id="more"></a>



<h1 id="课程问题"><a href="#课程问题" class="headerlink" title="课程问题"></a>课程问题</h1><p>课下时间：至少70%放在python coding。课下不需要看统计知识</p>
<p>机器学习：</p>
<ol>
<li>告诉老板，我们大概有5%的人要退订服务了</li>
<li>告诉老板，不知道有多少人会退订服务，但是可以告诉你为什么这些人要退订服务</li>
</ol>
<p>如果P值等于0.05：</p>
<ol>
<li>因为0.05是type1，所以可以反问为什么我们要把犯一型错误的概率定在0.05？如果很严重的话我们可以定的再小一点，如果不在乎的话可以定的大一点。</li>
</ol>
<p>MLE在什么时候不work:</p>
<ol>
<li>样本量太小会有问题。【100万人中求样本方差/样本均值，但是只有一个观测值】【均匀分布的估计】</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>问：选定模型需要理由吗？</p>
<p>答：根据不同的Assumption会有不同的模型</p>
<p>问：所有loss-function都是关于$\epsilon = y-\hat{y}$</p>
<p>答：有些模型写不出来loss-function（比如Tree-based）。但是如果能写出loss的，都是要优化xxx，就会跟error有关系。</p>
<p>问：均值和期望不同吗？</p>
<p>答：mean和expectation两者是完全不同的概念. 即使对应的数值一样，他们表达的意义是完全不同的. 简单地说, <strong>mean是针对实验样本来讨论的统计量, 是与具体数据有关的</strong>, 你的数据不同，Mean就不一样. 而<strong>expectation是对一个随机变量的数学特点的描述</strong>, 它更多表达的是在样本无穷的情况下会体现出的特点. 无论你某一次的样本数据是什么样，无论你某一次计算出来的mean多么不靠谱, 这个随机变量的expectation应该都是不变的. 但是如果你可以找到整个Population的所有情况来计算mean (这件事应该是不可能发生的), 那么它应该与expectation是一样的.</p>
<p>问：为什么线性回归的loss用平方？</p>
<p>答：直接对应线性方程<strong>噪声的高斯假设</strong> 。如果写出来似然函数然后用MLE的方法, joint pdf :<br>$$<br>f(y_1,…y_n|x_1,…x_n) = (\frac{1}{\sqrt{2\pi}\sigma})^nexp{-\frac{1}{2\sigma^2}\sum(y_i-x_i\beta)^2 }<br>$$<br>会发现最后的部分是平方损失，而MLE就是让那部分最小。</p>
<p>做题写代码之前，先想一些特殊的（test）case，让自己的code至少可以满足我们能想到的case。</p>
<p>一般的证明算法正确的方法：数学归纳法</p>
<p>问：<strong>L1 L2 loss的区别以及应用场景：</strong></p>
<p>字典的空间复杂度：key + value</p>
<p>Q: 如何解决Confounder：</p>
<p>A: 如果是regression model的话，要把可能的confounder都包含在model里；如果是two group test的话，要matching on confounder或者segment by confounder。</p>
<p><a href="https://joyeuserrance.wordpress.com/2011/04/22/proof-that-p-values-under-the-null-are-uniformly-distributed/" target="_blank" rel="noopener">P-values under the null are uniformly distributed</a></p>
<h1 id="广泛的知识"><a href="#广泛的知识" class="headerlink" title="广泛的知识"></a>广泛的知识</h1><p>机器学习的能力范围：</p>
<ul>
<li><p>给定一个x，并不能给定一个具体y【这也是为什么模型会犯错误】其实给的是y的一个分布【第一步】。然后我们再从y的分布中获得一个y的具体值【第二步】。</p>
</li>
<li><p>所以有的时候结果不好，可能模型是对的，并且已经做到了极限。是我们自己搞砸了第二步</p>
</li>
</ul>
<p>模型不能脱离与数据而存在【不能单独讨论好坏】</p>
<p>理解：考试成绩[error] = 平均水平[bias2]+某次具体发挥[var]</p>
<ul>
<li>Bias表示的是大量实验中的平均偏差[model在训练数据有稍微变化下的平均输出结果与真实值相比，得到的平均准确性]</li>
<li>Var更强调的是某一次出现的偏差[某一次model的数据结果与这个model的平均水平的差距 的平方的期望]</li>
<li>Bias和Variance是无法被计算的</li>
<li>模型越复杂，var越大。因为提取的信息不具有代表性，数据和模型之间的gap就会越来越大</li>
<li>女娲造人。先骨骼再填肉。骨骼就是model的assumption，填肉就是不同的training data. 每个靶图都是很多次不同的填肉，然后再观测眼睛的颜色。</li>
<li>Jason认为$\lambda$ 属于骨架的一部分，虽然他是个参数… </li>
</ul>
<p>我们最小化training error 是<strong>暗含了一个假设</strong>：最小化training error就是最小化testing error。但这个<strong>假设不成立</strong>，这也是过拟合的来源。我们发现过拟合的时候造成不稳的原因是var比较大，所以我们可以加一项来<strong>控制方差：Regularization</strong></p>
<p>Ridge Regression: L2-penalty    LASSO: L1-penalty<br>实际用的时候LASSO不是很稳定，作为最大缺点，二阶在工业界更常用</p>
<p>CV：</p>
<ol>
<li>可以用来hyperparameter tuning，来选$\lambda$ [grid search/ random search]</li>
<li>可以来 validate model selection 【只能选定某一种模型，而决定不了参数】</li>
</ol>
<p>Encoding 的方式：</p>
<ul>
<li>Label-Encoding 把factor变成数字 ordinal的情况</li>
<li>One-Hot-Encoding</li>
</ul>
<p>问：如何判断两个连续变量是否独立？</p>
<p>答：把连续变量离散化，根据range划分成小格子</p>
<p>问：如何判断一个连续一个离散变量是否独立？</p>
<p>答：试着去证明两个CDF是一样的。KL-divergence</p>
<p>Map-Reduce存在的问题：</p>
<ul>
<li>多个任务串联的时候，需要将中间文件写入磁盘，又得读出来。比较慢。</li>
</ul>
<h1 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h1><p>线性回归的线性到底如何定义？指数分类组？</p>
<p>问：为什么选择残差平方作为loss，为什么不是四次方？</p>
<p>答：好像跟什么高斯分布有关系？</p>
<p>问：为什么不用垂直距离做误差？</p>
<p>什么叫OA？</p>
<p>什么是Backtracking？公共课Class40讲了</p>
<h1 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h1><p>线性回归$y = ax+b$ </p>
<ol>
<li>如果给一个点，欠定方程under-determined equation</li>
<li>两个点：适定方程well-determined equation</li>
<li>多个点：<strong>超定方程over-determined equation</strong></li>
</ol>
<p><strong>五个Assumption: ？？？</strong></p>
<p>关于factor的coding有很多种，不仅有one-hot-coding.(Label encoding/<strong>target encoding</strong> 比较fancy)</p>
<p>One-hot-encoding: 保证了各个factor之间的距离都是一样的（$\sqrt{2}$）<br>    followup：等边三角形也保证了三个factor距离一样啊，并且还是二维的<br>    答案：one-hot-encoding 想要的更多的是方便interpret</p>
<pre><code>followup:出现了很多里面没有的新类别该怎么办
答案：1.新增一个other列

followup：如果有一个class有非常多的值，还可以做one-hot-encoding吗？
答案：产生原因：Feature过多的时候，overfitting（需要更多的数据）
    解决办法：1. 其他encoding（frequence-based encoding）
            2.做个聚类，重新用更小的类别数字代替原先的class</code></pre><p>问题：为什么不能直接将ABC三个班级code成为123？<br>答案：这个model基于距离的（线性模型就是）。但是概率模型（比如Tree-based）就没事</p>
<p><strong>朴素贝叶斯：</strong> 是否是花？ 给定feature (F1,…Fn) 现在要求花是哪一类？需要计算P(C|F1,…Fn) 但是这些Feature同时出现的情况可能不存在。<br>Assumption: P(Fi|C) 和 P(Fj|C)是独立的【条件独立】<br>实际例子：Fraud Activity Detection, 为了分类</p>
<p>统计中的随机性（randomness）：</p>
<ul>
<li>每一次出现都是随机的不可预测的</li>
<li>这些随机的背后<strong>存在着特定规律</strong> （所以如果一个参数属于某个参数空间，传统统计中认为就不属于随机变量）【参数不是随机变量】</li>
<li>不是所有不知道的量都是随机变量</li>
</ul>
<p>如何用random(5)[取值0,1,2,3,4]实现一个random(25)？</p>
<ul>
<li>可以把它写成一个方块，看成面积, $5X_1+X_2$</li>
<li><strong>random(7)怎么办?</strong></li>
</ul>
<p>CLT的来源背景：大量相互独立的叠加，并且<strong>每部分对在综合影响中所起的作用差不多</strong>。</p>
<p>为什么正态的误差服从正态分布？我觉得是因为好算F或者t之类的检验，Jason说有可能是因为我们认为大自然的噪声是独立同分布的，所以他们叠加是一个正态….</p>
<p>高斯假设是关于$\epsilon$ 的，或者是关于$y|x$ .</p>
<h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><p>当y是离散的时候，为什么不能用linear regression？<br>遇到的问题：</p>
<ul>
<li>y|x的分布不符合高斯分布</li>
</ul>
<p>解决办法：</p>
<ul>
<li>将y=0/1 变成0~1的概率p，再用线性拟合</li>
</ul>
<p>遇到的问题：</p>
<ul>
<li>很远的地方的数据会变成leverage point，将线拉的很扁。【可以思考赋予leverage点不同的权重】很确定的点可以小一些权重，而那些模糊区/0和1交叉点的地方需要给一些大的权重。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>变成一条折线，早早的就到了1然后一直是平的。【图形角度入手】发现logistic正好符合sigmoid形式，并且指数组也有很多好性质</li>
</ul>
<p>【从值域的角度理解】</p>
<p>开始的是离散的0和1，我们假设服从伯努利分布Ber(p)变成probability属于[0,1]，然后变成odds$\frac{p}{1-p}$ 属于[0,inf] ,然后$log(\frac{p}{1-p})$ 属于[-inf,inf] </p>
<p>多分类问题可以用</p>
<ol>
<li>one vs all</li>
<li><strong>softmax</strong></li>
</ol>
<p>局限性：仅支持一种非线性。</p>
<p>loss function，通过似然函数（joint pdf）计算出来：<br>$$<br>min\ log(p) = \sum_{i=1}^n[-y_ilog(\frac{1}{1+e^{-\beta x}})-(1-y_i)log(1- \frac{1}{1+e^{-\beta x}})]<br>$$<br>Sss</p>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>二分查找/折半搜索，针对已经排好序的序列。</p>
<p>用两个指针left和right进行操作，每次都比较mid = (left+right)/2 和目标值</p>
<p>时间复杂度log(N) 空间复杂度 constant（每次只在操作left right mid 三个指针）</p>
<ul>
<li>如果mid &lt; target, left = mid + 1</li>
<li>如果mid = target, 找到了</li>
<li>如果mid &gt; target, right = mid -1</li>
<li>如果left &gt;= right，就退出。如果left = right = target就返回left/right，如果不等于就退出。</li>
</ul>
<p>如果是多维的情况，也变成一维的情况，用两个指针来做。</p>
<p>Followup1: 寻找数列中最接近某个数值的数的index:</p>
<ul>
<li>此时，原本的 left = mid + 1/ right = mid -1 就要变成let = mid/ right = mid 因为保不齐目前这个mid虽然不是答案，但是是和答案最近的那个，所以不能轻易抛弃他</li>
<li>但是这样的话有时候会进入死循环，因为mid根本不变。所以至少保证三个数再开始跑，<strong>left &lt; right - 1</strong></li>
<li>并且需要<strong>postprocessing</strong>， 因为循环结束的时候，两个指针有可能不重合，而是距离为1，所有要对left和right再检测一遍</li>
<li>python三目运算符：<code>return left if 左小于右 else right</code></li>
</ul>
<p>Followup2: 寻找数列中最先出现某个数的index:</p>
<ul>
<li>要用followup1的判断方法: left &lt; right - 1 为什么呢？</li>
<li>如果mid &lt; target, left = mid。否则， right = mid</li>
<li>最后postprocessing, <strong>先检测left</strong>，再检测right。【反过来不行，因为我们要返回第一次出现的index】</li>
</ul>
<p>Classic判断方法：left &lt;= right. 变种：left &lt; right - 1. 判断是否可以用classic就是看循环中有没有mid = right 或者 mid = left 这种危险语句</p>
<p>Followup3: 寻找数列中最后出现某个数的index:</p>
<ul>
<li>跟2差不多</li>
<li>如果mid &gt; target, right = mid。否则， left = mid</li>
<li>最后postprocessing, <strong>先检测right</strong>，再检测left。</li>
</ul>
<p>Followup4：Search in rotated sorted array:</p>
<ul>
<li>rotated sorted array就是原本一个有序的数列，从中间砍成两半，然后调换他们的位置</li>
<li>有个好性质，那就是无论切掉几部分，剩下的拼起来还是一个rotated sorted array</li>
<li>通过left right 和mid的相对大小来确定mid左面/右面是一个sorted array</li>
</ul>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><p>线性数据结构</p>
<p>Linked List在内存中不一定是紧密相连的（不需要）</p>
<p>单链表：特点是链表的链接方向是单向的…只能访问下一位。单链表的定义还包括有头有尾，最后一个node.next = None 不会出现首尾相连的情况</p>
<p>Linked List 包含</p>
<ul>
<li>一个数据域，存放了数据</li>
<li>一个链域，存放了链表下一个地址位置</li>
</ul>
<p>刚开始创建的时候，self.next = None 因为还没有被链进链表…而在创建节点的时候肯定需要给一个val。所以init(self,val)就可以了</p>
<p>做swap的时候有时候想改变Node的val，但这样其实不符合职业操守，建议把val看成read-only</p>
<h2 id="Singly-Linked-List"><a href="#Singly-Linked-List" class="headerlink" title="Singly Linked List"></a>Singly Linked List</h2><h3 id="遍历Traverse"><a href="#遍历Traverse" class="headerlink" title="遍历Traverse"></a>遍历Traverse</h3><p>问：关于为什么这个函数要写成在class外面的free function而不写在class里面？</p>
<p>答：我的理解是因为Traverse这个功能<strong>并不是针对某一个具体的链表而设定的</strong>，所以不应该被定义在某个class的内部。定义成free function，也还可以遍历其他的链表。</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>添加元素的话一定要返回头结点head，要不然修改会找不到【如果在头前面加的话，没办法知道新的head】</p>
<p>要加fakehead，因为<strong>头结点不存在前驱节点</strong>，万一要在0位置操作的话</p>
<p>可以插入<strong>fake_head</strong>，整个代码清晰起来，因为所有节点都存在了前驱节点</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>如果删除之后将node.next = None,就会直接被Garbage collection清除掉。因为它没有被任何node指向，也没有指向任何node。</p>
<p>要加fakehead，因为<strong>头结点不存在前驱节点</strong>，万一要在0位置操作的话</p>
<h3 id="Merge-two-sorted-linked-list"><a href="#Merge-two-sorted-linked-list" class="headerlink" title="Merge two sorted linked list"></a>Merge two sorted linked list</h3><p>要添加fake_head 效果很棒</p>
<p>我开始想每次都新建一个listnode，但这样会使得空间复杂度为O(N1+N2)。所以用指针操作比较好，差距还是挺多的</p>
<p>时间复杂度O(N1+N2)；空间复杂度O(1) </p>
<h3 id="Find-middle-node-in-singly-linked-list"><a href="#Find-middle-node-in-singly-linked-list" class="headerlink" title="Find middle node in singly linked list"></a>Find middle node in singly linked list</h3><p>先问一下面试官，如果长度是2K，middle node的定义是什么？</p>
<h2 id="Doubly-linked-list"><a href="#Doubly-linked-list" class="headerlink" title="Doubly linked list"></a>Doubly linked list</h2><p>增添删除操作都是locally</p>
<p>但是还是需要fake_head 解决头结点不存在而需要特殊讨论的问题</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><code>fake_head.next = head; head.prev = fake_head</code> 注意一定要加上head.prev 这句话也要加上。并且在return之前要加上：<code>fake_head.next.prev = None; return fake_head.next</code></p>
<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><p>用<u><strong>归约</strong></u>来解决问题</p>
<p>一个小🌰：斐波那契Fibonacci Sequence：找第n位的元素</p>
<ol>
<li>建立一个list来存放所有的数据<ul>
<li>时间复杂度：O(n) 空间复杂度：O(n)</li>
</ul>
</li>
<li>用两个数字去模拟过程，a,b = b, a+b<ul>
<li>时间复杂度：O(n) 空间复杂度：O(1)</li>
</ul>
</li>
<li>Recursion：定义两个基础case F(0) = 0; F(1) = 1</li>
</ol>
<p>递归一个好处：</p>
<ul>
<li>平铺直叙，怎么想的，基本上代码就是怎么写，顺序都一样</li>
<li>有些问题用递归来写很清晰，实现起来很快</li>
<li>虽然一般来说性能可能没有直接写好，但是我们可以在实现之后再修改。</li>
</ul>
<p>Recursion 一个重要的点在于：找到<strong>Base Case</strong></p>
<p>对于递归传递参数我一直有个误区：<strong>结果传递到了哪里</strong></p>
<ul>
<li><p>其实无论是一个数还是一个数据类型，都需要准确的传递地址。一个数的话，一般在函数外先定义，然后函数内部加一行<code>global x</code> 。</p>
</li>
<li><p>如果是List的话应该不用global 因为地址是可以被查找的。</p>
<p><strong>一个有趣的错误：</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,y)</span>:</span></span><br><span class="line">        self.x += y</span><br><span class="line">        <span class="keyword">return</span> self.x</span><br><span class="line">s = Solution()</span><br><span class="line">s.add(<span class="number">3</span>) <span class="comment">#打印出来3</span></span><br><span class="line">s.add(<span class="number">5</span>) <span class="comment">#打印出来8</span></span><br></pre></td></tr></table></figure>

<p>这时候相当于用到了global变量，而global变量被存了起来。有一种解决办法是每次都重置这个global变量，但是如果频繁调用<code>s = Solution()</code> 看起来微蠢，可以写一个wrapper包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ResultWrapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max = <span class="number">-1</span></span><br><span class="line">        self.solution = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span>:</span></span><br><span class="line">    res = ResultWrapper()</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> res.solution</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>判断是否是二叉排序树：</p>
<ol>
<li>从上到下传递range</li>
<li>中序遍历 + 用一个global最大值</li>
<li>从下往上传递左右子树最大最小值 + 左右子树是不是BST</li>
</ol>
<h2 id="reverse-singly-linked-list"><a href="#reverse-singly-linked-list" class="headerlink" title="reverse singly linked list"></a>reverse singly linked list</h2><p><code>head.next.next = head</code> 这一步好强啊</p>
<p><strong>有一个重要思想</strong> 我们对于多个点的变量（比如<code>node.next.next.prev</code>），一定要看他会不会是None，如果可能会是的话，我们提前加一个判断，以及情况处理。</p>
<p>感觉这个算法厉害之处在于…recursive的部分不影响原来的head部分… 可以通过head.next 来获取<strong>recursive链表的最后一位</strong></p>
<h1 id="Non-linear-Models"><a href="#Non-linear-Models" class="headerlink" title="Non-linear Models"></a>Non-linear Models</h1><h3 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h3><ul>
<li>True Positive 这里的True指的是说的错没错。Positive指的是猜的是1还是0</li>
<li>Precision：在你说的正确里面，有多少是真正正确的。（你给出的答案，准确率是多少）</li>
<li>Recall：所有positive里面，有多少被找到了（召回了多少）。<strong>recall = 曹操</strong></li>
<li>accuracy：两种正确/四种情况</li>
<li>F1-value = precision 和 recall 的调和平均数</li>
</ul>
<p>如果是守旧的人，不希望的事情是spam folder里面有重要文件，而可以忍受spam进入邮箱。那么此时分类的时候就是重视recall而觉得precision没那么重要</p>
<h3 id="ROC-curve"><a href="#ROC-curve" class="headerlink" title="ROC curve"></a>ROC curve</h3><ul>
<li>用logistic的时候我们采用了人为的threshold。而采用这个可以直接反映数值</li>
<li>我们不想人为引入threshold</li>
<li>model不变，testing数据也不变。women画出一个随着threshold变化的准确率曲线</li>
<li>对于imbalance class也可以用</li>
<li>蓝色阴影面积决定了好坏。最差0.5（random），最好1。因为如果小于0.5的话，我们取个反就变成一个大于0.5的好分类器了</li>
<li>这个概率的解释：<strong>真实值排在错误值前面的概率</strong>（positive example is <strong>ranked</strong> more highly than a random chosen negative example）</li>
</ul>
<h3 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h3><p>以前机器学习，只能convex才可以做。现在non-convex也可以做（比如神经网络）</p>
<p>目的：使得总体混乱程度降低</p>
<p>ID3用了Entropy：$I_e = -log_2p_i$  ; $H = \sum_{i=1}^n p_iI_e$</p>
<p>C4.5用了GainRate </p>
<p>ID3倾向于对那些有很多分类的变量给更高的关注</p>
<p>CART：Gini impurity</p>
<p>为什么说决策树不是线性模型？$X_i$ 对y的影响只取决于$X_i$  的大小以及他前面的系数，与其他X都无关。但是决策树还与他的位置有关（也就是变量之间的关系也很重要spliting and priority）</p>
<p>问题：强烈过拟合。</p>
<p>解决办法：</p>
<ol>
<li>预剪枝/后剪枝（pre/post-prunning）</li>
<li>Ensemble: 好多棵树一起做 <u>Bagging</u>/boosting(有点复杂)</li>
</ol>
<h3 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h3><p>一棵树容易over-fitting</p>
<p>解决办法：向模型中加入随机性</p>
<p>有放回的抽样——保证每个元素分布一样。选取的K一般是总共feature的平方向下取整</p>
<p>一般来说不需要pruning</p>
<p>Feature importance value in Random Forest: 但从这个公式里面看不出来影响的正负<br>$$<br>Importance(i) = performance(RF) - performance(RF^{random(i)})<br>$$<br>这个performance可以是MSE/Miss classification cost(用OutOfBag的方法，而不是在添加了这个变量之后的entropy变化)</p>
<h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p>Maximize the minimum margin</p>
<p>也可以做regression，对应的loss：hinge loss</p>
<p><strong>Intuition</strong> : 希望边界直线处，分界更加清晰</p>
<p>缺点：</p>
<ul>
<li>sparse的情况没有logstic好</li>
<li>正常分类没有random forest好</li>
</ul>
<p>优点：</p>
<ul>
<li>没有维度灾难，高维上依旧work</li>
<li>数学上完备</li>
</ul>
<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>没有training stage，上来就开始test</p>
<p>也可以做regression，对最近的N个取均值，但正常一般用来classification</p>
<p>K可以被视作一个超参数，无法通过求出来</p>
<p>有个大问题：每一个预测需要O(N)的时间【计算N对距离】<br>解决办法：以空间换时间，先存好不同颜色的几个区域，local-sensitive-hashing。这是一个approximate的方法，在边界的时候容易出问题</p>
<h1 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h1><p>先用PCA，但是PCA破坏物理意义</p>
<p>目的：</p>
<ol>
<li>为了减少overfitting</li>
<li>为了找寻重要的变量，去掉useless variable</li>
</ol>
<p>有时候一个团队可能会选择解释性好而准确性差一点的模型，因为如果哪一天黑箱模型闹脾气不工作了，谁也没办法…</p>
<p>工业届还倾向于多个model来做一件事情，而不是一个model。这样可以多个team一起合作</p>
<p>一个做法：去除变量之间相关性</p>
<ul>
<li>有人用correlation</li>
</ul>
<p>Ridge 倾向于把几个相关性高的变量系数取的一样。因为在a+b= constant 的时候，$a^2+b^2$ 最小就是a = b 的情况。 </p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>协方差越大能够增加信息量，在很容易变化的一个量上面，如果我们能给出一个具体的值，那么对不确定性的影响降得会最多</p>
<p>首先保证了原信息损失最小，副产品是去除了相关性。并不是奔着去除相关性去的</p>
<p>记得要scale</p>
<h1 id="K-means-聚类"><a href="#K-means-聚类" class="headerlink" title="K-means 聚类"></a>K-means 聚类</h1><p>分类问题：原来有类别，现在新的数据，我们需要知道它是属于哪一类</p>
<p>聚类问题：原先没类别，想知道谁和谁更加接近</p>
<p>具体操作过程：不停地更换中心</p>
<p>另一种LDA（Latent Dirichlet Allocation）</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序Bubble-Sort"><a href="#冒泡排序Bubble-Sort" class="headerlink" title="冒泡排序Bubble Sort"></a>冒泡排序Bubble Sort</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fy2mq8lcomj31680kmtei.jpg" alt=""></p>
<p>从第一位开始，相邻的比较大小并交换。第一次一定会将最大的数字移到队列最后面。比较了n-1次，第二次开始要比较n-2次…以此类推</p>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<h2 id="选择排序Selection-Sort"><a href="#选择排序Selection-Sort" class="headerlink" title="选择排序Selection Sort"></a>选择排序Selection Sort</h2><ul>
<li>In-place comparison sort. 不需要额外空间/需要很少额外空间</li>
<li>It has O(n^2) 复杂度，最好最坏都一样，但是比bubble需要的swap的次数更少</li>
<li>甚至比插入排序insertion sort 还要糟糕</li>
<li>When auxiliary memory is limited, 就可以选它了</li>
</ul>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><p>把第一个数字看成一个有序数列。从第二个数字开始，每次都在有序数列中找到自己的位置并插入。一个一个插入，直到原先全部的数字都被插入到了数列中。</p>
<p>原本硬写，时间复杂度：O(n^2) 空间复杂度：O(n)</p>
<h3 id="改进1："><a href="#改进1：" class="headerlink" title="改进1："></a>改进1：</h3><p>具体code的时候，关键点在于，要提前给那个等待插入的数字<strong>预留一个位置</strong>。所以如果想不增加额外的空间复杂度的话：</p>
<ul>
<li>循环从第二位开始走，<code>cur = lst[idx]; k = idx</code> k标记了预留位置</li>
<li>进入一个while loop：每次让lst[k] 跟lst[k - 1]比，如果发现前面更小就跳出while循环</li>
<li>如果前面更大，就把k-1位置的数字移动到k位置，此时空出来的位置是k-1位，所以我们令 k = k - 1</li>
</ul>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<p>这里的时间复杂度：需要n的时间找位置，需要n的时间来做swap： (n+n) * n个数字</p>
<h3 id="改进2："><a href="#改进2：" class="headerlink" title="改进2："></a>改进2：</h3><p>用binary search找插入的位置</p>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<p>这里的时间复杂度：需要log(n)的时间找位置，需要n的时间来做swap： (n+log(n)) * n个数字</p>
<h2 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序 Quicksort"></a>快速排序 Quicksort</h2><ul>
<li>When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.</li>
<li>It is not a stable sort, meaning that the relative order of equal sort items is not preserved.</li>
<li>Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</li>
<li>On average, the algorithm takes O(n log n) comparisons to sort n items. <strong>In the worst case, it makes O(n2) comparisons</strong>, though this behavior is rare.</li>
<li>Quicksort is a divide and conquer algorithm.</li>
<li>The pivot selection and partitioning steps can be done in several different ways; <strong>the choice of specific implementation schemes greatly affects the algorithm’s performance.</strong></li>
</ul>
<p>如何选择pivot？</p>
<ul>
<li>Lomuto partition scheme：选择最后一个<ul>
<li>This scheme degrades to O(n2) when the array is already in order.</li>
</ul>
</li>
<li>用随机数，然后跟最后一位换一下。防止一直出现最差情况</li>
</ul>
<p>优势在于：inplace-sort 每次return都是None 因为不需要创建新空间</p>
<p>时间复杂度：平均/最好 是O(Nlog(N)) 最差：O(N2) 但是概率超小【每次pivot都选出极值】</p>
<p>空间复杂度：O(log(N)) 都来自于recursion 最差情况是O(N) 【概率超小】</p>
<p><strong>写代码分为三步：</strong></p>
<ol>
<li>主函数quickSort(self, alist, left, right)，接受array 传递出quicksort(self, array,0, len-1) 并且还可以用来return </li>
<li>quicksort(self, alist, left, right): 接受左右位置，从partition函数中获得pivot，递归的主函数</li>
<li>partition(self, alist, left, right)：用random.randint(left, right) 来随机产生pivot的位置，进行分类，然后传递pivot的正确位置</li>
</ol>
<h2 id="归并排序-Mergesort"><a href="#归并排序-Mergesort" class="headerlink" title="归并排序 Mergesort"></a>归并排序 Mergesort</h2><p>排序中的王者</p>
<p>核心问题在于，两个长度为N的有序数列合并，复杂度的讨论:</p>
<ul>
<li>时间复杂度O(2*N) 遍历所有元素</li>
<li>空间复杂度O(2*N) 新建了一个数列</li>
</ul>
<p>归并排序的合并过程：每一次合并操作，都涉及到n个元素的合并，所以时间复杂度和空间复杂度都是O(N)。但是总共会合并log(N)次[层数]，所以时间空间复杂度都是O(Nlog(N))</p>
<p>归并排序的拆分过程：每个数字都被跑了一遍，产生了新的长度为N的array。总共有log(N)层</p>
<p><strong>空间复杂度：O(N+log(N)) = O(N)</strong> 来自于recursion和新产生的数组</p>
<ul>
<li><p>N来自于每一层产生的新数组，至于为什么不是Nlog(N) 因为每一层新产生的空间都会被回收掉，空间复杂度指的是 在程序运行的时候 某个时刻需要的最大空间 而不是累计使用了多大的空间【因为这种情况下累积不起来】</p>
</li>
<li><p>log(N)是来自于recursion。每深入一层，就会多一个O(1) 可以理解为【找个地方来存放要运行的代码】其实是存的是地址，要知道每个递归的开始点和结束点。从哪里出来的/回到哪里</p>
</li>
</ul>
<p><strong>Linked-List 版本的sort没有任何的优势</strong> 老师说只是为了让我们练练写代码</p>
<h2 id="Bucket-Sort-Bin-Sort"><a href="#Bucket-Sort-Bin-Sort" class="headerlink" title="Bucket Sort/ Bin Sort"></a>Bucket Sort/ Bin Sort</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Bucket_sort_1.svg/320px-Bucket_sort_1.svg.png" alt=""></p>
<h1 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h1><p>进队enqueue【安Q】 出队dequeue【弟Q】</p>
<p>实际意义：排队</p>
<p>用链表比较好，因为如果用list的话，deque时间复杂度是O(N)</p>
<p>定义了一个ADT（Abstract Data Type）High-level上面带来的好处是：</p>
<ol>
<li>Seperation of Concerns: 使用者开发者不需要互相关心</li>
<li>Readability and maintainability</li>
</ol>
<p>Python有个内置的队列：deque 这个可以支持两端进两端出</p>
<h2 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h2><p>开始想只增添一个属性min 但是如果dequeue的时候把最小值删除了，就麻烦了。所以这个min可以用<strong>另外一个队列</strong>来维护。时间复杂度amortized O(1) <strong>均摊时间</strong></p>
<h1 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h1><p>入栈 push 出栈pop</p>
<p>实际意义：浏览器回退/编辑文档撤销/邮件列表最新出现在最上面/<strong>函数的调用本身</strong></p>
<p>可以直接用list</p>
<h1 id="Binary-Tree二叉树"><a href="#Binary-Tree二叉树" class="headerlink" title="Binary Tree二叉树"></a>Binary Tree二叉树</h1><p><strong>平衡二叉树Balanced</strong>： 每一个节点的左右子节点深度差 &lt;=1</p>
<p><strong>完全二叉树Complete</strong>：除了最后一层，其它层都是满的。并且最后一层是从左往右排的</p>
<p><strong>二叉搜索树Binary Search Tree</strong>：左子树都小于node，右子树都大于node，不考虑相等情况</p>
<p>递归中的BaseCase都是叶子节点的下一层：<code>If not root: return</code></p>
<p>想逐层打印的话：建一个queue每次pop出一个并且把左右节点push进去</p>
<p>发现BFS可以用stack写，DFS可以用queue写</p>
<h1 id="A-B-Testing"><a href="#A-B-Testing" class="headerlink" title="A/B Testing"></a>A/B Testing</h1><p>Quality control in the product iteration 比如说新上线一个功能想测试</p>
<h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><p>目的：快速找到极值</p>
<p>结构：Complete Binary Tree 分为min/maxheap</p>
<p>创建一个heap：从头元素开始不停地sift up（O(Nlog(N))）。Sift up 能保证前面一直是一个heap，sift down只能保证后面一直是heap，所以可以从最后一个开始不停的sift down(O(N))。</p>
<ul>
<li>时间复杂度小了很多，因为最后一层原来贡献了$\frac{N}{2}logN$ , 它们现在只贡献了0</li>
<li>并且实际操作的话，可以忽略最后一行，从最后一个有孩子的开始sift down. </li>
</ul>
<p>Pop的时候先交换array的最前最后，在那个大元素下降的时候，必须要跟左右孩子中较小的那个换，如果跟那个较大的换，会导致root比孩子数值大的问题</p>
<h1 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h1><p>时间复杂度最多是4logN 不能cover连续的四个Node</p>
<h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><strong>正常存法</strong>：是用list分别存储顶点和连线，缺点：</p>
<ul>
<li>一个很简单的问题都回答不了：给定两个定点A, B。是否存在一条路径连接他们呢？</li>
</ul>
<p><strong>Adjacency Matrix</strong>: 用一个n*n的矩阵存储边的信息，如果直接相连即为1。缺点：</p>
<ul>
<li>如果是个Sparse矩阵的话，浪费空间</li>
<li>添加一个新顶点会变得很难</li>
</ul>
<p>优点：</p>
<ul>
<li>可以自己乘自己，获得是否存在长度为K的路径（以及几条）</li>
</ul>
<p><strong>Adjacency List</strong>: 用字典来存储，每个节点是一个key，每一个与该节点相邻的节点是value。优点：</p>
<ul>
<li>我们不会为那些不存在的边浪费存储空间</li>
<li>查询一条边是否存在很快速</li>
<li>添加一条边也很简单</li>
</ul>
<p><strong>一些常见的问题</strong>：</p>
<ol>
<li>给定两点，是否存在通路？</li>
<li>给定一点，找到所有可达点以及所有邻边</li>
<li>给定一幅图，遍历所有点</li>
</ol>
<h3 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h3><p><strong>BFS遍历</strong>：Gab的例子：找眼镜，一点点摸</p>
<p>对于一个给定的节点，先遍历所有距离为1的节点，再遍历对所有新节点来说距离为1的节点。</p>
<ul>
<li>Time Complexity: 对于所有节点V，我们入栈一次出栈一次，并且我们遍历一次他们的邻边。O(V+E)</li>
</ul>
<p>可以用来找最短路径</p>
<p><strong>DFS遍历</strong>：Gab举了个例子：走迷宫。</p>
<p>通过递归来实现，从过一个点出发，算所有能从这个点走到的点。</p>
<p>可以找到所有连通分量</p>
<p><strong>状态</strong>：</p>
<p>对于有向图，有四种边的类型：Tree/Forward/Backward/Cross edge</p>
<p>对于无向图，有两种边的类型：Tree/Backward edge</p>
<p>所以在编程的时候我们要对每种情况进行分类讨论，是一个很便捷的思路。</p>
<p>无向图寻找环：找是否有Backward Edge。注意要记录一个父亲</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Courses</category>
        <category>Laioffer</category>
      </categories>
  </entry>
  <entry>
    <title>SQL心得</title>
    <url>/2020/07/02/SQL%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>找工作时出了出汗，还在Hackerank上面刷题。现在估计都忘了…</p>
<a id="more"></a>



<h1 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h1><ul>
<li>拿到某一列最大值的那一行数据</li>
</ul>
<h1 id="例题解答"><a href="#例题解答" class="headerlink" title="例题解答"></a>例题解答</h1><ol>
<li><a href="https://www.hackerrank.com/challenges/weather-observation-station-6/forum" target="_blank" rel="noopener">首字母是元音</a><ul>
<li><code>WHERE LEFT(CITY,1) IN (&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;);</code></li>
<li><code>WHERE CITY REGEXP &#39;^[AEIOU]&#39;</code></li>
</ul>
</li>
</ol>
<p><a href="https://www.hackerrank.com/challenges/draw-the-triangle-1/problem" target="_blank" rel="noopener">打印小星星</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="built_in">number</span> = <span class="number">21</span>; <span class="comment">/*这一步应该是设定变量？为什么不用Declare，省事！*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">repeat</span>(<span class="string">'* '</span>, @<span class="built_in">number</span> := @<span class="built_in">number</span> - <span class="number">1</span>) <span class="keyword">from</span> information_schema.tables<span class="comment">/*内置table可供遍历*/</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @COUNTER <span class="built_in">INT</span> = <span class="number">20</span>;</span><br><span class="line">WHILE @COUNTER &gt;= 0</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    PRINT <span class="keyword">REPLICATE</span>(<span class="string">'* '</span>, @COUNTER)</span><br><span class="line">    <span class="keyword">SET</span> @COUNTER = @COUNTER - <span class="number">1</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>







<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>Statement always end in a semi-colon;</li>
<li>注释一般用/**/</li>
<li>Command 一般都用大写来表示</li>
<li>character在这里面被称为TEXT：（四种常见格式：INTEGER, TEXT, DATE, REAL）</li>
<li>missing value 用 NULL 表示</li>
<li>Line breaks don’t mean anything specific in SQL. We could write this entire query in one line, and it would run just fine.</li>
<li><code>AS</code> is a keyword in SQL that allows you to <em>rename</em> a column or table using an alias. 跟sas的label一样，只改变输出不改变原数据</li>
<li><code>DISTINCT</code> is used to return unique values in the output. It filters out all duplicate values in the specified column(s).</li>
<li>判断等号的方式就是一个等于号</li>
<li>FROM some_table a 可以用a来指代这个table</li>
<li>如果没有数据的时候要返回NULL 可以用双重SELECT 也可以把UNION SELECT NULL放在语句中</li>
<li>DROP TABLE xxx 彻底删除数据库</li>
<li>IN/NOT IN 判断属于情况</li>
<li>DELETE可以直接删除某一行观测值</li>
<li>关于时间的函数：<strong>TO_DAYS(wt1.DATE)</strong> return the number of days between from year 0 to date DATE, <strong>subdate</strong>(w1.Date, k)可以把日期往前调k天</li>
<li>mod(id,2)=0 偶数 还可以用id % 2 =0</li>
</ul>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每一行都必须具有一个主键值（主键列不允许NULL值）；</li>
<li>主键列中的值不允许修改或更新；</li>
<li>主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。</li>
</ul>
<p>注释用#或者/**/</p>
<p>不等于可以用&lt;&gt;</p>
<p>Between and 是包含一个闭集</p>
<p>在SELECT语句中，子查询总是从内向外处理。在处理上面的SELECT语句时，DBMS实际上执行了两个操作。</p>
<p>作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。</p>
<p>if(判断，如果真，如果假)</p>
<p><code>ORDER BY RIGHT(NAME,3),ID;</code> 可以根据NAME的最后三个字符来排序</p>
<p>定义一个变量 <code>DECLARE @variable_name variable_type = xxx</code>，赋值可以单独用<code>SET @variable_name = xxx</code> 来操作。不过我发现有时候不DECLARE直接SET也可以。</p>
<p>information_schema.tables 是内置的一个table，有61行</p>
<h1 id="Manipulation"><a href="#Manipulation" class="headerlink" title="Manipulation"></a>Manipulation</h1><ul>
<li>CREATE TABLE celebs(<br> id INTEGER,<pre><code> name TEXT,
age INTEGER</code></pre>  );  创建table 可以在数据类型后面跟上NULL/NOT NULL 来要求是否允许缺失值，默认为NULL。可在接着在后面给出 DEFAULT xxx 来给出默认值。可以直接标注primary key</li>
<li>ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id); 也可以增添主键</li>
<li>外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。</li>
<li>只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识。</li>
<li>INSERT INTO celebs (id, name, age) VALUES (2, ‘Beyonce Knowles’, 33);<br> 插入新数据。insert后面没有分号，每插入一行数据就要用一个insert？并且还可以在括号中列出来想插入哪些列的变量，没被填写的那些除非是auto-increment否则会被NULL代替。</li>
<li>如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。1. 该列定义为允许NULL值（无值或空值）。2. 在表定义中给出默认值。这表示如果不给出值，将使用默认值。如果对表中不允许NULL值且没有默认值的列不给出值，DBMS将产生错误消息，并且相应的行插入不成功。</li>
<li>SELECT * INTO CustCopy FROM Customers; 可以实现复制表的功能。不过不管从多少个表中检索数据，数据都只能插入到一个表中。</li>
<li>UPDATE celebs<br>SET age = 22<br>WHERE id = 1; 将celebs数据中id=1的数据，age改为22 这个WHERE很关键，如果没有的话，【所有数据都会被改变】</li>
<li>要删除某个列的值，可用UPDATE设置它为NULL（假如表定义允许NULL值）。</li>
<li>ALTER TABLE celebs ADD COLUMN<br>twitter_handle TEXT; 增加新的一列</li>
<li>DELETE FROM celebs WHERE<br>twitter_handle IS NULL;  删除推特账号是missing的数据。删除一行/多行</li>
<li>如果要从Products表中删除一个产品，而这个产品用在OrderItems的已有订单中，那么DELETE语句将抛出错误并中止。这是总要定义外键的另一个理由。</li>
<li>在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>DROP TABLE 彻底删除一个表，而不只是删除其内容</li>
</ul>
<p>唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。 </p>
<ul>
<li>表可包含多个唯一约束，但每个表只允许一个主键。</li>
<li>唯一约束列可包含NULL值。 </li>
<li>唯一约束列可修改或更新。 </li>
<li>唯一约束列的值可重复使用。 </li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ul>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>SELECT * FROM celebs;  select会生成一个新的 result table</p>
<ul>
<li>SELECT column1,column2, … FROM table; 【用逗号连接】</li>
<li><code>WHERE</code> clause filters the result set to only include rows where the following <em>condition</em> is true.</li>
<li>IN操作符一般比一组OR操作符执行得更快。IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句。</li>
<li><code>LIKE</code> is a special operator used with the <code>WHERE</code> clause to search for a specific pattern in a column. 像是在按照模式匹配字符串，<strong>不分大小写</strong>。用_下划线来指代任何单个字符，%代表任何单/多个字符</li>
<li>通配符%看起来像是可以匹配任何东西，<strong>但有个例外，这就是NULL</strong>。子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL的行。</li>
<li>方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。此通配符可以用前缀字符^（脱字号）来否定。</li>
<li>通过IS NULL/IS NOT NULL 来判断是否为缺失值(大于小于等于号之类的不行)</li>
<li>BETWEEN 如果是两个字符的话不包含第二个字符，如果是两个数字则包含第二个数字</li>
<li>可以用AND/OR 来连接多个condition</li>
<li>ORDER BY … DESC/ASC 降序或者升序排列（注意DESC放在列名的后面，DESCENDING也可以）。在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</li>
<li>如果有必要，可以混合匹配使用实际列名和相对列位置（1,2,3,…）。</li>
<li>在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误</li>
<li><code>LIMIT</code> is a clause that lets you specify the maximum number of rows the result set will have. This saves space on our screen and makes our queries run faster.<code>LIMIT</code> always goes at the very end of the query. Also, it is not supported in all SQL databases. </li>
<li>Limit x,y = limit y offset x 表示的是从第x+1行开始，返回y个数据</li>
<li>SELECT name,<br> CASE<br>  WHEN imdb_rating &gt; 7 THEN ‘Good’<br>  WHEN imdb_rating &gt; 5 THEN ‘Okay’<br>  ELSE ‘Bad’<br> END AS ‘Rating’ #重命名<br>  FROM movies;  CASE-END判断语句</li>
<li>COUNT(1) 可以辅助分组计数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> Country <span class="keyword">IN</span> (<span class="string">'Germany'</span>,<span class="string">'UK'</span>); <span class="comment">#IN 可以从多个元素中找东西</span></span><br></pre></td></tr></table></figure>



<p>要想从一个表中检索多个列，列名之间必须以逗号分隔，但最后一个列名后不加。</p>
<p>使用通配符有一个大优点。由于不明确指定列名（因为星号检索每一列），所以能检索出名字未知的列。</p>
<p>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 </p>
<p>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">50</span> <span class="keyword">PERCENT</span> * <span class="keyword">FROM</span> Customers; <span class="comment">#可以选出前50%的数据</span></span><br></pre></td></tr></table></figure>





<h2 id="计算字段-amp-常用函数"><a href="#计算字段-amp-常用函数" class="headerlink" title="计算字段&amp;常用函数"></a>计算字段&amp;常用函数</h2><p>TRIM/RTRIM/LTRIM 去掉左右的空格</p>
<p>‘+’ 或者|| 可以用来拼接字符</p>
<p>虽然SELECT通常用于从表中检索数据，但是省略了FROM子句后就是简单地访问和处 理表达式，例如SELECT 3 * 2;将返回6，SELECT Trim(‘ abc ‘);将返回abc，SELECT Now();使用Now()函数返回当前日期和时间。现在你明 白了，可以根据需要使用SELECT语句进行检验。</p>
<p>LEFT/RIGHT 返回最左（右）面的字符</p>
<p>SOUNDEX 返回字符串的SOUNDEX值，匹配发音</p>
<p>PI()返回圆周率</p>
<p>GRESTEST 返回最大值</p>
<h2 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h2><ul>
<li>SELECT COUNT(*) FROM Table; 返回一共有多少行</li>
<li>SUM/MAX/MIN/AVG/ROUND</li>
<li>AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。AVG()函数忽略列值为NULL的行。</li>
<li>在用于文本数据时，MAX()返回按该列排序后的最后一行。MAX()函数忽略列值为NULL的行。</li>
<li>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</li>
<li>GROUP BY 按照某一指标分类。后面可以接数字，表示按照SELECT语句中第几个column来分组</li>
<li>When we want to limit the results of a query based on an aggregate property, use <code>HAVING</code>. <code>HAVING</code> statement always comes after <code>GROUP BY</code>, but before <code>ORDER BY</code> and <code>LIMIT</code>. 事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是，WHERE过滤行，而HAVING过滤分组。</li>
<li>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做也算合法，但许多SQL实现不支持，可能会产生模糊的 错误消息。</li>
</ul>
<p>GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</p>
<p>GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子 句中指定相同的表达式。不能使用别名。</p>
<p>大多数SQL实现不允许GROUP BY列带有长度可变的数据类型</p>
<p>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p>
<p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p>
<p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p>
<h1 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h1><p>由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。（直接SELECT FROM x1, x2, x3;）有时，返回笛卡儿积的联结，也称叉联结（cross join）。</p>
<p>目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内联结（inner join）。</p>
<p>SQL允许对表起别名，来允许在一条SELECT语句中多次使用相同的表。（自联结）</p>
<p>OUTER JOIN 允许左边的表的数据在右边的表中没有出现过（这是 LEFT OUTER JOIN的定义，如果是RIGHT OUTER JOIN 就反过来）</p>
<p>还存在另一种外联结，就是全外联结（full outer join），它检索两个表中的所有行并关联那些可以关联的行。与左外联结或右外联结包含一个表 的不关联的行不同，全外联结包含两个表的不关联的行。（MySQL不支持）</p>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>使用UNION很简单，所要做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。如果组合四条SELECT语句，将要使用三个UNION关键字</p>
<p>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。</p>
<p>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
<p>UNION从查询结果集中自动去除了重复的行；换句话说，它的行为与一条SELECT语句中使用多个WHERE子句条件一样。因为Indiana州有一个 Fun4All单位，所以两条SELECT语句都返回该行。使用UNION时，重复的行会被自动取消。这是UNION的默认行为，如果愿意也可以改变它。事实上，如果想返回所有的匹配行，可使用UNION ALL而不是UNION。</p>
<h2 id="Multiple-Tables"><a href="#Multiple-Tables" class="headerlink" title="Multiple Tables"></a>Multiple Tables</h2><ul>
<li>Combining Tables:<br>SELECT orders.order_id,<pre><code>customers.customer_name</code></pre>FROM orders<br>JOIN customers<pre><code>ON orders.customer_id = customers.customer_id</code></pre></li>
<li>默认的join是 inner-join，如果某一行对应的行数据不匹配的话，就把它删掉。left-join 保全先select的table中所有的信息，将后select中没有的信息用missing来填</li>
<li>CROSS JOIN 返回所有可能种排列组合</li>
<li>UNION 相当于r里面的rbind，直接将两个column一样的table上下组合起来</li>
<li>WITH previous_results AS (<pre><code>SELECT ...</code></pre>   )<br>   SELECT *<br>   FROM previous_results<br>   JOIN other_table<br>  ON … = …; WITH可以将运算中生成的新table一起绑起来</li>
</ul>
<p>##Constrains</p>
<p>They can be used to tell the database to reject inserted data that does not adhere to a certain restriction.</p>
<ul>
<li><p>CREATE TABLE celebs (</p>
<p>  id INTEGER PRIMARY KEY,<br>  name TEXT UNIQUE,<br>  date_of_birth TEXT NOT NULL,<br>  date_of_death TEXT DEFAULT ‘Not Applicable’,<br>);</p>
</li>
<li><p><code>PRIMARY KEY</code>: columns can be used to uniquely identify the row.</p>
</li>
<li><p><code>UNIQUE</code> columns have a different value for every row. This is similar to <code>PRIMARY KEY</code> except a table can have many different <code>UNIQUE</code> columns</p>
</li>
<li><p><code>NOT NULL</code> columns must have a value. </p>
</li>
<li><p><code>DEFAULT</code> columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.</p>
</li>
<li></li>
</ul>
<h1 id="Table-Transformation"><a href="#Table-Transformation" class="headerlink" title="Table Transformation"></a>Table Transformation</h1><p>While working with databases, we often need to transform data from one format to achieve a desired result</p>
<h2 id="Subqueries"><a href="#Subqueries" class="headerlink" title="Subqueries"></a>Subqueries</h2><p>A <strong>non-correlated subquery</strong> is a subquery that can be run independently of the outer query and can be used to complete a multi-step transformation. 选择部分只出现在FROM里面</p>
<ul>
<li>SELECT * FROM flights<br>WHERE origin in (<br>SELECT code<br>  FROM airports<br>  WHERE elevation &lt; 2000<br>); 在一个table中以另一个table为选择条件，找出子表</li>
<li>SELECT a.dep_month,<pre><code>a.dep_day_of_week,
AVG(a.flight_distance) AS average_distance</code></pre>  FROM (<pre><code> SELECT dep_month,
       dep_day_of_week,
        dep_date,
        SUM(distance) AS flight_distance
   FROM flights
  GROUP BY 1,2,3
) a</code></pre> GROUP BY 1,2<br> ORDER BY 1,2; 在一个表内做一些选择与统计量计算</li>
</ul>
<p>In a <strong>correlated subquery</strong>, the subquery can not be run independently of the outer query（选择部分出现在SELECT里面）. The order of operations is important in a correlated subquery: </p>
<ol>
<li>A row is processed in the outer query. </li>
<li>Then, for that particular row in the outer query, the subquery is executed.</li>
</ol>
<ul>
<li>SELECT id FROM flights AS f<br>WHERE distance&lt;(<br>  SELECT AVG(distance)<br>  FROM flights<br>  WHERE carrier = f.carrier); 这个AS f 很关键，要不然无法和下面这个select的flights区分开来</li>
</ul>
<h2 id="Set-Operation"><a href="#Set-Operation" class="headerlink" title="Set Operation"></a>Set Operation</h2><p>Merge 2 rows called a join, merge 2 columns called a union.</p>
<ul>
<li>若是想让UNION包含重复的元素，需要在后面加上关键词 ALL</li>
<li>INTERSECT 连接两个SELECT，只包含相同的行</li>
<li>EXCEPT 连接两个SELECT，只包含第一个有第二个没有的行</li>
</ul>
<h2 id="Conditional-Aggregates"><a href="#Conditional-Aggregates" class="headerlink" title="Conditional Aggregates"></a>Conditional Aggregates</h2><ul>
<li>COUNT(CASE WHEN ) 可以返回特定的求和</li>
<li>SELECT    origin,<br>SUM(a.distance) AS total_flight_distance, <pre><code>SUM(CASE WHEN carrier = &apos;DL&apos; THEN distance ELSE 0 END) as total_delta_flight_distance </code></pre>FROM flights AS a<br>GROUP BY origin; SUM的求和要放在Then后面</li>
</ul>
<h1 id="Date-Time-and-String"><a href="#Date-Time-and-String" class="headerlink" title="Date, Time and String"></a>Date, Time and String</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Dates are often written in the following format(同时也是函数名)</p>
<ol>
<li>Date: YYYY-MM-DD</li>
<li>Datetime or Timestamp: YYYY-MM-DD hh:mm:ss</li>
</ol>
<ul>
<li><pre><code>DATETIME(time1, &apos;+3 hours&apos;, &apos;40 minutes&apos;, &apos;2 days&apos;);</code></pre><p>Would return a time 3 hours, 20 minutes, and 2 days after <code>time1</code>.</p>
</li>
<li><p>YEAR(xxx)来返回年份</p>
</li>
<li><p>获取系统日期：CURRENT_DATE()</p>
</li>
</ul>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul>
<li>SELECT (number1 + number2) 直接四则运算</li>
<li>SELECT CAST(number1 AS REAL) 转换格式</li>
<li>SELECT ROUND(number, precision) 取整</li>
<li>MAX/MIN</li>
</ul>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><ul>
<li>A || ‘ ’ || B 用空格连接A和B</li>
<li>REPLACE(string,from_string,to_string) 字符串替换</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加 或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p>为什么要用视图：</p>
<ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。</li>
<li>在编写查询后，可以方便地重用它而不必知道其基本查询细节。 </li>
<li>使用表的一部分而不是整个表。 </li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。 </li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>视图用CREATE VIEW语句来创建。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</p>
<p>视图常见用途：</p>
<ol>
<li>利用视图简化复杂的联结</li>
<li>用视图重新格式化检索出的数据</li>
<li>用视图过滤不想要的数据</li>
<li>使用视图与计算字段</li>
</ol>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<p>有点难 不知道这个具体是干嘛的</p>
<h1 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h1><p>使用事务处理（transaction processing），通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态。</p>
<p>在使用事务处理时，有几个反复出现的关键词。下面是关于事务处理需要知道的几个术语：</p>
<ul>
<li>事务（transaction）指一组SQL语句； </li>
<li>回退（rollback）指撤销指定SQL语句的过程； </li>
<li>提交（commit）指将未存储的SQL语句结果写入数据库表； </li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事 务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</p>
<p>SQL的ROLLBACK命令用来回退（撤销）SQL语句</p>
<p>一般的SQL语句都是针对数据库表直接执行和编写的。这就是所谓的隐式提交（implicit commit），即提交（写或保存）操作是自动进行的。 在事务处理块中，提交不会隐式进行。不过，不同DBMS的做法有所不同。有的DBMS按隐式提交处理事务端，有的则不这样。 进行明确的提交，使用<strong>COMMIT</strong>语句。</p>
<p>要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 在SQL中，这些占位符称为保留点。在MariaDB、MySQL和Oracle中创建占位符，可使用<strong>SAVEPOINT</strong>语句：</p>
<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在。游标（cursor）是一个存储在DBMS服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>不同的DBMS支持不同的游标选项和特性。常见的一些选项和特性如下。</p>
<ul>
<li>能够标记游标为只读，使数据能读取，但不能更新和删除。 </li>
<li>能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。 </li>
<li>能标记某些列为可编辑的，某些列为不可编辑的。 </li>
<li>规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。 </li>
<li>指示DBMS对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Python心得</title>
    <url>/2020/07/02/Python%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用力学。</p>
<a id="more"></a>



<p>未解决的问题</p>
<p>什么是eval？</p>
<h1 id="犯过的错误"><a href="#犯过的错误" class="headerlink" title="犯过的错误"></a>犯过的错误</h1><ul>
<li><p>A little important thing to be cautious:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums[:] &#x3D; nums[n-k:] + nums[:n-k]</span><br></pre></td></tr></table></figure>

<p>can’t be written as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; nums[n-k:] + nums[:n-k]</span><br></pre></td></tr></table></figure>

<p>on the OJ.</p>
<p>The previous one can truly change the value of <strong>old</strong> <em>nums</em>, but the following one just changes its reference to a <strong>new</strong> <em>nums</em> not the value of <strong>old</strong> <em>nums</em>.</p>
</li>
<li><p>在数二进制有多少个1的时候用sum巨慢无比，bin(num)[2:].count(‘1’)是一个更好的选择？</p>
<ul>
<li>不是吧…如果用 &amp; 的话应该会更快？</li>
</ul>
</li>
<li><p>对于123456这种连续的改变，只记录1和7然后用cumulative的方式再变回去会快很多</p>
</li>
<li><p>要是对array是否为none做sanity check当然更好。注意这个叫sanity check</p>
</li>
</ul>
<p><strong>== 和 is 的区别：</strong> 前面是判断等价关系。后面的is是判断identity，也就是两个内存单元的判断。所以有时候对于class的类别，因为没有默认的等价关系，所以都会默认区比较内存单元，会出现这样的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = ListNode(<span class="number">1</span>), ListNode(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> a == b <span class="comment">#会返回False，需要class里面 def __eq__(self, other)</span></span><br><span class="line"><span class="comment">#定义了eq就需要再定义两个事情：def __ne__(self, other); def __hash__(self) 哈希值</span></span><br></pre></td></tr></table></figure>

<p>一般答案的输出集合：Res = [] result的意思</p>
<p>一个已经被decode了的字符s不具有属性s.decode</p>
<p>两个字符串相加，时间复杂度是O(N) 因为后面那个字符需要一个一个添加进去</p>
<p>输入与<strong>输出</strong>并不算在空间复杂度之中（输出也不算）。</p>
<p>计算递归的复杂度，可以画树状图的方式。关于空间复杂度，不是每一层占用的空间，因为函数调用串行执行，一路走到底才会走到其他分支。所以每一层其实只占用一份的空间，其他要不然已经被释放了，要不然还没走到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#有的时候我会用两个stack倒来倒去，就像这样：</span></span><br><span class="line">stack1, stack2 = [root], []</span><br><span class="line"><span class="keyword">while</span> stack1:</span><br><span class="line">    <span class="keyword">while</span> stack1:</span><br><span class="line">        r = stack1.pop()</span><br><span class="line">        ....</span><br><span class="line">        stack2.append(...)</span><br><span class="line">    stack1, stack2 = stack2, stack1</span><br><span class="line"><span class="comment">#今天看到一个老哥的代码：</span></span><br><span class="line">q = collections.deque([root])</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">    r = q.popleft()</span><br><span class="line">    q.append(....) <span class="comment">#感觉更简洁，并且时间复杂度一样</span></span><br></pre></td></tr></table></figure>



<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul>
<li>Python 变量命名规则<ul>
<li>以下划线/字母开始</li>
<li>字母+数字+下划线 来命名</li>
<li>大小写敏感</li>
<li>存在一些保留字符，如果强行赋值的话会报错，但是有些语言就会同意你来重新赋值</li>
</ul>
</li>
<li>Python 2.7里面做的是整数除法【不是四舍五入而是向下取整】但是python3里面是浮点除法<ul>
<li>提示：<code>print 1.0 * 5250/1000</code> 和 <code>print 5250/1000 * 1.0</code> 答案不同</li>
</ul>
</li>
<li>变量类别：<ul>
<li>None 就是NA的意思</li>
<li>很大的整数是long类型的(2**63左右)</li>
<li>float(‘inf’) 和 float(‘-inf’) 表示无穷【大小写无所谓】</li>
</ul>
</li>
<li>raw_input(‘Some Instructions…’) 用户可以输入，默认是字符串。<ul>
<li>如果用input的话，会evaluate式子。比如<code>a = input(&#39;...&#39;); 1+1</code> 【a被传递了2】</li>
<li>默认是一行，如果多行的话需要加while然后逐行输入</li>
</ul>
</li>
<li>语句块不一定都是一个tab也可以是一个空格，只要大家的缩进都相同。【缩进都缩回去了，所以不需要end】良好的coding习惯可以在代码块的下面空一行</li>
<li>三个单/双引号可以注释代码块，在赋值中也是为了在里面输入单引号&amp;双引号</li>
<li>任何非0和非None都会被evaluate成True。只有【0和None】会被evaluate成False</li>
<li>If 0 &lt; 1 : print ‘能运行 ‘ 但是不推荐</li>
<li>逻辑比较：not &gt; and &gt; or 【这个啥意思】</li>
<li>在文件开头加入 # -*- coding: UTF-8 -*- 或者 #coding=utf-8 就可以让python以utf-8进行编码【默认是ASCII】</li>
<li>range只能产生整数序列，numpy.arrange可以产生float数列</li>
<li>python当print的东西是None的时候，返回的不是空白，而是四个英文字母：None</li>
<li>Python is a PASS-BY-OBJECT-REFERENCE programming language<ul>
<li>存储分为stack和heap。stack存放的是reference(变量名)。重新赋值(x = [1])的时候stack里面的reference不变，但是指向了heap（存储了object）里面的一个新的个体。扩充赋值[x.append(1)]这时候heap里的数量没多，元素发生了改变。</li>
<li>平时我们说的占用内存是指heap + stack 合起来的大小</li>
<li>a = [1], b = a, a =[2] 此时b的值是[1]</li>
<li>【某语言】pass by reference: x = [1] 会变成 x = [1] 重新赋值&amp;改变object都会导致值的改变</li>
<li>【某语言】pass by value: 会把object和reference都copy一遍 x = [1] 会变成 x’ = [1]’ 怎么操作跟原来都没关系。</li>
<li>【Python】pass by object reference: x = [1] 会变成 x’ = [1] 重新赋值不会改变，修改的时候会改变</li>
</ul>
</li>
<li>tab 是 increase indent /  shift + tab 是decrease indent</li>
<li>空间复杂度：取决于<strong>额外产生</strong>的空间。因为那些数据占用的地方跟我运行我的程序没关系，并不能用来评估我的这个代码的效率。额外的空间一般都存在内存的heap里面，除了recursion【这里的heap 和stack只是内存的，和另外的heap&amp;stack不是一个东西】</li>
<li>ctr+shift+r 运行代码</li>
<li>//地板除，%显示余数</li>
<li>map支持批量化操作，节省运算速度，不用每一次都解析代码。</li>
<li>ord：Return the Unicode code point for a one-character string</li>
<li>bin(number)[2:] 可以去掉前面的’0b’</li>
<li>elif =else if</li>
<li>s.index(max(s)) 返回s中最大值的index</li>
<li>判断list是否是空的：if list/ if not list</li>
<li>在环境中删除变量。del var</li>
<li>关于xrange与range的区别：range(1,n) allocates memory to store all the 1…n values. But xrange(1,n) generates them on the fly: in each iteration the next number is generated. So it is better memory wise.</li>
<li>del：删除一个变量-如同他从未存在过</li>
<li>print(‘These items are:’, end=’ ‘) end=’’在结尾加上一个空格。默认是换行</li>
<li>time.strftime(格式) 打印当前时间 （import time）</li>
<li>程序需要人为换行的时候可以加一个反斜杠’&#39;</li>
<li><code>print(&quot;There are {:d} robots&quot;.format(Robot))</code> :  :d这里表示了Robot的格式</li>
<li>input(‘展示内容’)可以让录入用户输入的信心，返回的数据类型是str，要通过int()来变成整数</li>
<li>assert 语句：确信某事是真的，如果是假的，则直接报错返回。便于我们检查错误</li>
<li>type函数判断类型</li>
<li>id(variable) 可以返回variable所指向的内存地址，以十进制的方式来表示</li>
<li>python切片操作是左闭右开</li>
<li><strong>reduce()</strong> 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</li>
</ul>
<p><a href="https://stackoverflow.com/questions/36965507/writing-a-dictionary-to-a-text-file" target="_blank" rel="noopener">如何保存set到本地</a></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数是一个动词，执行具体的行为。函数是组织好的，可<strong>重复使用</strong>的，用来实现单一，或相关联功能的代码段。</li>
<li>print函数默认以一个回车’\n’结尾。print(‘a’,end = ‘?’)可以修改。print在打印多个对象之间会默认以一个空格连接：sep=’’可以修改</li>
<li>for和while循环也可以连接else。显而易见的。else总会被运行，除非for/while中间有break。continue 跳过代码中的剩余部分，进行下一循环</li>
<li>如果想在函数里面<strong>使用并修改全局变量</strong>，global x,y,… 可以告诉pyhon接下来函数中的用的x是一个全局变量。</li>
<li>default直接在定义里面写等于，函数中没有默认值的参数必须放在有默认值的参数的前面</li>
<li>可变参数：函数中输入参数的个数是可变的。使用<em>加变量名会把传入的数据生成一个tuple，使用*</em>的话则生成一个字典。</li>
<li>如果return没有搭配任何一个值，则表示return None</li>
<li>Python 中的 pass 语句用于指示一个没有内容的语句块。</li>
<li>print(function._<em>doc_</em>) 可以打印出来function的文档字符串。建议我在编写函数的时候，在函数的第一行就用一对三引号来写一下函数说明</li>
<li><strong>函数只evaluate到return为止</strong>，如果return的条件满足了，之后的代码就不会被执行了。return比break更强，break只能跳出一层，return直接跳出所有东西，结束了函数。</li>
<li>函数可以有多个返回值，可以return x,y 赋值的时候a,b = f()</li>
<li>函数传递的时候可以不按照顺序：<ul>
<li><code>def f=(name,age)</code></li>
<li><code>y = f(age = 12, name = &#39;Jack&#39;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_idx, max_val = max(enumerate(nums), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment">#可以获得max的index</span></span><br></pre></td></tr></table></figure>

<p>函数内定义函数：<a href="https://www.programiz.com/python-programming/closure" target="_blank" rel="noopener">Closure</a></p>
<ul>
<li>we have a closure in Python when <u>a nested function references a value in its enclosing scope</u>. And The enclosing function must <strong>return</strong> the nested function.</li>
<li>在python3 里面可以用 nonlocal 来修改</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>continue和break只针对外面的一层，想跳出多层循环的话只能用boolean flag</li>
<li>如果只是用于循环而不需要一个序列的话，用xrange要比range更好。xrange本质上是一个生成器</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul>
<li>字符叫char(character) 字符串叫str(string)</li>
<li><code>&#39;1&#39;*2 = &#39;11&#39;;&#39;1&#39;+&#39;2&#39; = &#39;12&#39;</code> 但是除号不能用于 str和int之间。Concatenation</li>
<li>字符串不支持对某个位置进行重新赋值: 字符串是不可变的</li>
<li>u’xxxx’ 表示xxx是用unicode来加密的</li>
<li>list()将字符串变成列表。’’.join()将列表变成字符串</li>
<li>a = ‘word’*5 迅速创建字符</li>
<li>b =  [ str(i) for i in a ]迅速将数字列表转化为字符列表</li>
<li>s.split()可以将字符按照空格切开</li>
<li>判断大小写：str.islower/str.isupper. 大小写互换: str.swapcase()</li>
<li>python中大小写转换：str.upper:全部变为大写、str.lower()：全部变为小写、str.capitalize()字符串的第一个单词的首字母变为大写，其他都是小写、str.title()：字符串的每个单词首字母大写，其他变为小写、</li>
<li>多行字符可用三个单引号或者双引号括起来，甚至可以用’’’’….’’’’ 只要前后引号数量一样即可，毕竟只有单引号双引号这两个可能不够用</li>
<li>虽然加号可以连接多个字符，但这样被认为是不优雅的。’I am’ + str(age) + ‘years old’ 可以写成：’I am {0或者空着} years old’.format(age)。<strong>format</strong>有多种用法: {0:.3f}保留小数点后三位。{0:_^11}使用下划线填充文本使文字在中央，字符长度填充为11位。大括号里面可以什么都不写，也可以写index，也可以写’name’这种具体含义，但是如果写了name需要在format里面变成<code>&#39;My name is {name}&#39;.format(name = &#39;Siyu&#39;)</code> </li>
<li>在字符串的末尾加一个反斜杠’\‘表示字符串将在下一行继续，但是不会变成新的一行. 用反斜杠属于显式行连接，用括号连接则属于隐式行连接。</li>
<li>原始字符串：常在正则表达式中出现，前面带一个r或R。前面带一个u表示是unicode编码</li>
<li>对于不可变对象str操作的时候，比如说 a.replace(‘b’, ‘B’) 其实是创建了一个新的字符，新的字符所有的b都变成了B，而a本什么还是没有发生变化</li>
<li>字符串有函数s.index(‘x’)，返回x在字符串中的位置</li>
<li>x.split(‘ ‘)[index] 可以将以空格分隔的字符拆分成几个，再用index索引取出来</li>
<li>str.zfill(num) 可以往字符前面补0来达到固定位数</li>
<li>ord: 返回字符的asc码. chr()将asc变成字符</li>
<li><code>chr.startswith()</code> 判断是不是以某个字符串开始。<code>if &#39;a&#39; in chr</code> 判断’a’是否在chr中，<code>chr.find(xx)</code> 如果xx在chr中则返回下标，如果不在，则返回1. <code>&#39;xx&#39;.join(List)</code> 将List(字符列表)中的元素用xx连接起来变成一个字符</li>
<li>str.find()字符中找匹配字符，找到了返回位置，没找到返回-1</li>
<li>去掉所有标点符号<code>re.sub(&#39;[%s]&#39; % re.escape(string.punctuation), &#39;&#39;, paragraph)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.strip()<span class="comment">#可以去掉首尾空格</span></span><br></pre></td></tr></table></figure>

<p>两个字符（长度分别为m, n）拼接操作<code>m+n</code> 时间复杂度是O(m+n)</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li>re.findall(r’abc’,s) 从s中找到所有abc并返回abc</li>
<li></li>
</ul>
<h4 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h4><p><a href="https://docs.python.org/3/howto/unicode.html" target="_blank" rel="noopener">https://docs.python.org/3/howto/unicode.html</a> #unicode教程</p>
<p><a href="https://www.compart.com/en/unicode/" target="_blank" rel="noopener">https://www.compart.com/en/unicode/</a> #unicode查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"\N&#123;GREEK CAPITAL LETTER DELTA&#125;"</span>  <span class="comment"># Using the character name</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\x0394"</span>                          <span class="comment"># Using a 8-bit hex value</span></span><br><span class="line"><span class="string">"\u0394"</span>                          <span class="comment"># Using a 16-bit hex value</span></span><br><span class="line"><span class="string">"\U00000394"</span>                      <span class="comment"># Using a 32-bit hex value</span></span><br></pre></td></tr></table></figure>



<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li>当有一列key和一列value的时候，想<strong>合成一个dict</strong>：d = dict(zip(key,value))</li>
<li>根据value找key：list(dicxx.keys())[list(dicxx.values()).index(“001”)]但是多对一的映射不好写</li>
<li>字典的Key值必须是不可变的对象（比如字符）</li>
</ul>
<p>M.get(k, d=None): 从字典M里面找key=k，找不到的话返回d而不是报错</p>
<p>M.setdefault(k, d): If key k exists in the map, simply return M[k]; if key k does not exist, set M[k] = d and return that value.</p>
<p>M.pop(k, d=None): Remove the item associated with key k from the map and return its associated value v. If key k is not in the map, return default value d. 正常删除用：<code>del M[k]</code></p>
<p>M.popitem(): Remove an arbitrary key-value pair from the map, and return a (k,v) tuple representing the removed pair. If map is empty, raise a KeyError.</p>
<p>M.clear(): Remove all key-value pairs from the map.</p>
<p>M.update(M2): Assign M[k] = v for every (k,v) pair in map M2.</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><code>bric = bri.copy()</code> 集合的硬复制，其他种类的硬复制可以通过切片的方式<code>a[:]</code></li>
<li>交集运算：<code>bri &amp; bric # OR bri.intersection(bric)</code>差集: 减号或者^。并集用 |</li>
</ul>
<p>b.issubset(a) 判断b是否是a的子集</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul>
<li>52.4E10采用科学计数法，返回一个floats</li>
<li>平方运算是*<em>：3\</em>*2=81</li>
<li>int(‘num’,base=N) 将N进制的数转换为10进制</li>
<li>bin()[2:] 转化为二进制</li>
<li>print(‘%.4f’ % 1.6) 可以规定输出小数位数</li>
</ul>
<h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><ul>
<li>可变长度的，而其他语言的array都是固定长度的，因此python没有array这个概念…所以对于长度：<ul>
<li>开始有个默认长度，比如说10</li>
<li>不断的插入元素，当达到capacity的时候(80%)</li>
<li>创建一个新的list，具有双倍的长度：20</li>
</ul>
</li>
<li>list支持mixed type</li>
<li>用加号可以连接多个list</li>
<li>lst.extend([xxxx]) 可以同时append多个元素在lst的最后/也可以用加号</li>
<li>可以用del(lst[index]) 来删除固定位置的东西</li>
<li>lst.remove(element) 删除第一个出现的element。如果没有出现，则报错</li>
<li>比较两个字符的大小，从第一个不一样的元素开始比较。如果有一个元素走到头了，剩下的长的元素会被认为是大的那个。字符会变成ASCII码来进行比较</li>
<li>list的索引从0开始，倒数第n个元素可以用「-n」或「len()-n」做索引</li>
<li>排序可以用lst.sort() 或者sorted(lst) <code>A.sort(key = lambda x: x % 2)</code> 按照除2的余数排序</li>
<li>向list中追加元素：list.append(‘new’)</li>
<li>把元素插入制定的位置：list.insert(num,’new’)</li>
<li>list.pop(n),删除第n个元素，什么都不填的话默认删除最后一个元素</li>
<li>可以通过list[k] = ‘new’ 来直接替换第k个位置上的元素</li>
<li>list里面的元素类型可以不同，甚至一个list都可以成为另一个list里面的元素</li>
<li>[12,3]*3 答案是[12,3,12,3,12,3] 乘号是重复整个list元素</li>
<li>list是mutable可变的，而<strong>字符串是不可变的(Immutable)</strong>。所以我们可以对list进行sort直接修改源文件，但是不能这么对字符串操作？</li>
<li>删除元素还可以用<code>del shoplist[0]</code></li>
<li>有时候在试index的时候发现list里面并没有这个数字，这时可以用try来解决</li>
<li>list来删除元素：<code>curr.next = curr.next.next</code></li>
<li>有时候array search的方式可能不是从左到右<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    thing_index = thing_list.index(thing)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    thing_index = <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面两种写法等价</span></span><br><span class="line">dp += min(dp[-i * i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(len(dp) ** <span class="number">0.5</span> + <span class="number">1</span>))) + <span class="number">1</span>, <span class="comment">#注意这个逗号</span></span><br><span class="line">dp += [min(dp[-i * i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(len(dp) ** <span class="number">0.5</span> + <span class="number">1</span>))) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如何找到一个loop的开始？</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fys0mm3y1lj31bd0u01kx.jpg" alt=""></p>
<p>List comprehension: 就是以前说的那个错误的’’生成器’’</p>
<h3 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h3><ul>
<li>元组是不可变的，用括号进行分隔。括号可带可不带，最好带着</li>
<li>元组里面可以包含元组</li>
<li>想生成只有一个元素的tuple需要<code>a = (2,)</code></li>
<li>tuple可以直接赋值<code>(x,y,z) = (1,2,3)</code> 但是我发现list好像也可以</li>
<li>append功能只能通过重新赋值来实现。<code>a = (1,2); a = a + (3,)</code> </li>
</ul>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ul>
<li>xxx in list/tuple：会返回逻辑值</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>模块里面的函数用点来连接：math.ceil()天花板函数</li>
<li>模块在编译中会产生.pyc文件，使得下一次载入包更加快速</li>
<li>使用点来选取模块中的部分</li>
<li>内置的 dir() 函数能够返回由对象所定义的名称列表。 如果这一对象是一个模块，则该列表会包括函数内所定义的函数、类与变量。vars有时候也能干一样的事情</li>
<li></li>
</ul>
<p>17.7.3</p>
<p>可以在终端中输入python来创造一个交互式环境【像R语言的窗口】，输入exit()来退出<br>以.py结尾的文件每一行python代码的运行结果不会自动打印，需要在外面套一个print()<br>python可以直接输入16进制的数 以0x开头<br>print(‘’’…’’’)可以使得输入过程变为多行，此时只要括号没扩上都可以用空格来换行『三个单引号』<br>布尔运算分为and or not<br>None表示空值<br>//表示取除法得数 %取余数<br>想分两行打印s2和s4，两种解决方案：print(s2,s4,sep=’’); print(s2,’\n’+s4)<br>print(str1+str2) 可以将两个字符无缝衔接</p>
<p>ord(‘str’)获取字符的整数表示 chr(num)把编码转换为对应的字符<br>字符创建方式可以用十六进制：a = ‘\u4e2d\u6587’<br>以unicode表示的字符可以编码为指定的bytes：  ‘ABC’.encode(‘ascii’)   ‘中文’.encode(‘utf-8’)<br>把bytes变为str，需要用decode： b’ABC’.decode(‘ascii’)<br>同种编码互相转的话，会报错<br>len(‘str’)可以求出str包含多少字符，也可以求出bytes的字节数：len(b’ABC’)，也可以求出list的元素个数</p>
<p>当源代码中包含中文时，需要在文件开头写上两行：<br>#!/usr/bin/env python3     第一行告诉linux/OSX系统这是一个python可执行程序<br># -<em>- coding: utf-8 -</em>-    第二行告诉要按UTF-8来进行编码</p>
<p>格式化占位符：「亲爱的xxx你好！你xx月的话费是xx，余额是xx」<br>‘Hi, %s, you have %d’ % (‘Michael’,1000)  如果只有一个%？，后面的括号可以省略。<br>常见的占位符有： %d整数 %f浮点数 %s字符串 %x十六进制整数    %%来转义%<br>例子：可以决定是否补0以及小数的位数</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘%2d-%02d’ % (3, 1)<br>‘ 3-01’<br>‘%.2f’ % 3.1415926<br>‘3.14’</p>
</blockquote>
</blockquote>
</blockquote>
<p>拆解Tuple：<br>    x=(1,2,3,4)<br>    a,b,c,d=x</p>
<p>而有序列表Tuple使用小括号，一旦初始化便不能再更改，可以从中提取元素，但不能再进行赋值删除等其他操作。<br>产生只有一个元素的Tuple时，要加一个逗号消除歧义。 t = (1,)</p>
<p>for in循环记得最后加冒号<br>range()可以生成一个整数序列（从0开始），然后还可以再用list()转换<br>break直接跳出循环，continue结束本次循环并直接开始下一轮循环</p>
<p>数据放入dict可以加快查找和插入的速度 d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}，<br>但dict需要占用大量的内存<br>可以直接通过key来放入新的数据 d[‘Adam’]=67<br>‘Thomas’ in d 来判断key「Thomas」是否存在与d<br>dict的key必须是不可变对象，因为这个算法是通过Key来计算位置的，这种叫哈希算法。因此list因为具有可变的性质，不能被作为dict的key。<br>x{‘name’:email}我们可以设置三种循环：<br>    ①for name in x:<br>        print(x[name]) #会输出email<br>    ②for email in x.values():<br>        print(email) #也会输出email<br>    ③for name,email in x,items():<br>        print(name)<br>        print(email)  #会打印出来name和email</p>
<p>d.get(‘str’,-1) 如果’str’存在于d就返回’str’对应的值，否则返回-1<br>d.pop(‘str’)删除d中的str以及它对应的值</p>
<p>set也是一组key的集合，但不存储value。<br>s.add(new)添加新元素     s.remove()可以删除元素<br>两个集合可以做数学上的交集与并集。 s1&amp;s2是交集  s1|s2是并集<br>bool(xx)可以把xx变成True/False<br>hex()十进制to十六进制，bin()十进制to二进制 bin(x^y)比较xy各个位数一样的写0不一样的写1<br>空函数： def nop(): pass   可以用作占位符，先让其他代码能运行起来。</p>
<p>定义函数时可以顺便加上数据类型检查： if not isinstance(x,(int,float))<br>                               raise TypeError(‘bad operand type’)<br>检验多个参数时可用<br>f=[False for x in (a,b,c) if not isinstance(x,(int,float))]<br>if f:<br>raise TypeError(‘Bad Type’)    注意：False首字母大写才表示错误的意思</p>
<p>import math 导入math包 允许使用sin/cos等函数<br>定义参数的时候可以默认参数：def power(x, n=2):  意思便是如果power(2,5)便计算2的五次方，如果power(4)便默认计算4的平方。<br>注意：①必选参数必须放在默认参数之前，②默认参数必须指向不变对象。<br>def add_end(L=[]):<br>    L.append(‘END’)<br>    return L    在不停的调用add_end()时，就会出问题，因为此时默认参数指向了一个可变对象</p>
<p>可变参数：def calc(<em>args):  同时 *args表示把args这个list所有的元素作为可变参数传进去。<br>关键字参数：def person(name, age, *</em>kw): 可以在输入的时候填入除了必选项之外的信息，person(‘Bob’, 35, city=’Beijing’)像这里的city就属于关键字参数<br><strong>extra表示把extra这个dict所有的key-value用关键字参数传入到函数的</strong>kw参数<br>限制关键字参数的名字：def person(name, age, <em>, city, job):命名关键字参数<br>def person(name, age, *args, city, job):后面的city与job就不需要再添加</em>了<br>命名关键字参数也可以有缺省值。<br>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>递归时防止栈溢出的方式：使最后的return仅返回递归函数本身，不能包含表达式。这种方式又被称为尾递归。</p>
<p>创建一个1，3，5…99的列表：list(range(1,100,2))  或者 list(range(100))[1::2]</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Object-oriented是否是面向对象编程主要看是不是具有关键字Class（如汇编和Pascal就没有，他们是面向过程process-oriented）</p>
<h2 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h2><p>我们为什么需要Class？</p>
<ol>
<li>每个object有多个属性</li>
<li>需要针对这些属性建立一些能完成特殊需求的函数：比如查找…</li>
</ol>
<p>Coding style: 像self._value这样，就默认了value这个值是内部封装的一个变量，用户最好不要随意玩耍，这样通过变量名字来暗示这一点</p>
<ul>
<li><code>def __init__(self,):</code> Constuctor：对想操作的对象进行初始化，相当于造出来了一个object。可以把其他的函数看做设计的蓝图，而init可以看做是开始施工</li>
<li><code>class SchoolMember:</code> self 在class的第一行并不出现</li>
<li><code>__del__或者__len__</code> 都有各自的触发条件，本质上跟<code>__init__</code> 属于一类函数。这种函数一般都不会被直接call，有其他方式来调用</li>
</ul>
<p>class listnode(object) #这样会直接生成<strong>new-style class</strong> 额所以老师建议也放一个object进去</p>
<p>class里面的__.xxx 的变量是不能被用户直接调用的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.__value = value</span><br><span class="line">s = xxx(<span class="number">5</span>)</span><br><span class="line">print(s.value) <span class="comment">#会输出5</span></span><br><span class="line">print(s.__value) <span class="comment">#会报错</span></span><br></pre></td></tr></table></figure>







<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul>
<li>f.open(‘file.txt’,’w’) 打开一个本地文件 (‘w’写入模式，’r’只读模式, ‘a’追加模式) （还可以选择’t’文本模式，’b’二进制模式）类似的函数还有f.write, f.close, f.readline.</li>
<li>io.open(…, encoding = ‘utf-8’) 可以选择语言。</li>
<li>pickle.dump/pickle.load 进行文件的封装和拆封</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li><p>在我们有可能遇到异常的时候，可以采取try的方法。我们将所有可能引发异常或错误的语句放在 try 代码块中，并将相应的错误或异常的处理器 （Handler）放在 except 子句或代码块中。 except 子句可以处理某种特定的错误或异常， 或者是一个在括号中列出的错误或异常。如果没有提供错误或异常的名称，它将处理所有错误与异常。</p>
<p>try:</p>
<pre><code>text = input(&apos;Enter something --&gt; &apos;)</code></pre><p>except EOFError:</p>
<pre><code>print(&apos;Why did you do an EOF on me?&apos;)</code></pre></li>
<li><p>可以通过raise语句触发一个用户自定义的Exception类</p>
</li>
<li><p>try…finally 可以使finally的部分100%会被运行，而不会受到前面的代码错误的影响</p>
</li>
<li><p>如果用try finally 进行打开文件+关闭文件的操作 可以用with open来简洁的代替</p>
</li>
</ul>
<p>#数学</p>
<ul>
<li><p>itertools 中的permutations&amp;combinations 可以求出排列组合</p>
</li>
<li><p>float(‘inf’)正无穷</p>
</li>
<li><p>for i,j in enumerate(nums) 要多用</p>
</li>
<li><pre><code class="python">map(operator.sub, sums[k:], sums)可以实现sums数列相差k个元素的取差。引入operator只是给出了个减法函数,类似的还有add,abs...
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- </span><br><span class="line"></span><br><span class="line">为了注意range的用法</span><br><span class="line"></span><br><span class="line">L[0:3]表示从索引0开始取，一直取到索引3前面的那个元素，还可以倒数切片，两个数字之差是几，就切出来几个元素</span><br><span class="line">L[:]可以原样复制一个list L[::-1]可以把列表倒置</span><br><span class="line">字符串也可以看成是一种list，每个元素就是一个字符</span><br><span class="line">默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()</span><br><span class="line">enumerate可以把list变成索引元素对。给元素标上号</span><br><span class="line"></span><br><span class="line">列表生成式的应用：</span><br><span class="line">&gt;&gt;&gt; L &#x3D; [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">&gt;&gt;&gt; [&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]</span><br><span class="line"></span><br><span class="line">生成器generator：将列表生成式中的[]变成() 中的每个元素只是保留了算法，没有展开计算，所以在调用或者打印的时候要用next()或者for循环</span><br><span class="line">例如斐波那契数列：</span><br><span class="line">def fib(max):</span><br><span class="line">    n, a, b &#x3D; 0, 0, 1       注意这里的赋值语句</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b &#x3D; b, a + b      注意这里的计算语句</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">    return &#39;done&#39;</span><br><span class="line"></span><br><span class="line">把上式中的print改成yield就变成了一个generator 需要用for循环来输出值。</span><br><span class="line">生成器在做的时候可以设置成无限循环，在输出的时候控制break来跳出即可</span><br><span class="line"></span><br><span class="line">把list,dict,str等可迭代对象变成迭代器可以使用iter()函数</span><br><span class="line"></span><br><span class="line">凡是对一个list里面的每个元素进行同一个操作的算法都可以用map: list(map(f,[]))</span><br><span class="line">reduce 把一个二元函数作用在一个序列上，reduce(f, [x1, x2, x3, x4]) &#x3D; f(f(f(x1, x2), x3), x4)</span><br><span class="line">from functools import reduce  #用reduce之前要写这样一句话</span><br><span class="line">字符转换成数字：</span><br><span class="line">def char2num(s):</span><br><span class="line">    return &#123;&#39;0&#39;:0,&#39;1&#39;:1,&#39;2&#39;:2,&#39;3&#39;:3,&#39;4&#39;:4,&#39;5&#39;:5,&#39;6&#39;:6,&#39;7&#39;:7,&#39;8&#39;:8,&#39;9&#39;:9&#125;[s]</span><br><span class="line"></span><br><span class="line">filter(f,L&#x3D;[…]) 前面的f是是非判断函数，用来留下L中为True的那些元素</span><br><span class="line">sorted()对一个列表排序，可以接受key：sorted([36, 5，-4], key&#x3D;abs)，反向排序加上 reverse&#x3D;True </span><br><span class="line">函数下返回函数，节省运算时间空间。比如计算求和的时候存储的是一个求和的式子，待到需要运算结果的时候再对那个求和式子进行运算。下面是一个闭包实例：</span><br><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs &#x3D; []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">匿名函数lambda：reduce(lambda x, y: x * y, L)</span><br><span class="line">函数有个__name__的属性，可以拿到函数的名字</span><br><span class="line">装饰器：在代码运行简动态增加功能又不改变函数自身的定义。</span><br><span class="line">import functools</span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)     #这一行目的是使得函数名称不改变</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#39;%s %s():&#39; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">偏函数functools.partial的作用是把一个函数的某些参数固定住（修改了默认值）。int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br><span class="line"></span><br><span class="line">安装第三方库：pip3 install Pillow 在terminal里面</span><br><span class="line"></span><br><span class="line">x^y表示的是异或 相同输出0不同输出1</span><br><span class="line">zip(*map&#x2F;list)可以将这个矩阵转置(如果长度不同取最短)—输出的时候格式会有一些问题</span><br><span class="line"></span><br><span class="line">combined&#x3D;[x for j in nums for x in j] 可以把nums&#x3D;[[2,3],[4,5]]变为[2,3,4,5]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">17.11.17</span><br><span class="line"></span><br><span class="line">def add_numbers(x,y,z&#x3D;None):  </span><br><span class="line">	return x+y+z	</span><br><span class="line">预设了z&#x3D;None之后，如果输入的变量只有两个，程序也可以运行。注意提供默认值的变量必须放在变量的最后</span><br><span class="line">type 可以查看变量类型</span><br><span class="line"></span><br><span class="line">连接字符和数字的时候需要在数字外面套一个str()</span><br><span class="line"></span><br><span class="line">字符串格式处理语言：</span><br><span class="line">	sales_record &#x3D; &#123;&#39;price&#39;: 3.24,&#39;person&#39;: &#39;Chris&#39;&#125;</span><br><span class="line">	sales_statement &#x3D; &#39;&#123;&#125; bought item(s) at a price of &#123;&#125; each&#39;</span><br><span class="line">	print(sales_statement.format(sales_record[&#39;person&#39;],sales_record[&#39;price&#39;]))</span><br><span class="line"></span><br><span class="line">.shape #输出矩阵大小</span><br><span class="line">.reshape(n,m) #将矩阵变成n*m的矩阵 resize好像也可</span><br><span class="line">Numpy：</span><br><span class="line">	numpy.array([],[]) #建立矩阵 如果是连接的话，默认是vertical?</span><br><span class="line">	numpy.arange(0,30,2) 生成一个0-28的步长为2的一维矩阵</span><br><span class="line">	numpy.linspace(出发，终止，个数) 创建一个一维矩阵</span><br><span class="line">	numpy.ones&#x2F;zeros&#x2F;eye&#x2F;diag 创建全是1、全是0、标准阵、对角阵(把一个已知n维向量变成n维矩阵)</span><br><span class="line">	numpy.array([1,2,3]*3)和numpy.repeat([1,2,3],3) #前者是123123123，后者是111222333</span><br><span class="line">	numpy.vstack&#x2F;hstack 竖直（水平）连接两个矩阵</span><br><span class="line">	numpy.random.randint 产生随机数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x.dot(y) 做x,y的点乘</span><br><span class="line">z.T 做transpose</span><br><span class="line">z.dtype 当前type</span><br><span class="line">z.astype(&#39;f&#39;) 变type为f</span><br><span class="line">常用函数.sum&#x2F;max&#x2F;min&#x2F;mean&#x2F;std&#x2F;argmax(输出最大值的index)</span><br><span class="line">.copy 复制出来，要不然的话对复制出来的进行修改，也会改变原数据</span><br><span class="line">想要同时对两个东西进行迭代 可以用zip()</span><br><span class="line">索引-1表示最后一个 :-1表示除去最后一个 ::-1 将数据反向排列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 二叉树</span><br><span class="line"></span><br><span class="line">- 四种遍历方式：层序：一行一行。先序：根左右。中序：左根右。后序：左右根</span><br><span class="line">- 后序遍历最后一个节点是根节点</span><br><span class="line"></span><br><span class="line">可以在self树结构里面挂更多的信息，方便做某些题目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 概念&amp;哲学&amp;错误</span><br><span class="line"></span><br><span class="line">- 在定义函数 时给定的名称称作“形参”(Parameters)，在调用函数时你所提供给函数的值称作“实参”(Arguments)。</span><br><span class="line">- 警告：一般来说，你应该尽量避免使用 from...import 语句，而去使用 import语句。这是为了避免在你的程序中出现名称冲突，同时也为了使程序更加易读。</span><br><span class="line">- EOFerror：end of file</span><br><span class="line"></span><br><span class="line">对于for i in range这种循环操作，如果循环指标i无意义的话可以使用：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">for _ in range(10) #用下划线来代替指标i</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" target="_blank" rel="noopener">Python命名艺术</a></p>
<p><a href="https://stackoverflow.com/questions/41691327/ssl-sslerror-ssl-certificate-verify-failed-certificate-verify-failed-ssl-c#41692664" target="_blank" rel="noopener">nltk.download失败</a></p>
<p><a href="https://blog.csdn.net/u011012422/article/details/84201075" target="_blank" rel="noopener">Error:Cannot start process, the working directory ‘’ does not exist</a></p>
<p>默认的re匹配完之后就会继续从下一个地方找，不会寻找overlap的匹配。<a href="https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches" target="_blank" rel="noopener">stackoverflow</a> 里面两种解法都挺好的，第一种更妙，寻找Pattern前面的字符然后定位。</p>
<h1 id="IPython-Notebook"><a href="#IPython-Notebook" class="headerlink" title="IPython Notebook"></a>IPython Notebook</h1><p><a href="https://stackoverflow.com/questions/36786722/how-to-display-full-output-in-jupyter-not-only-last-result" target="_blank" rel="noopener">解决只有最后一行结果的问题</a> :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure>









<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>argsort 相当于r里面的order</p>
<p>np.floor/ceil 地板/天花板函数</p>
<p><code>np.delete(arr, obj, axis=None)</code> Return a new array with sub-arrays along an axis deleted.</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data * <span class="number">10</span> <span class="comment">#每个数字都乘10</span></span><br><span class="line">data + data <span class="comment">#对应位置相加，相乘也是类似</span></span><br><span class="line">data.shape <span class="comment">#返回维数(行，列) 几乘几（每一维是多少）</span></span><br><span class="line">data.dtype <span class="comment">#返回里面数据的类型</span></span><br><span class="line">data[k,:], data[k] <span class="comment">#取出第k+1行</span></span><br><span class="line">data[:,k] <span class="comment">#取出第k+1列</span></span><br><span class="line">data[<span class="number">5</span>:] <span class="comment">#取出第五个以及之后的</span></span><br><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>], arr2d[<span class="number">0</span>, <span class="number">2</span>] <span class="comment">#这两种写法都可以</span></span><br><span class="line">data.ndim <span class="comment"># 打印出来有几维，比如说一个4*5的二维数组，会打印出来2</span></span><br><span class="line">data.reshape(m,n) <span class="comment"># 变换维数，-1 表示缺省值，系统可以帮我们计算这里填什么</span></span><br><span class="line">arr.T <span class="comment">#转置</span></span><br><span class="line">arr.mean(), np.mean(arr) <span class="comment"># 可以求mean</span></span><br><span class="line">arr.sum(axis = <span class="number">0</span>) <span class="comment"># 求和 0是按列求和，1是按行求和</span></span><br><span class="line">arr.cumsum() <span class="comment"># 累积求和</span></span><br><span class="line">arr.sort(<span class="number">1</span>) <span class="comment">#排序 1指的是按行排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>)) <span class="comment">#生成一个3*6的全0数据</span></span><br><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">#随机生成一组数据，分布未知</span></span><br><span class="line">np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="comment"># create 1d array 左闭右开 2是步长</span></span><br><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32) <span class="comment">#dtype规定类型，默认是float64/int64</span></span><br><span class="line"><span class="comment">#dtype其他类型：np.string_(注意有个下划线), 'u4'/'u8' 分别表示uint32/uint64</span></span><br><span class="line">data.astype(np.float64) <span class="comment">#astype来改变类型，将小数变成整数的时候，直接扔掉了小数部分</span></span><br></pre></td></tr></table></figure>

<p>array的slicing也只是传递了内存地址，软拷贝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.copy() <span class="comment">#硬拷贝，生成一份复制品</span></span><br></pre></td></tr></table></figure>

<p>python支持boolean indexing，这里跟R好像啊</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[name = <span class="string">'BOB'</span>] <span class="comment"># 选出name是bob的那些行</span></span><br><span class="line">data[~(name = <span class="string">'BOB'</span>)] <span class="comment"># 选出name 不 是bob的那些行</span></span><br></pre></td></tr></table></figure>

<h3 id="np系列其他函数"><a href="#np系列其他函数" class="headerlink" title="np系列其他函数"></a>np系列其他函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.dot(arr.T, arr) <span class="comment">#计算点乘/矩阵乘积</span></span><br><span class="line">x @ x.T <span class="comment">#另一种点乘的方式</span></span><br><span class="line">np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)) <span class="comment">#高维转置闪瞎我的眼，先不琢磨了，微难想</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 高维交换坐标轴，这里是交换第2和第三维</span></span><br><span class="line">np.sqrt(arr), np.exp(arr) <span class="comment"># Fast Element-Wise Array Functions</span></span><br><span class="line">np.maximum(x, y) <span class="comment">#### 在比较x，y两个向量的时候，居然是逐个位置进行比较的，最后返回一个向量</span></span><br><span class="line">remainder, whole_part = np.modf(arr) <span class="comment"># 将一个小数的整数部分和小数部分分别取出来</span></span><br><span class="line">np.sqrt(arr, arr) <span class="comment">#这个会将sqrt的结果传给arr，相当于 arr = np.sqrt(arr)?</span></span><br><span class="line">a,b = np.meshgrid(x,y) <span class="comment">#Matlab里面也有这个函数，生成网格矩阵，其中a的每一行是x的复制，b的每一列是y的复制,复制的次数是另一个的维数</span></span><br><span class="line">np.where(cond, xarr, yarr) <span class="comment"># 如果cond是True，返回xarr的值，如果是False，返回yarr的值</span></span><br><span class="line">np.unique(names) <span class="comment">#DISTINCT</span></span><br><span class="line">np.in1d(X,Y) <span class="comment">#逐个判断X的元素是不是在Y里面</span></span><br></pre></td></tr></table></figure>

<p>Boolean 判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line">bools.any() <span class="comment">#True</span></span><br><span class="line">bools.all() <span class="comment">#False</span></span><br></pre></td></tr></table></figure>

<p>数据存入导出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.save(<span class="string">'some_array'</span>, arr) <span class="comment">#导出为一个npy数据</span></span><br><span class="line">np.load(<span class="string">'some_array.npy'</span>) <span class="comment">#导入数据</span></span><br><span class="line"><span class="comment">###多个文件一起存</span></span><br><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr) </span><br><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line">arch[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr) <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>Linear Algebra</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br></pre></td></tr></table></figure>



<p>np.linspace(1.5, 2.5, 9) 左闭右闭 9是数量</p>
<p>np.zeros/ ones/ full[填充常数] / eye [identity array]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1 = a[<span class="number">0</span>, :] <span class="comment"># rank 1 view of the first row 这个是一维的</span></span><br><span class="line">r2 = a[<span class="number">0</span>:<span class="number">1</span>, :] <span class="comment"># rank 2 view of the first row 这个是二维的</span></span><br></pre></td></tr></table></figure>

<p><code>a[(a &gt; 5) &amp; (a &lt; 10)]</code> 用小括号来做boolean array</p>
<p>加减乘除都是point-wise</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(np.dot(a, b.transpose())) <span class="comment"># 2x3, 3x2</span></span><br><span class="line">print(a.T.dot(b)) <span class="comment"># 3x2, 2x3 两种矩阵乘积的方法</span></span><br></pre></td></tr></table></figure>

<p>python支持broadcasting，两个维数不同的矩阵进行加减</p>
<ul>
<li>Rule：<a href="https://docs.scipy.org/doc/numpy-1.15.0/user/basics.broadcasting.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/numpy-1.15.0/user/basics.broadcasting.html</a></li>
<li>维数能操作：从最后一位往前看，每一位都需要满足：<ul>
<li>两个维数相等 </li>
<li>其中一个维数是1 </li>
<li>要是有一个维数更长，多出来的那一部分不用管</li>
</ul>
</li>
</ul>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=(<span class="number">4</span>, <span class="number">4</span>)) <span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> normalvariate <span class="comment">#Multivariate </span></span><br><span class="line">np.random.randint(low, high=<span class="literal">None</span>, size=<span class="literal">None</span>, dtype=<span class="string">'l'</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/22994423/difference-between-np-random-seed-and-np-random-randomstate" target="_blank" rel="noopener">random.seed 与 random.state的区别</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><code>np.random.seed(42) #产生随机种子</code></p>
<p><code>np.random.choice(np.arange(100),size=[10,3],replace=True)</code> 随机抽样</p>
<p><code>np.random.shuffle</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 用来产生正态N(0, 1)随机数，参数只是维数，如果想改变方差均值，需要在外面自己做变换</span></span><br></pre></td></tr></table></figure>





<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><ul>
<li>info() 返回数据基本信息和数据内容</li>
<li>value_counts() 计数</li>
<li>.head()/ .tail() 返回前五行和最后五行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat_tmp = dat.iloc[:,<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 选取某几列</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans.to_csv(<span class="string">'save.csv'</span>, index = <span class="literal">False</span>) <span class="comment">#df - csv index指的是是否保存rowname</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dataframe.columns.values <span class="comment">#Get header</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/17071871/select-rows-from-a-dataframe-based-on-values-in-a-column-in-pandas" target="_blank" rel="noopener">条件的取出行</a></p>
<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>把一个list缩成一个字典，key就是list里面的元素，value就是元素重复的次数</p>
<ul>
<li>most_common(k) 可以返回k个最多的元素</li>
</ul>
<p><strong>defaultdict</strong>(list) #创立一个value是list的初始dict，可以直接如下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> sequence:</span><br><span class="line">    counts[x] += <span class="number">1</span> <span class="comment">#不用去在意x是否原先在counts里面 会被intialize to 0</span></span><br></pre></td></tr></table></figure>




<h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><ul>
<li>accumulate: 相当于numpy里面的cumsum</li>
</ul>
<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><ul>
<li>sub 减法 用来配合map使用</li>
</ul>
<h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><ul>
<li>nlargest/nsmallest 可以求出序列中前几个最大值/最小值</li>
</ul>
<h2 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h2><p><a href="https://networkx.github.io/documentation/networkx-1.10/index.html" target="_blank" rel="noopener">https://networkx.github.io/documentation/networkx-1.10/index.html</a></p>
<h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p>Mac端Pycharm不能直接画图，需要</p>
<ul>
<li>用代码<code>print(matplotlib.get_backend())</code> 查看输出是否为MACOSX，如果是的话：</li>
<li>参考这个网页：<a href="https://stackoverflow.com/questions/47834643/how-can-i-run-matplotlib-in-pycharm-on-macos" target="_blank" rel="noopener">修改默认画图选项</a></li>
<li>另外注意必须先写<code>import matplotlib</code>, 再写<code>import matplotlib.pyplot as plt</code></li>
</ul>
<p><a href="https://stackoverflow.com/questions/16625507/python-checking-if-point-is-inside-a-polygon" target="_blank" rel="noopener">判断一个点是否在多边形里面</a></p>
<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><ul>
<li>在比较tuple的时候会比较每个元素，而不只是tuple的第一元素。对于数字我们可以用<code>float(&#39;Inf&#39;)</code> 来控制大小，对于字符的话最小值为<code>&#39;&#39;</code>, 最大值目前还没有想法，不过有个老哥提出了<code>&#39;z&#39;*101</code> 我有点好奇</li>
</ul>
<h2 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>

<p>一共有五种预设主题，通过<code>sns.set_style(&#39;whitegrid&#39;)</code> 来修改。</p>
<ul>
<li>darkgrid，whitegrid，dark，white，和ticks</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.distplot <span class="comment">#画出密度分布</span></span><br></pre></td></tr></table></figure>

<h2 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h2><p>制作交互界面</p>
<p><a href="https://morvanzhou.github.io/tutorials/python-basic/tkinter/3-03-example3/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/tkinter/3-03-example3/</a></p>
<h2 id="其他包包"><a href="#其他包包" class="headerlink" title="其他包包"></a>其他包包</h2><p><strong>ast</strong>: </p>
<ul>
<li><a href="https://stackoverflow.com/questions/46144452/writing-a-set-to-an-output-file-in-python" target="_blank" rel="noopener">输出set到本地</a></li>
</ul>
<p><strong>spacy</strong>:</p>
<ul>
<li><a href="https://github.com/hamelsmu/Seq2Seq_Tutorial/issues/1" target="_blank" rel="noopener">无法加载en包</a></li>
</ul>
<h1 id="操作技巧"><a href="#操作技巧" class="headerlink" title="操作技巧"></a>操作技巧</h1><ul>
<li>cmd+/ 快速批量注释。还可以在想注释内容的前后加上三个单引号</li>
<li>help(‘function’) 帮助手册</li>
<li>一行如果想输入多个代码语句，中间用分号连接</li>
<li><em>Command+Option+L</em> 一键使代码符合规范</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Spark心得</title>
    <url>/2020/07/02/Spark%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Laioffer学习的，628第三次yelp正好用上了。</p>
<a id="more"></a>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Apache Spark 读作 阿派cheap（没有p）</p>
<p><a href="https://databricks.com/blog/2015/04/13/deep-dive-into-spark-sqls-catalyst-optimizer.html" target="_blank" rel="noopener">Spark_Optimizer</a></p>
<p>数据类型RDD：Resilient Distributed Datasets (<strong>RDD</strong>) is a fundamental data structure of Spark. It is an immutable distributed collection of objects. Each dataset in <strong>RDD</strong> is divided into logical partitions, which may be computed on different nodes of the cluster.</p>
<p>Spark allows two distinct kinds of operations by the user. There are <strong>transformations</strong> and there are <strong>actions</strong>.</p>
<ul>
<li><strong>Transformations</strong> are operations that will not be completed at the time you write and execute the code in a cell - they will only get executed once you have called a <strong>action</strong>.</li>
<li>Examples of Transformations: select, distinct, groupBy, sum, orderBy, filter, limit</li>
<li><strong>Actions</strong> are commands that are computed by Spark right at the time of their execution.</li>
<li>Examples of Actions: show, collect, count, save</li>
</ul>
<p>%[coding language] 来切换python/R/SQL</p>
<p>display(xxx) 用来展示一下dataframe</p>
<ul>
<li>这个函数厉害的点在于：we can very easily <strong>create some more sophisticated graphs</strong> by clicking the graphing icon that you can see below</li>
</ul>
<p>xxx.explain() 来解释transformation背后的physical plan</p>
<p><code>Xxx.first()</code> 取出header</p>
<p><code>xxx.take(n)</code> 取出前n行</p>
<p><a href="https://docs.databricks.com/user-guide/libraries.html" target="_blank" rel="noopener">Databricks倒入外部包</a></p>
<p>DS/DF 比RDD更快，因为Spark知道了数据的样子</p>
<p>ReduceByKey 比GroupByKey好处：在shuffle之前做了一步聚合操作，压缩数据传输量。</p>
<p>Join是最慢的一个操作。</p>
<p>spark.read.json自动变成DF</p>
<p>df.show()#画个图</p>
<p>df.count()#有几行</p>
<p>df.printSchema()#看看基本信息</p>
<p>df.createOrReplaceTempView(Name) #可以变成一个table，可以之后用SQL</p>
<p>spark.sql(“SELECT…”) #SQL语句，用这种方式取出来的格式是Data.frame</p>
<p>pyspark.sql.row #用来生成DF</p>
<p>spark.createDataFrame(NAME)</p>
<p>vector assembler 可以把columns转化成vector</p>
<h1 id="pyspark"><a href="#pyspark" class="headerlink" title="pyspark"></a>pyspark</h1><p><a href="https://www.analyticsvidhya.com/blog/2016/10/spark-dataframe-and-operations/" target="_blank" rel="noopener">pyspark教程</a></p>
<p><a href="https://stackoverflow.com/questions/46956026/how-to-convert-column-with-string-type-to-int-form-in-pyspark-data-frame" target="_blank" rel="noopener">如何修改列的type</a>：<code>crimeSunday = crimeSunday.withColumn(&#39;X&#39;, crimeSunday[&#39;X&#39;].cast(&#39;float&#39;))</code></p>
<h1 id="Databricks-语法"><a href="#Databricks-语法" class="headerlink" title="Databricks 语法"></a>Databricks 语法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbutils.fs.rm(&#39;FileStore&#x2F;tables&#x2F;628&#x2F;review_100k.json&#39;,True) #删除自己上传的文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>R心得</title>
    <url>/2020/07/02/R%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>老本行，学。</p>
<a id="more"></a>



<h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><ul>
<li>如何画出线性分割图PDA？用R语言我是没整明白</li>
</ul>
<h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><ul>
<li><p>args(mean)—快速查看mean的参数有哪些</p>
</li>
<li><p>example(mean)—看一个mean的实例</p>
</li>
<li><p>&lt;&lt;- 强制赋值给一个全局变量</p>
</li>
<li><p>ls() &amp; ls.str() 可以查看当前工作空间中存在哪些已定义的变量和函数。ls()不会显示以”.”开头的隐藏变量，可通过ls(all.names=T)强制输出所有变量</p>
</li>
<li><p>rm(list=ls())来删除全局所有变量———注意编程的道德规范</p>
</li>
<li><p>逻辑向量进行比较，any() &amp; all() any中有一个为真则输出真，all中全部为真则输出真, purrr包里还有个some和every</p>
</li>
<li><p>想删除向量里面的na/null :  v[!is.na(v) &amp; !is.null(v)]</p>
</li>
<li><p>names函数可以给向量每个分量起名字</p>
</li>
<li><p>欧几里得算法计算两个数的最大公约数：</p>
<p>gcd &lt;- function(a,b){<br>if(b==0) return(a)<br>else return(gcd(b,a%%b))<br>}</p>
</li>
<li><p>卸载软件包: detach(package:MASS)</p>
</li>
<li><p>data() 查看都有哪些内置的数据</p>
</li>
<li><p>near():用来对比两个近似的数是否相等。near(1/49*49,1)</p>
</li>
<li><p>在赋值语句前后加上小括号，可以输出赋值内容</p>
</li>
<li><p>xor(): 异或. &amp;&amp;和 || 只比较两个向量的第一位</p>
</li>
<li><p>log2(),log10(): 以2和10作为底数。作者推荐用2做底数，因为interpret的时候更有利：答案每少1，变换之前的数就比原来少了一半。</p>
</li>
<li><p>lag(), lead(): 将数组向后和向前移动一位。多用于比较 x==lag(x)</p>
</li>
<li><p>cumsum, cumprod, cummin, cummax, cummean. 累积函数</p>
</li>
<li><p>order依次给出第几小的是第几个，sort将数据从小到大排序，rank给出第一个数是第几小的，会把NA放在最后，同样的数用均值来计算rank。min.rank对同样的数会用最小值来计算rank. 更多选项参见?rank</p>
</li>
<li><p>pipe: %&gt;% 相当于「then」 放在一段语句的最后，省去了为中间变量起名的过程，大大缩短了编程时间. Pipe使用的环境不是当前环境而是新创造出来一个临时环境，所以遇到需要当前环境的函数时会产生一些问题。如果pipe的语句超过了10行或者中间有很多的输入输出，那么不建议用pipe</p>
</li>
<li><p>pipe的另外三种：%T&gt;% : return the lefthand side not the righthand side. %$%: 快速从data.frame里面选出某几个变量。%&lt;&gt;%赋值，但是作者不建议这么做，他认为赋值作为一个很重要的过程，值得花费点时间多写几步换来更清楚的代码</p>
</li>
<li><p>表示离散程度的除了sd&amp;var，还有IQR():0.75分位数与0.25分位数的差。mad(x):1.4826*绝对中位差：用原数据减去中位数后得到的新数据的绝对值的中位数。在数据点包含outlier的时候，后两种效果更好。</p>
</li>
<li><p>first(), last(),nth(x,n): 取出向量中特定位置的元素</p>
</li>
<li><p>range()里面有一个参数finite = T 表示去掉这个向量里面的无穷再取range</p>
</li>
<li><p>identical():判断两个向量是否相等。注意integer和double即使数字一样结果也会返回false。所以这时候改用dplyr::near()</p>
</li>
<li><p>switch(status, status1 = … , status2 = …  ): 可以将多个if条件放到一个框里</p>
</li>
<li><p>cut(aaa, 3, dig.lab = 2, ordered = TRUE): 将aaa从小到大变成三个类别，每个类别中小数点后不超过两位</p>
</li>
<li><p>stop(“错误信息”)：在函数或者循环里加上判断错误信息的语句可以让他变得更robust。内置还有一个函数叫stopifnot()</p>
</li>
<li><p>函数里面的变量可以定义成…  ：可以自动match多个无法被其他方式match的输入。</p>
</li>
<li><p>pipable function分为两类：transformation &amp; side-effect：第二种类似于画个图或者写个文件之类的，对原文件不产生影响，那么这些函数返回值会是那个源文件。</p>
</li>
<li><p>R默认的数字类型是double所以要生成integer需要手动在数字后面加上L</p>
</li>
<li><p>is.finite/is.infinite/is.nan/is.na：判断doube类型的四大天王，其中NaN数据会对后两个函数都给出T</p>
</li>
<li><p>NA/NA_real/integer/character_: NA有四种类型，分别代表logical,double,integer,character.</p>
</li>
<li><p>purrr出了is_logical/…/atomic/list/vector: 用来修正自带is.的问题。vector可分成list和atomic。atomic可以分成numeric,logical和character.numeric可以分成double和integer. is_scalar_atomic还可以顺便检查一下长度是否为1.</p>
</li>
<li><p>rep(1:2,3)结果是121212. rep(1:2, each = 3)结果是111222</p>
</li>
<li><p>set_names()给向量起名。</p>
</li>
<li><p>可以为向量添加attributes：attr(data,’Name’)&lt;-‘…’ attributes(x)输出所有的attributes</p>
</li>
<li><p>factors，date-times/times, tibbles都是vector+attributes的结果</p>
</li>
<li><p>mean函数里面的trim参数：从排过序的原始数据中，从数据的两端分别删除floor(trim * length)个数据再进行平均值计算</p>
</li>
<li><p>keep/discard(logical)：只保留那些True/False</p>
</li>
<li><p>detect/detect_index: 返回第一个True的值和第一个True的位置</p>
</li>
<li><p>head_while/tail_while: 从开头/结尾开始返回连续的所有True的值，如果开头/结尾就是False则返回0.</p>
</li>
<li><p>reduce: Reduce a list to a single value by iteratively applying a binary function</p>
</li>
<li><p>accumulate: Accumulate recursive folds across a list</p>
</li>
<li><p>broom::glance: 对一个fit作用，给出各种参数指标(精简版summary)。tidy给出系数，augment给出原数据加上残差等一系列统计指标</p>
</li>
<li><p>J是矩阵的subsetting   ?????</p>
</li>
<li><p>多维正态联合分布：mvrnorm</p>
</li>
<li><p>多个因子变量进行对比可以用contrasts(z)</p>
</li>
<li><p>substr可以取字符的首字母substr(“china”,1,1)</p>
</li>
<li><p>typeof比mode更新，但class返回的是当前状态下他是一个什么类型</p>
</li>
<li><p>sub(pattern= ‘\,‘ ,replacement=’’, y) 表示将字符串y里面所有的”,”去掉第一个，gsub全局去掉。</p>
</li>
<li><p>bootstrap产生数据保存到一个list里面：f&lt;-function(m) sapply(1:m,function(o) sample(X,replace = TRUE)) ; b&lt;-f(1000)</p>
</li>
<li><p>f&lt;-Vectorize(f) 使一个函数可以进行向量化运算</p>
</li>
<li><p>m&lt;-optimize(f,interval=c(1,4),maximum=TRUE)[[2]] 给出一维函数在某段区间的最大或者最小值</p>
</li>
<li><p>产生一个异质（元素类型不同）的矩阵：从一个异质的列表开始，赋予它维数。</p>
</li>
<li><p>在向量中间插入数据：append(oldvec,newvalues,after=n) 表示在第n个数据后插入新的一个元素</p>
</li>
<li><p>合并几组向量形成一个list：list(com1=v1,com2=v2,com3=v3)  可以用stack将全是向量的list变成一个一列的长向量</p>
</li>
<li><p>从列表中移除取值为空值的元素： lst[sapply(lst,is.null)] &lt;- NULL 赋予NULL是删除列表元素的一种方法</p>
</li>
<li><p>lapply与sapply都可以对列表进行操作，不同点是前者返回一个列表，而后者返回一个向量</p>
</li>
<li><p>矩阵可以通过添加参数 byrow=TRUE 来使数据按行排列</p>
</li>
<li><p>从矩阵中取出一行/一列矩阵：而不是取出一行数据： row&lt;-matrix[1,,drop=FALSE]</p>
</li>
<li><p>若obs是一个列表的列表而不是数据框列表：Map(as.data.frame,obs)变成数据框列表. Map是对向量的操作的函数（可能list本质上是一个向量吧）</p>
</li>
<li><p>反复调用一个函数用replicate</p>
</li>
<li><p>删除一个包detach(‘package: …’)</p>
</li>
<li><p>rnorm函数中输入的是sd而不是var</p>
</li>
<li><p>sweep 将输入的向量减去一个统计量（可以是mean或者其他…）</p>
</li>
<li><p>proc.time()获取代码运行时间</p>
</li>
<li><p>factorial(n)返回n的阶乘</p>
</li>
<li><p>win.graph可以调整图片大小，但是只能在windows上面用，dev.new不限平台</p>
</li>
<li><p>pander 专门用来打印的？</p>
</li>
<li><p>seq_along() 产生对应长度的index</p>
</li>
<li><p>which(dis==min(dist(dat2)), arr.ind = T) 返回特定元素在矩阵中的index</p>
</li>
<li><p>对于一些大数，可以先做log变换再变回去。lgamma(x)可以算log(gamma(x))</p>
</li>
<li><p>返回一个向量的最大值位置，用order然后看最后一位</p>
</li>
<li><p>dist计算多维距离的时候，对于某一个位置如果有NA的话，会默认用其他位置距离的平均值来impute</p>
</li>
<li><p>非参拟合可以用smooth.spline 报错tol的时候一般是因为x只有1个，一般来说至少有四个不同的x才可以正常运行</p>
</li>
</ul>
<p><strong>System.time</strong>: How to interpret the reported times user, system, and elapsed：</p>
<ul>
<li><p>Well, clearly <code>elapsed</code> is the <strong>wall clock time</strong> taken to execute the function, plus some benchmarking code wrapping it </p>
</li>
<li><p>“User CPU time” gives the CPU time spent by the current process (i.e., the current R session) </p>
</li>
<li><p>“system CPU time” gives the CPU time spent by the kernel (the operating system) on behalf of the current process. The operating system is used for things like opening files, doing input or output, starting other processes, and looking at the system clock: operations that involve resources that many processes must share. Different operating systems will have different things done by the operating system.</p>
</li>
<li><p>为什么有时候elapsed time远远大于其他两个之和？<a href="https://stackoverflow.com/questions/13688840/what-caused-my-elapsed-time-much-longer-than-user-time" target="_blank" rel="noopener">https://stackoverflow.com/questions/13688840/what-caused-my-elapsed-time-much-longer-than-user-time</a></p>
</li>
<li><p>为什么有的时候<a href="https://stackoverflow.com/questions/18654497/mclapply-user-time-larger-than-elapsed-time" target="_blank" rel="noopener">user time larger than elapsed time</a></p>
</li>
<li><p>table函数等价于python里面的Counter()</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">methods(print) <span class="comment"># print 本身先判断数据类型，再给出不同的print做法</span></span><br></pre></td></tr></table></figure>

<p>如果想取出特定summary中的某一部分，可以<u>用str先看一下structure</u>，确定好位置之后再直接输出。</p>
<p><a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/hexmode.html" target="_blank" rel="noopener">10-16 base转换</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data %&gt;%</span><br><span class="line">	`colnames&lt;-`(c(<span class="string">"Population"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>)) <span class="comment">#Pipeline 里面改column name</span></span><br></pre></td></tr></table></figure>

<p>当前的包安装不上的时候：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">'/Users/moran/Desktop/Epi_2.33.tar.gz'</span>,repos = <span class="literal">NULL</span>, type=<span class="string">"source"</span>)</span><br></pre></td></tr></table></figure>

<p>tryCatch里面赋值的时候，要用&lt;&lt;-而不是&lt;-</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><p>在使用for循环的时候，<strong>如果给output预先分配好空间的话，那么整体的运行速度会快很多</strong>，这里可以使用vector(mode = ‘logical’, length= 12).</p>
</li>
<li><p>可以用函数seq_along(n)来代替 1:n 来规避n=0的时候的错误</p>
</li>
<li><p>以后不要在循环里面写出c(当前，新内容)这种效率低的语法，可以先把结果存在一个list里面，然后再使用unlist，list的空间也要先赋好。purrr::flatten_dbl()更严格，如果不是一个double的list会报错。如果是字符型的，用paste(output, collapse = “”)。如果是一堆列向量，用dplyr::bind_rows(output)</p>
</li>
<li><p>多多使用while语句（simulation中常用，针对循环次数不确定，但是一个标准确定的时候）。所有for都可以改成while但是不是所有while都可以改成for</p>
</li>
<li><p>函数嵌套函数，apply系列的替代函数：map():list. map_lgl/int/dbl/chr 分别对应的不同数据类型</p>
</li>
<li><p>map+pipe时，遇到自定义函数可以用map(~lm(mpg ~ wt, data = .))来代替map(function(df) lm(mpg ~ wt, data = df))</p>
</li>
<li><p>例子：models %&gt;%   map(summary) %&gt;%   map_dbl(~.$r.squared) 最后一个可以替换成 map_dbl(“r.squared”)</p>
</li>
<li><p>有时候一个循环的一部分出了错，但是整个程序中那些正确的值也无法输出，这时候我们用safely()这个函数可以返回一个二维列表，第一列是result，第二列是error。如果最后输出结构太复杂可以用transpose()来修正。</p>
</li>
<li><p>在我们不想知道为什么错了的时候可以用possibly(原函数, 「替」)这样的话只要报错，都用「替」来替代</p>
</li>
<li><p>还有一个函数叫quietly(): 跟safely差不多，输出的结果更简单清晰。</p>
</li>
<li><p>当我们迭代的变量大于一个的时候，用pmap()。两个的时候是map2()</p>
</li>
<li><p>当我们迭代的是函数而不是变量的时候：invoke_map(f, parameter)</p>
</li>
<li><p>walk/walk2/pwalk：call a function for its side effect rather that its return value.</p>
</li>
<li><p>.Last.value  最近的一个计算结果</p>
</li>
<li><p>source(“”) 可以读取文本文件(.R后缀的文件)并执行其内容  可选参数：echo=TRUE ——在执行的同时显示源代码</p>
</li>
<li><p>print(pi,digits=4) / cat(format(pi,digits=4),”\n”) 可以改变输出数据的位数，format是用来设定数据的格式</p>
</li>
<li><p>cat(“…”,file=”filename”)  来使输出结果到filename的文件里，不过如果反复使用，要加append=TRUE。改进则要使用到文件的链接，且无需append=TRUE： con&lt;-file(“..”,”w”)  cat(data,file=con)</p>
</li>
<li><p>list.files()  显示当前工作目录里面的文件</p>
</li>
<li><p>save(data,file=”filename”) 存为一个二进制文件 </p>
</li>
<li><p>dput(data,file=”filename”)  存为一个ASCII码文件，操作是将该数据以structure函数的方式打印，直接拷贝再赋值给其他变量即可，reproduce the data。</p>
</li>
<li><p>dump(“data”,file=”filename”) 与dput效果一样，只是多了一组引号</p>
</li>
<li><p>next = continue break = break</p>
</li>
</ul>
<h1 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h1><ul>
<li>plot(cex=0.2) 调整数据点大小</li>
<li>一个例子：curve(sin(x),from=-10,to=10,ylim=c(-2,2),main=”函数sin(x)”,col=”red”,lty=3,lwd=2,ylab=”y轴sin(x)”)<br>abline(h=1);abline(h=-1)</li>
<li>hist(freq=F)输出density密度 freq=T 输出frequency频数</li>
<li>chull画凸形</li>
<li>将图片和文字打印到pdf里：pdf(‘file’); plot(….) ; gridExtra::grid.table(data.frame); dev.off()</li>
<li>plot.new() 打印空白图片</li>
</ul>
<p><a href="https://www.stat.ubc.ca/~jenny/STAT545A/block14_colors.html" target="_blank" rel="noopener">16进制颜色介绍</a></p>
<p>将数字转成16进制可以用as.hexmode()这个函数，R=G=B这个颜色将是黑(0)灰白(255)</p>
<p><a href="https://www.rapidtables.com/web/color/html-color-codes.html" target="_blank" rel="noopener">HTML文件中的颜色</a></p>
<p><a href="http://www.sthda.com/english/wiki/visualize-correlation-matrix-using-correlogram" target="_blank" rel="noopener">corrplot</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">guides(fill = guide_legend(reverse = <span class="literal">TRUE</span>)) <span class="comment"># 翻转legend顺序 离散</span></span><br><span class="line">guides(colour = guide_legend(reverse=<span class="literal">T</span>)) <span class="comment"># 翻转legend顺序 连续</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/11774703/adding-text-to-a-grid-table-plot" target="_blank" rel="noopener">如何在打印table并且加上title和footnote?</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 想以一个data.frame的每一列为变量画图，想加图例(并且调整图例的顺序)</span></span><br><span class="line">df &lt;- data.frame(x1 = rnorm(<span class="number">100</span>),x2 = rnorm(<span class="number">100</span>)-<span class="number">0.5</span>, x3 = rnorm(<span class="number">100</span>)+<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ggplot(df)+</span><br><span class="line">  geom_density(aes(x = x1, fill = <span class="string">'liu'</span>),alpha = <span class="number">0.2</span>)+</span><br><span class="line">  geom_density(aes(x = x2, fill = <span class="string">'yu'</span>),alpha = <span class="number">0.2</span>)+</span><br><span class="line">  geom_density(aes(x = x3, fill = <span class="string">'meng'</span>),alpha = <span class="number">0.2</span>)+</span><br><span class="line">  scale_fill_manual(yumeng,values=c(liu=<span class="string">"red"</span>, yu=<span class="string">"blue"</span>, meng=<span class="string">"purple"</span>), breaks = c(<span class="string">'liu'</span>, <span class="string">'yu'</span>, <span class="string">'meng'</span>))<span class="comment"># breaks用来调整图例的顺序</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rug 在基本图中添加数据点所对应的横纵坐标小竖线</p>
</li>
<li><p>geom_bar + errorbar 想画横线在上下：<a href="https://stackoverflow.com/questions/35424162/problem-placing-error-bars-at-the-center-of-the-columns-in-ggplot" target="_blank" rel="noopener">如何对齐</a> <a href="https://stats.stackexchange.com/questions/8137/how-to-add-horizontal-lines-to-ggplot2-boxplot" target="_blank" rel="noopener">如何加横线</a></p>
</li>
</ul>
<p><a href="https://stackoverflow.com/a/18055838" target="_blank" rel="noopener">保存ps半透明图片</a></p>
<h2 id="GGplot："><a href="#GGplot：" class="headerlink" title="GGplot："></a>GGplot：</h2><p>分为七个主要部分：dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.</p>
<ul>
<li>ggplot(data=<data>):负责创建坐标系，之后的图会贴在上面。</li>
<li>aes()里面的可调参数有x, y, color, alpha(color的黑白版), size(单位mm), shape(一个图最多6个，共有0-24种), group(单纯的分组而不加区别)</li>
<li>如果不是想按照某个变量来分组，而是想对所有数据进行统一操作，需要将命令放在aes外面，整个函数里面。</li>
<li>stroke=num: 点的边界宽度</li>
<li>注意连接函数的加号不能放在新一行的开头，要放在旧一行的结尾</li>
<li>facet_wrap(~class, nrow=) 将原有的plot根据class来分成小图</li>
<li>facet_grid(A~B) 将原有的plot根据AB来分成行列小图（A可以为.）这样就变成了nrow=1的facet_wrap</li>
<li>show.legend=FALSE 放在整个函数里面，隐藏图例</li>
<li>可以将geom的函数共同的mapping挪到ggplot函数里面，也可以在随后的函数中重新定义mapping（改变setting）甚至是data（取子集）来覆盖或者增添条件。</li>
<li>coord_flip()坐标系转置（常用于转置箱型图以及处理x名字过长）</li>
<li>coord_quickmap()自动选择x-y的合适比例</li>
<li>coord_polar()极坐标</li>
<li>labs(x=, y=, title=, subtitle=, caption=(底注)) 添加注释，只要是一切能改的</li>
<li>如果想打印数学符号，可以用quote()，更多数学语言的包尽在plotmath</li>
<li>count(data,cut_width(num)): 把关于连续变量的密度图以特定宽度统计个数, cut_number则是以特定数据量进行划分。</li>
<li>coord_cartesian(ylim=c(0,50)):  在画条形图的时候有的x观测量相对之下超小，在图上难以观察，于是用这个函数可以将很矮小的条拉起来。</li>
<li>改变图例的展示方式：guides/guide_legend/guide_colourbar</li>
<li>有时候我们对数据进行log变换，但是这样的话axes就变得不好解释，所以我们可以选择对x和y轴的scale进行变换：scale_x_log10()</li>
<li>theme(legend.position = “none”) 将图例去掉，分散在图中。一般来说position可以取left/right/top/bottom。还有很多其他的theme比如theme_bw（background-white）</li>
<li>colorbrewer这个包针对色盲人群做了优化</li>
<li>如果想对固定颜色种类：scale_colour_manual(values = c(Republican = “red”, Democratic = “blue”))</li>
<li>scale_color_x / scale_fill_x(x还可以特别设为gradient/gradient2/viridis)</li>
<li>ggsave可以保存最近的一张图片，但是大小尺寸都是根据当前窗口自适应的，不是很reproducible，所以我们最好自己固定尺寸</li>
<li>如果想画多个图在一个画板上。将每一个ggplot保存成p1-p4. gridExtra::grid.arrange(p1, p2, p3, p4, ncol=2)</li>
<li>如果想用颜色区分多条线并且加图例：aes(x=x,y=y3,color = ‘y3’) </li>
<li>想自定义颜色的话：scale_colour_manual( values=c(‘springgreen4’, ‘tomato3’, ‘lightskyblue’,’orange’))</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">linetype=<span class="string">"dotted"</span> <span class="comment">#可以决定线的形状</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">annotate(<span class="string">"text"</span>, x = <span class="number">7.5</span>, y = <span class="number">0.9</span>, label = <span class="string">"ratio = 96%"</span>) <span class="comment"># 在图中标记注释</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">theme(panel.background = element_rect(fill = <span class="string">'blue4'</span>), panel.grid.major =element_blank(), panel.grid.minor = element_blank()) <span class="comment">#可以改变背景色+网格</span></span><br></pre></td></tr></table></figure>

<p><a href="https://ggplot2.tidyverse.org/reference/theme.html" target="_blank" rel="noopener">更改theme 比如说字体方向等…</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">scale_fill_discrete(name = <span class="string">"Group Mean"</span>) <span class="comment">#更改legend title</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">scale_x_discrete(limits=c(<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>)) <span class="comment"># 可以改变X轴顺序</span></span><br></pre></td></tr></table></figure>

<p><a href="https://rpkgs.datanovia.com/ggpubr/reference/ggpar.html" target="_blank" rel="noopener">ggpubr</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">theme(axis.text=element_text(size=<span class="number">12</span>),</span><br><span class="line">        axis.title=element_text(size=<span class="number">20</span>)) <span class="comment"># 调大坐标轴字体</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">facet_wrap(~variable,ncol=<span class="number">4</span>,scales=<span class="string">"free"</span>)+ <span class="comment"># 根据variable直接画出多个图而不用grid.arrange</span></span><br><span class="line">  theme(strip.text.x = element_text(size = <span class="number">30</span>)) <span class="comment"># 调整facet_wrap的变量字体</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/46783163/r-ggplot2-boxplots-with-wilcoxon-significance-levels-and-facets-show-only-sig" target="_blank" rel="noopener">Stat_compare_mean如何只画出来显著的变量</a></p>
<h2 id="geom系的函数："><a href="#geom系的函数：" class="headerlink" title="geom系的函数："></a>geom系的函数：</h2><ul>
<li>geom_smooth() 拟合图，method中可选lm, glm, loess… aes中可选linetype=class 来对不同的class进行分别拟合. se=T/F来控制是否画出线周围的灰色置信区域。span越大，拟合图就越光滑</li>
<li>geom_bar()个数柱状图, 可以修改stat=选择其他统计量.bar函数默认的stat是count，同样的，stat_count函数的默认geom也是bar，这种情况下，可以用stat_count来代替geom_bar。color选择外框颜色，fill选择填充颜色(可以等于其他变量，画出分层色彩的柱状图。也可以等于NA，就是不涂色)。<a href="https://stackoverflow.com/questions/30183199/ggplot2-plot-mean-with-geom-bar" target="_blank" rel="noopener">Plot Group Mean</a></li>
<li>bar中position=（identity：每种类别都画出具体位置，但比如有的最小值小于其他的最大值，就会导致重叠的问题。fill：将所有集合都变成高度1，然后内部填充颜色，有助于比较不同集合之间的成分比例。dodge：每个集合都是好几个小柱状图，解决了重叠的问题。Jitter：给每个数据点加一个小随机误差，解决over-plotting问题）</li>
<li>stat_summary()对于每种类别画出一条垂直的竖线，两个端点和中间一个黑点代表着最大值最小值和中位数/均值</li>
<li>geom_jitter()等同于geom_point(position=’jitter’)</li>
<li>geom_count也是来解决over-plotting的，把数据重合点用一个更大的点来表示。也用来画出两个因子变量的联合图</li>
<li>geom_freqpoly(): 另一种密度图像，用线来代替条形。有时候各个类别的个数相差很多，而如果我们想看类别内的分布情况，需要标准化，在ggplot主函数的mapping中令aes(x=price,y=..density..)这样每条线下面的面积都是1</li>
<li>geom_boxplot()：对于无序的变量，可以用reorder(x,y,FUN=median)来根据中位数从左至右排序,varwidth=T用来使每个箱型图的宽度与数据量成正比 <a href="https://stackoverflow.com/questions/33524669/labeling-outliers-of-boxplots-in-r" target="_blank" rel="noopener">如何加outlier的label</a></li>
<li>geom_tile(mapping=aes(fill=n)) 为count填色</li>
<li>geom_bin2d geom_hex 都是对两个连续变量画出分块密度图。前者是方形，后者是六边形（需要安装包hexbin）。</li>
<li>geom_ref_line(h = ?): 添加一条白色指示线</li>
<li>geom_text()是geom_point的扩展板，带个label可以在点附近写东西</li>
<li>geom_label(nudge_y=？)将geom_text里面的文字外面套了一个矩形框，可以将矩形框上移？个单位</li>
<li>但是以上两种geom都解决不了重叠的问题，这时候就要用到ggrepel::geom_label_repel 再配合一下给对应的点圈出来，就很清晰了</li>
<li>geom_rect(xmin,xmax,ymin,ymax): 框住兴趣点</li>
<li>geom_segment(x,y,xend,yend): 画一个箭头</li>
<li>scale_name-of-the-aesthetic_name-of-the-scale: scale一般都会默认选，除非要改变default。scale里面两个重要的参数breaks=和labels = NULL对axes进行操作</li>
<li>geom_vline(): 添加一条竖线</li>
<li>geom_errorbar(aes(ymin=len, ymax=len+sd), width=.2, position=position_dodge(.9))  柱状图中画出置信区间</li>
</ul>
<p><a href="https://ggplot2.tidyverse.org/reference/scale_grey.html" target="_blank" rel="noopener">如何画出灰色图片</a></p>
<p><a href="https://stackoverflow.com/questions/30183199/ggplot2-plot-mean-with-geom-bar" target="_blank" rel="noopener">geom_bar画出groupmean</a></p>
<h2 id="ggpubr"><a href="#ggpubr" class="headerlink" title="ggpubr"></a>ggpubr</h2><p>ggboxplot(data = dat_tmp,x = ‘X’, y = ‘Y’, color = ‘X’, palette = ‘set1’, add = “jitter”,outlier.shape = NA)</p>
<ul>
<li>Add = jitter 可以画出所有点</li>
<li>但是有了add = jitter之后 离群的点会出现两次，outlier.shape = NA 可以只显示一次</li>
</ul>
<h1 id="数据基本处理："><a href="#数据基本处理：" class="headerlink" title="数据基本处理："></a>数据基本处理：</h1><ul>
<li><p>as_tibble(): 将data.frame变成tibble</p>
</li>
<li><p>tibble(x=…, y=…, z=…)：直接生成tibble</p>
</li>
<li><p>print(tibble, width = Inf)这样在打印的时候会把所有列都打出来</p>
</li>
<li><p>tribble：复杂一点但是易读懂的tibble生成方式。<del>x,</del>y,~z  ‘a’,2,3,’b’,4,5…</p>
</li>
<li><p>取某一列的时候可以用$也可以用[]来取出tibble, [[]]来取出数据。如果用pipe方式的话需要加一个点。data %&gt;% .$x</p>
</li>
<li><p>enframe(): 将一个列变量变成一个两列的tibble，有名字的话名字变成第一列，没有的话将第二列复制一遍放在第一列</p>
</li>
<li><p>deframe(): 干的事情和enframe相反，讲一个两列的tibble变成一个向量，第一列被当成名字</p>
</li>
<li><p>data &lt;- read.table(“”,sep=”\t”,header=T,fileEncoding=”UCS-2LE”) 把数据从excel里面拷到txt必须这么输入，要不然会有隐藏字符看不到</p>
</li>
<li><p>read.table() 参数：stringAsFactor=F 不将字符转化为因子  na.strings=”.”  缺失值在这组数据中以”.”来标记  注意read.table默认header=F</p>
</li>
<li><p>scan(“filename”,what=list(data=character(0),high=numeric(0)))</p>
<p>其他参数： n=number nlines=number skip=number na.strings=list 分别表示读取number个数据后停止，读取number行后停止，先跳过number行在读取，将list中的字符串解释为na。scan可以从网页中读取数据</p>
</li>
<li><p>load(‘file’)从本地读进去一个数据。一般都是以.Rdata结尾。.Rdata也是save语句的默认格式</p>
</li>
</ul>
<p>tally 统计group mean</p>
<h2 id="tidyr"><a href="#tidyr" class="headerlink" title="tidyr"></a>tidyr</h2><ul>
<li>gather(xxx, key = ‘a’, value = ‘b’): 如果在tibble的第一行存在一些数据而非数据名（就像2*2联表中的列那样），那么我们就把这些数据放在xxx的位置，为他们产生一个新变量叫做a，而原本的数据框里面的数据也有了一个新的名字叫做b，这样就把这些数据所在的列变成了两列，a和b。可以添加na.rm=T参数</li>
<li>spread(data, key = ‘a’, value = ‘b’): 针对有些时候某一列a中包含的都是变量名，而b列分别存了这些变量的值，所以我们只用这两个参数就可以把数据清洗干净。</li>
<li>separate(data, col1, into = c(‘col2’, ‘col3’), sep = ‘/‘): 若有一列中包含了两列的数据，并且用’/‘字符分隔的，那么我们可以用这个函数将col1分成col2和col3. 如果我们不确定是怎么分割的，可以将sep换成convert = TRUE，我们还可以给sep附一个数字向量，他会在对应的位置进行分割</li>
<li>unite(colnew, col1, col2, sep=’’): 将原来的col1和col2合并成colnew</li>
<li>complete(data,col1,col2): 将col1和col2的所有组合都检查一遍，如果没有的就添加成NA</li>
<li>fill(data, col): 有时候的NA出现是因为想表示这些空的数据跟上面的数据一样，所以就不用再写一遍了。这时候我们可以用fill来告诉计算机col列所有的NA都用在它上面离它最近的数据填充</li>
</ul>
<h2 id="readr"><a href="#readr" class="headerlink" title="readr"></a>readr</h2><ul>
<li>read_csv():逗号分隔。read_csv2()：分号分隔。read_tsv():tab分隔。read_delim()：不管什么分隔都ok。read_fwf()：固定宽度文件（可用里面的参数fwf_widths()来固定宽度，或fwf_positions()来确定位置）read_table():列和列之间用空格分隔。read_log()：apache style还不懂这是什么</li>
<li>read_csv: 默认是把第一行作为列名，所以如果我们不想要开始的n行：skip=n, 我们不想要开头带井号的行：comment=’#’，或者直接这些数据都没有名字：col_names=F. 或者可以col_names=c(…)来创建新的名字. na=’’告诉计算机这个文件中na是以什么方式存下来的。</li>
<li>parse_*(): *可以为logical, integer, double, number, character , factor, datetime, time, date : 将输入的字符转换成其他格式，如果有错的话，可以用problem()来查看为何出错</li>
<li>对于number来说，各个国家地区的书写方式不同，如果小数点不是.而是’,’ 那么我们可以在最后加上，locale = locale(decimal_mark = ‘,’) 同时parse_number()这个函数忽略掉数字前和后的字符，所以如果是123.45，点之后的45会被忽略掉，读成123. 而$100也会读成100. 最后，如果是像美国这种每三个数字就加一个逗号的问题，number可以解决，而对于除了逗号其他的组间分隔符，要用parse_number(‘…’, locale = locale(grouping_mark = ‘?’))</li>
<li>对于strings来说，问题就只有编码的不同产生的问题。现在大家都用UTF-8，但是一些老文件可能不是。所以如果我们知道这些字符的编码，可以用parse_character(… , locale = locale(encoding = ‘某种编码’)) 如果我们不知道编码的话，可以用内置函数来猜。guess_encoding(charToRaw(‘char’)) 其中charToRaw是将char变成源代码。当然大部分情况下他们也猜不准，除非数据量很大。</li>
<li>关于时间。date返回从1970-1-1以来的天数。date-time返回从1970-1-1以来的秒数。time返回从前一天晚上12点到现在的秒数. date-time接受八位加T加六位的字符。date接受八位，time接受六位。（都是默认，可以根据情况不同而有所调整）。关于时间还有很多灵活地参数表示，这里先不说了…R4ds书上P135有说到。</li>
<li>guess_parser()来猜测某个字符是什么类型。parse_guess()用猜测的类型进行parse</li>
<li>readr工作的时候会选取前1000列来guess（代码中guess_max=1000），再用guess的结果进行parse，但有时候前1000行不具有代表性，所以问题就来了，这时候我们可以用problems(x)或者stop_for_problems(x)进行查验，并对col_types = cols(x=col_double()…) 放入readr中重新读。因为readr只查前1000，我们也可以用tail(data)来检验一下最后的几条数据看看是否符合预期。有时我们也用col_types = cols(.default = col_character()) 全部读成character，再用type_convert进行修正。</li>
<li>写出函数：write_csv(), write_tsv(). 默认采用UTF-8编码。如果我们想输出一个CSV文件给excel 可以用write_excel_csv()会在文件的开头告诉excel我们是用UTF-8进行编码的。但是以上类型会在有NA的时候出一些小问题。这里我们引入一种专为R应用的函数write_rds()&amp;read_rds(),文件也要以rds为后缀。还有一种方法是所有编程语言通用的feather格式。write_feather()和read_feather()同样需要后缀为feather.</li>
<li>其他格式：haven:读spss和sas文件。readxl：读xls和xlsx文件。DBI（以及RMySQL，RSQLite，RPostgreSQL）可以对数据跑SQL语句并且返回一个data.frame. jsonlite: for JSON. xml2: for XML</li>
<li>readfwf :像SAS一样按照固定的格式读取文件：fixed with format</li>
</ul>
<p>##dplyr:</p>
<ul>
<li>tibbles格式是一种特殊的data.frame(四种基本格式：int整数，dbl实数，chr字符，dttm日期加时间，lgl逻辑，fctr类别，date日期)</li>
<li>between(x,left,right): 判断x是否大于等于left小于等于right，返回逻辑值</li>
<li>rename(data, new_name=old_name) : 对列改名</li>
<li>inner_join对于key只在x或者y的数据予以删除。outerjoin中left_join保留x中所有，right_join保留y中所有，full_join保留全部。</li>
<li>对于left_join.如果key是一对一，一对多，多对一都ok。但是如果是多对多的时候，会产生笛卡尔积。</li>
<li>left_join选择key的方式，默认是by = NULL 即对xy所有重合的列名进行join，第二种by=c(‘col’)根据选定的key进行join，第三种by=c(‘a’=’b’)对于x中的a和y中的b进行比较。</li>
<li>merge(x,y, all.x = T, all.y = T)和join系列效果一样，只不过join系列一是看得清楚，二是算得快并且不容易出错。SQL也能做，但是看不懂，先不嗦了</li>
<li>semi_join(x,y) 保留x中所有match了y的观测值。anti_join(x,y)丢掉x中所有match了y的观测值</li>
<li>intersect() ,union() ,setdiff(x,y). 最后一个函数返回x\y .集合语言可以对tibble的观测值进行作用</li>
</ul>
<p>###六种基本函数</p>
<p>格式：第一个位置放置data.frame，后面的都是用不加引号的变量名对数据进行操作，最后返回一个data.frame。</p>
<ul>
<li>filter():根据变量筛选观测值集合. 注意filter会自动去掉逻辑式中False和NA的观测值，如果需要保留NA，则要使用is.na() | xxx</li>
<li>arrange()：将观测值以某些指标进行排列.默认升序，降序用desc(col.names). NA会被放在最后</li>
<li>select()：选出特定变量. -(name1:name2) 表示去掉name1到name2中间的全部列。还可以用其他辅助函数：starts_with(‘xx’), ends_with, contains(), matches(‘’)满足特定正则表达式，num_range(‘x’,1:3)选出x1,x2和x3, one_of(vars)选出字符表示的列名集合（但我发现不用one_of直接对vars进行select也OK）。式子最后加上everything()：把前面选择的变量移到列的最前面，相当于不仅选出了特定变量，还补上了其他未选择的变量。如果想区分大小写，在match类函数里面添加：ignore.case=F</li>
<li>mutate()：根据已有变量产生新变量. 如果只想保留新变量，使用transmute(). 将一些异常(大于0的)观测值填写成NA：mutate(y=ifelse(y&gt;0,NA,y))</li>
<li>summarize()：将多个变量浓缩成一个统计量, 常与group_by连用. 里面的函数n()返回观测值的个数，n_distinct()返回不同的观测值的个数。计数还可以用count(,wt=…)代替summarize()</li>
<li>group_by()：将命令对每个分组作用, 想去掉分组用ungroup(). </li>
<li>nest：常与group_by连用，在tibble里面生成小tibble.使用unnest(data, varaible) 来变回常规tibble. 还有一个用法是nest(col1:col2): 将col1到col2中间的列都捆绑起来</li>
</ul>
<h1 id="stringr字符"><a href="#stringr字符" class="headerlink" title="stringr字符"></a>stringr字符</h1><p>很多stringr的函数都有第二个版本_all ：works with all matches</p>
<p>stringi包是stringr的扩充版，函数从42个增加到了234，遇到了棘手的问题可以试着从stringi中找一下，函数名称的开头也会变成stri_…</p>
<ul>
<li>有时候console里面打印出来的字符不是他本来的样子，要用writeLines()</li>
<li>r4ds作者建议用双引号来引用字符。</li>
<li>?”‘“ 或者 ?’”‘ 都可以来查看一系列关于各种字符的表达</li>
<li>str_length(): 求字符长度</li>
<li>str_c()：combine字符，相当于paste。如果想让NA变成字符型的NA打印或者操作，使用str_replace_na(x)。把一个字符向量变成一个字符：collapse = “,”</li>
<li>str_sub(str, start, end): subsetting，注意这个str_sub不是创建了一个新的变量而是提供指针，这样的话如果你对sub之后的字符进行了修改，那么原来的字符也会被修改</li>
<li>str_to_lower()/ str_to_upper()/str_to_title: 全部变成小写/大写/首字母大写。但是不同语言的大小写可能略有不同，需要通过locale = “en” 来获得robust的结果。str_order和str_sort比起原生的排序也是多了locale可以选择。</li>
<li>str_trim(): 去掉字符开始和结尾的空格。</li>
<li>str_wrap(): 把字符变成一个格式化段落</li>
<li>str_view(x,’match’): 用来可视化匹配结果</li>
<li>str_detect(): 判断是否匹配，返回逻辑值</li>
<li>str_count(): 返回一个数字，匹配了多少次。注意match不会重叠。str_count(“abababa”, “aba”) <em>#&gt; [1] 2</em>  而不是三个</li>
<li>str_subset(): 选出匹配的字符们</li>
<li>str_extract(): 将Match的部分提取出来（默认值是第一个match的）。如果想提取出来所有的match，用str_extract_all()会返回一个列表，可以加上simplify = T 就会变成一个矩阵，宽度用NA填补成最长宽度来对齐。</li>
<li>str_match()&amp;all: 分组匹配，返回一个矩阵。第一列是str_extract的所有组合在一起的完整内容，后面每一列是每一组分别的内容。如果数据集是一个tibble，可以用tidyr::extract(tibble, name-of-matches, matches, remove = F)来代替str_match.(remove的意思是是否删除原tibble)</li>
<li>str_replace()&amp;all: 用给定字符替换匹配字符。可以用c(‘match1’=’new1’,…)来建立一个多维替换。还可以用分组的方法调换位置。str_replace(“([ ^ ]+) ([ ^ ]+)”, “\\2 \\1”)</li>
<li>str_split(“分隔符”): 进行切割，返回一个list。可用simplify = T 来返回一个Matrix。参数n=几，可以固定最多切成几份。可用boundary(“word”)作为match来选中所有的单词而忽略标点以及空格。</li>
<li>str_locate()&amp;all: 返回每个match的开始和结束位置</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>. 匹配任何字符（except a newline）但是我们如果只想匹配”.”这个字符，需要变成「\\.」第一个斜杠告诉计算机我们现在是特殊字符，第二个斜杠保护了”.”不会单独出现。想要match一个「\」我们需要用四个「\」</li>
<li>锚定：”^”从字符的开始进行匹配，”$“从字符的结尾开始匹配：记忆口诀：<em>if you begin with power (<code>^</code>), you end up with money (<code>$</code>).</em> 如果想让正则表达式只匹配全字符，可以同时加上^和$。</li>
<li>match the boundary between words with \b</li>
<li>\d: 匹配一个数字。\s: match white space（space/tab/newline）\S:匹配所有非空白 [abc]: match a,b, or c. [ ^abc]: match anything except a,b, or c. 注意前两个带斜杠的在match的时候都需要再加一个斜杠</li>
<li>abc|xyz 可以match到”abc”或者”xyz” 复杂的式子中可以加上圆括号，例如 “gr(e|a)y” 都可以match到灰色</li>
<li>repetition：一个match可以用几次。?可以用0或1. +可以用1或更多。*可以用0或更多。还可以特意指定匹配多少个。{n}：正好n个。{n,}：n或更多。{,m}：最多m个。{n,m}：在n和m之间。（在有三个匹配项时，{2,3}最后还是会匹配三个，说明匹配的时候默认是越多越好。可以再、在最后添加一个问号”{2,3}?”来变成匹配的越少越好）</li>
<li>可以使用斜杠来分组\1\2… 注意在匹配时还是要多加一个斜杠。</li>
<li>再用str函数的时候，匹配的”match”其实都是regex(“match”)的缩写版。regex函数还有很多参数：ignore_case = T. multiline = T（让^和$ match每一行的开始和结束而不是整个字符的开始和结束）dotall = T (允许”.” match everything including \n)</li>
<li>regex()的替代品们。fixed()：能让我们告别复杂的斜杠并且算的比正则式快，只能match一模一样的，但对于一些含有音调的字母的多种表达方式可能会不识别。coll()太复杂了感觉暂时不用学。</li>
<li>apropos(‘replace’): 常用来选出带有特定字符的函数（带有replace的）</li>
<li>dir(pattern = ‘正则式’)：在目录中搜索文件，返回match的文件名</li>
<li>AB*表示的是一个A加n个B，n为自然数</li>
<li>(Y|F)(.)\2：匹配Y或者F，后面跟上两个一样的字符</li>
<li>[A-T]匹配A到T，但(A-T) 匹配「A-T」</li>
<li>grep函数如果匹配不到的话，会返回长度为0的东西，可以用length()来catch</li>
</ul>
<h1 id="forcats因子变量"><a href="#forcats因子变量" class="headerlink" title="forcats因子变量"></a>forcats因子变量</h1><ul>
<li>创建因子变量：factor(char, levels = …) 对于不在levels里的字符会自动转成NA（对于这种情况如果需要error提示的话，可用readr::parse_factor代替factor）</li>
<li>对于levels的顺序，默认是字母表顺序，如果想按照char本身出现的顺序来排序的话，方法1：factor(char, levels = unique(char)) 方法2： fct_inorder(factor(char))</li>
<li>对于tibble中的因子变量，可以用count来轻松看到有哪些levels，数量各是多少。或者可用geom_bar(). 默认ggplot会将数据量为0的类别在图中删去，可以+scale_x_discrete(drop = F)来强制显示</li>
<li>modifying factor order: fct_reorder(f,x, fun) f是要修改的变量。x是一个向量，按照从小至大的顺序对f重新编排。fun：如果对于一个f有多个x跟他对应，那么默认value=median</li>
<li>fct_relevel(f, level1)：将level1移到所有level最前面。</li>
<li>fct_reorder2(f, x, y): 根据x取到最大值时y的取值进行排序。（画图完interpret的时候常用）</li>
<li>fct_rev(): reverse</li>
<li>fct_infreq(): 按照频率，从大到小排序。（一般还是从小到大舒服，所以配合fct_rev使用）</li>
<li>modifying factor levels: fct_recode(f, “new”=”old”) 可以将多个old指向同一个new</li>
<li>fct_collapse(f, “new”=c(“old1”, “old2”, …)): 快速的进行多个old指向一个new的操作</li>
<li>fct_lump(): 默认会将多个迷你组合，合并成一个小组，并且保持他仍然是最小的组合。我们可以加上参数n=几，来告诉他合并之后保留几个组</li>
<li>增加一个factor的level可以用c连接，删除的话只需要再z1$INCNONW1&lt;-factor(z1$INCNONW1) 留下用到的level</li>
</ul>
<h1 id="lubridate时间"><a href="#lubridate时间" class="headerlink" title="lubridate时间"></a>lubridate时间</h1><ul>
<li>today(): 获取当前日期。now(): 获取当前日期+时间</li>
<li>从字符或数字变成日期+时间：m/d/y + _ + h/m/s的任何一个排列组合都是一个函数。参数tz = “Timezone”</li>
<li>make_date/make_datetime(year=, month=…): 如果时间的每个部分被存在了不同地方，用这个函数。</li>
<li>as_date/as_datetime(): 在两种格式的时间中相互转换。也可以把从1970-1-1开始的天数/秒数转换成时间。</li>
<li>year/month/mday/yday/wday(time): 从一个时间变量里面抽取信息也可以进行赋值。对于month/wday 可以选择label=T返回英文，abbr=F返回全称。</li>
<li>floor/round/ceiling_date(time, “unit”): 四舍五入到最近的单位</li>
<li>如果是对多项指标同时修改/赋值的话可以使用update(time,year=…)，如果赋值超过上界，会被直接加到下一个时间单元</li>
<li>在r中如果时间减去时间会得到一个difftime变量，但是由于时间的单位可以是秒分时天..很难处理，所以用as.duration将他变成秒。</li>
<li>duration家族还有：dseconds/dminutes/dhours/ddays/dweeks/dyears都是将对应的后缀变成秒，duration可以进行加减乘除。</li>
<li>period家族：seconds/minutes/hours/days/months/weeks/years时间单位是多种多样的，也可以加减乘除</li>
<li>intervals：(start %–% end) : 是一个有开始结束点的时间段，多用于时间段相除</li>
<li>Sys.timezone(): 查看当前时区</li>
<li>除非特殊表明，否则lubricate采用UTC时间。想变换时区（时间会随之更改）：with_tz(time, tzone = “continent/city”)。想变换时区（时间不会变）：force_tz(time, tzone = “continent/city”)</li>
</ul>
<h1 id="modelr模型"><a href="#modelr模型" class="headerlink" title="modelr模型"></a>modelr模型</h1><ul>
<li>data_grid()：求出离散数据的自变量集合。.model可以添加模型信息</li>
<li>seq_range()：求出连续数据的模拟自变量集合. pretty = T 可以使output更加好看。 trim=0.1 会把两端10%的数据去掉（总共去掉20%的数据）expend = 0.1 与trim相反，将两端拉长5%（合在一起是0.1）</li>
<li>add_predictions(data, model) 根据自变量和模型算出预测值并进行连接</li>
<li>add_residuals(data, model) 跟上一个函数同理</li>
<li>可视化残差的方法：geom_freqpoly 或者 画散点图和 y=0进行比较</li>
<li>model_matrix 生成设计矩阵</li>
<li>对于多个model来说 有gather_prediction/spread_prediction. 前者是多出一列mod类型（分为1和2）一列是预测值。后者直接多出来两类预测值，所以前者窄长，后者扁宽。</li>
</ul>
<h1 id="回归分析："><a href="#回归分析：" class="headerlink" title="回归分析："></a>回归分析：</h1><ul>
<li>如果formula里面带有加减乘除等符号，要用I()括起来</li>
<li>再用poly的时候，有时候因为不可导会导致设计矩阵出现正负无穷。这时候用splines::ns(x, n)来代替poly(x, n)</li>
<li>有缺失值的时候一般R都会默默地不出声自动drop掉那一行，options(na.action = na.warn) 会在drop之后给出一行warning。options(na.action = na.exclude)还原。</li>
<li>nobs(formula)可以查看某个fit到底使用了多少个观测值（number of observations）</li>
<li>常用的模型：lm/glm/gam(generalized additive model)/penalized(glmnet)/rlm(robust)/tree</li>
<li>lm(v1<del>I(v2 * v3))真的是v2乘v3。但如果是lm(v1</del>v2 * v3)就会有v2,v3,以及v2:v3</li>
<li>rstudent 返回fit之后的残差</li>
<li>xtabs可以根据不同字符型变量组合生成01的设计矩阵</li>
<li>sigma(fit)可以返回fit的standardized residual</li>
<li>Logistic: glm(formula, family = binomial( link = ‘logit’ ))</li>
</ul>
<p>aov函数默认给出type1，anova函数默认给出type2，type2&amp;3可以用car::Anova(type = c(‘II’,’III’)) 来使用</p>
<p>conf.int获得置信区间</p>
<h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><ul>
<li>prcomp函数</li>
<li>biplot可以画出PCscores and loadings- 二维图只能选择前两个PC</li>
<li>pls::pcr </li>
<li>validationplot</li>
<li>princomp 可以直接给出loadings 需要用<code>fit2$loadings[]</code>取出matrix形式<ul>
<li>这个函数即使定义了cor = F, 也会自动中心化score矩阵</li>
</ul>
</li>
<li><a href="http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/112-pca-principal-component-analysis-essentials/" target="_blank" rel="noopener">PCA画图很好看</a></li>
</ul>
<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><p>主要用的包有TSA/latticeExtra</p>
<ul>
<li>lattice::xyplot 可以画出时间序列图。比plot好看一点点点</li>
<li>TSA::as.ts 将向量变成时间序列</li>
<li>xyplot(hours, panel = function(x, y, …) {panel.xyplot(x, y, …) panel.text(x = x, y = y, labels = months)}) 标出各个月份的信息</li>
<li>harmonic fit一个cosine-trend</li>
<li>densityplot&amp;qqmath判断是否正态</li>
</ul>
<p>Econometricians often talk about a time series being <em>integrated with order k, I(k)</em>. <em>k</em> being the minimum number of differences required to obtain a stationary time series. forecast::nsdiffs() 可以做ADF test</p>
<p>R output 的 ma 和 ar 都是 等式右面直接的值。</p>
<p>tsdiag 返回更详细的诊断</p>
<h1 id="Stat471"><a href="#Stat471" class="headerlink" title="Stat471"></a>Stat471</h1><p>ecoreg::gauss.hermite(k) 获取g(x)的多项式分解。同样还有integrate.gh</p>
<p>预分配数据框——有助于提高运算速度：<br>N&lt;-1000000<br>dfrm&lt;- data.frame(dosage=numeric(N),lab=factor(N,levels=c(“A”,”B”)))</p>
<p>根据位置选择数据框的列：<br>dfrm[[n]]=dfrm[,n] 返回第n列<br>特别的，dfrm[,n,drop=FALSE] = dfrm[n] 返回一个数据框，元素为第n列<br>dfrm[c(n1,n2)]=dfrm[,c(n1,n2)] 返回一个数据框，元素为第n1和n2列</p>
<p>根据条件更便捷的选定行和列： subset(dfrm,select=c(colname1,…,colnameN))<br>subset(dfrm,select=c(predictor,response),subset=(response&gt;0))</p>
<p>直接编辑数据框：①temp&lt;-edit(dfrm) dfrm&lt;-temp  ② fix(dfrm)</p>
<p>从数据中移除包含NA值的一整行： new&lt;-na.omit(dfrm)</p>
<p>根据名称排除列： subset(dfrm,select= c(-badboy,-patient.id))</p>
<p>根据共有列合并数据框： new&lt;-merge(born,died,by=”name”)</p>
<p>对于快速一次性使用数据框内的数据，可以不用attach&amp;detach ： with(dataframe,expr)<br>z&lt;-with(data,(pop-mean(pop))/sd(pop))<br>但注意attach之后就别对原数据进行操作了，因为无法改变原来的值。只能将值调出来赋给新的变量。</p>
<p>【重点】不同类型的数据转换，P156页： 首先要记住可以单独用cbind/rbind 来达到转换成行/列的效果</p>
<p>nls可以根据特定形式的函数进行最小二乘拟合，用coef来提取参数</p>
<p>mvnormalmixEM 可以计算多元正太的EM</p>
<p>5.5</p>
<p>基础篇（4）</p>
<p>split(列表的一行，列表的另一个用来分类的行)<br>unstack(data.frame(列表的一行，列表的另一个用来分类的行))  用来对列表中向量进行分组</p>
<p>对列表的每一个元素进行操作：用lapply/sapply s是简化的意思<br>对列表的每一行进行操作：apply(list,1,f) 其中1表示行，2表示列，c(1,2)表示行和列<br>tapply(data,factor,fx) 对列表的某一列按照另一分组的列进行分类并操作<br>by(data,factor,fx)  把整个数据框按照某一分类方式进行分类并操作<br>mapply 将函数应用于多维向量上 mapply(gcd,c(1,2,3),c(9,6,3))</p>
<p>第七章：字符串和日期：</p>
<p>获取字符串长度： nchar()</p>
<p>连接字符串 paste(“”,””,sep=””)<br>paste(c(“a”,”b”),”c”,sep=”e”,collapse=”f”)  输出结果：[1] “aecfbec”</p>
<p>提取字符串： substr(string,start,end)</p>
<p>根据字符中有的分隔符来分割字符串：  strsplit(“LOVE”,””)  可能的拓展参数 fixed=TRUE</p>
<p>将字符串中的某些字符替换成其他字符：<br>sub(old,new,string)  将string中第一个old找出来替换成new<br>gsub(old,new,string) 将string中所有old都替换成new</p>
<p>针对某些特殊字符，如”first\rsecond\n” 使用函数print和cat输出的结果是不一样的</p>
<p>生成两组字符串的笛卡尔积：  m&lt;-outer(strings1,strings2,paste,sep=””)<br>此法生成一个矩阵，可用as.vector变成一个向量<br>用m[!lower.tri(m)]可以去掉m矩阵的下三角中所有元素 （上三角为upper.tri）</p>
<p>得到当前日期： Sys.Date()  </p>
<p>将字符串转换为时间： as.Date(“12/31/2016”,format=”%m/%d/%Y”)</p>
<p>改变时间输出格式：  format(Sys.Date(),format=”%m/%d/%Y”)</p>
<p>%b 缩写的月份名称 %B完整的月份名称 %d两位数字的日期 %m两位数字的月份 %y没有世纪的年份 %Y有世纪的年份</p>
<p>生成给定数字的时间： ISOdate(年，月，日，小时，分钟，秒) 可在外面套上一层as.Date将具体时间变成为某一天</p>
<p>将时间变成从1970-1-1以来的天数： julian(date)/as.integer(date)</p>
<p>要具体知道某一天的其他信息（如它是一年中的第几天，是个星期几…）p&lt;-as.POSIXlt(date)<br>参数p$: sec,min,hour,mday(该月的天数),mon,year(from1900),wday(0~6—0为周日),yday(该年的天数),isdst(夏时令标记)</p>
<p>创建日期序列： seq(from=d1,to=d2,by=天数/“month”,length.out=多少天)</p>
<p>5.6<br>第八章：概率<br>dnorm正态密度 pnorm正态的分布函数（累计概率） qnorm正态分位数 rnorm正态分布随机数<br>binom二项分布 geom几何分布 hyper超几何分布 nbinom负二项分布 pois泊松分布<br>beta贝塔 cauchy柯西 chisq卡方 exp指数 f-F分布 gamma伽马 lnorm对数正态 logis逻辑分布 t—T分布 unif均匀分布 weibull威布尔分布 wilcox-Wilcoxon分布</p>
<p>combn(items,k) 从items里面抽k个出来，把所有组合排列出来</p>
<p>生成随机样本序列： sample(vec,n，prob=c(…))</p>
<p>d+分布为独立概率，q+概率能求分位数  p+分布为累计概率，在参数中添加 lower.tail=F表明求出互补概率1-P</p>
<p>diff(pbinom(c(3,7),size=10,prob=0.5)) 可以求出在3~7之间的概率  但diff并不是绝对值</p>
<p>polygon(region.x, region.y, density=) 可以为图形填充阴影</p>
<p>第九章：统计概论</p>
<p>统计惯例：选择显著水平α=0.05 则计算出p值小于0.05拒绝原假设，p&gt;0.05不拒绝</p>
<p>summary不提供关于数据波动方面的信息，所以要自己加上sd()等</p>
<p>计算相对频数：mean(逻辑判别式)  如：mean(x&gt;0)  此法也可用来求逆分位数</p>
<p>table(f1,f2) 将数据按照f1,f2的因子类进行计数，形成一个列联表</p>
<p>检验分类变量的独立性： summary(table()) 观察结果中的p值</p>
<p>为了保证一个有意义的置信区间或者是T检验，在数据&lt;30个的时候要保证数据是服从正态分布的</p>
<p>中位数的置信区间： wilcox.test(x,conf.int=T)</p>
<p>问题：有一组数据由失败与成功构成，你认为成功的比例是p，你需要用样本数据来检验<br>prop.test(x,n,p，alternative=”greater/less/two.sided”) 记得要将想证明的结论放在对立假设<br>prop.test(x,n)可以输出一个比例的置信区间</p>
<p>游程检验——一个序列是否是随机的：<br>library(tseries)<br>runs.test(as.factor())</p>
<p>比较两组样本的均值： t.test(x,y,paired=, var.equal= )</p>
<p>两个总体具有相同的图形形状，但他们的均值是否相同呢？：wilcox.test(x,y,paired=)</p>
<p>检验相关系数的显著性: cor.test(x,y)  对于非正态总体： cor.test(x,y,method=”Spearman”)</p>
<p>两组数据都由成功/失败组成，我想知道这两组是否具有相同的成功比例：prop.test(每一组的成功个数，每一组的总数)</p>
<p>把一些样本的均值与其他任何一个样本的均值进行比较：pairwise.t.test(data,factor)</p>
<p>两个样本是否取自同一个分布？： ks.test(x,y)</p>
<p>17.11.7<br>grep(pattern = “j”, x = a, ignore.case=F, value = TRUE)取出特定字符，ignorecase表明去不区分大小写，value意思是输出字符还是输出字符的位置<br>sub(pattern = “e”, replacement = “E”, x = a)只替换每个字符第一个出现的位置 gsub替换所有<br>coef(summary(lm))也是一种输出系数的方法<br>lm(xx<del>0+yy,data=?)/lm(xx</del>yy-1,data=?) 不要截距<br>lm(xx~(.-1),data=?) 彻底不要截距  (.-x)去掉x之外其他的进行拟合</p>
<p>ggplot:<br>    ggplot之后是什么也没有的，需要通过+geom_bar()等一系列来输出<br>    例子①ggplot(mpg, aes(cty, hwy)) +geom_point(aes(color = drv, size=cyl), shape=19, alpha=0.5)<br>    例子②ggplot(a,aes(carb,optden))+geom_point()+geom_smooth(method=lm)</p>
<p>多项式线性拟合 <del>poly(x,n)<br>confint(lm,level=0.95)给出置信区间<br>model.tables(av1, type=”means”) 可以给出aov()各个分类的均值（默认的是给出系数）<br>xtabs(</del> wool + tension, warpbreaks) 给出wool和tension每个类别都有多少个观测值<br>model.matrix输出设计矩阵<br>invisible(capture.output(y &lt;- ff(2))) 可以隐藏赋值语句中自带的print<br><strong>reformulate</strong>(paste(“X”, 1:p, sep=””), “Y”) 可以自动输出线性回归的格式：Y~X1+…+Xp<br>faraway包里面有Cpplot<br>leaps包里有leap，可以算Mallow’s Cp</p>
<p>fit1&lt;-rpart(lowbwt~.,data=test0,parms=list(split=”information”,<br>loss=matrix(c(0,1,5,0),byrow=TRUE,nrow=2)))  可以用来在rpart里面添加misclassification cost</p>
<h1 id="R-Markdown"><a href="#R-Markdown" class="headerlink" title="R-Markdown:"></a>R-Markdown:</h1><ul>
<li>一个星号包围是斜体，两个星号包围是粗体，code是用斜点包围</li>
<li>上标用^包围，下标用~包围</li>
<li>无序列表使用一个星号加两个tab，子列表分别在星号前面加上tab</li>
<li>有序列表1.加tab 并且后面的数字也都是1. Rmarkdown会自动修正</li>
<li>新建代码chunk可以用insert和cmd+alt+I. chunk的名字在r加一个空格之后输入。如果一个chunk起名叫setup，那么不管运行哪一个chunk，这个chunk都会被先运行一遍</li>
<li>options们：eval = FALSE:这框框的代码不会被计算(evaluate)但是会显示。include = FALSE：跑代码但是不显示代码或者结果。echo = FALSE：跑代码，不显示代码，显示结果。message = FALSE/warning = FALSE：让最后的结果不显示message和warning。results = ‘hide’：隐藏printed output。fig.show = ‘hide’：隐藏plot。error = TRUE：如果这个chunk坏了那么还会继续运行其他chunk的内容。</li>
<li>knitr::kable(): 使得表格打印效果更好，同类函数包还有xtable, stargazer, pander, tables, ascii</li>
<li>如果某个工程运行一次耗时很大，可以加上cached=TRUE来让运行的结果存起来，只要代码没变，之后运行的时候就不会重复计算。但有时这个chunk要接受其他chunk的结果，其他chunk如果变了的话是发现不了的，所以可以加上 dependson =’chunk name’ 另外如果有读文件的操作的话，文件的修改也是不能被发现的，可以加上cache.extra=file.info(). 最后记得清理：knitr::clean_cache()</li>
<li>可以通过knitr::opts_chunk$set()来修改默认的option</li>
<li>在R-markdown中添加数字可以用format(x, digits=2, big.mark=’,’)等来规范格式</li>
<li>如果我们在文字中想添加一些简短的数据信息(比如一个dataframe的行数)，这时候重开一个chunk显然不是最好的做法，可以用r+空格+语句并用斜点来包围</li>
<li>要注意有时候markdown的working directory和主环境的wd不是一个，可能会导致一些错误</li>
<li>可以设置全局参数，在三个断线分隔的开头，加上 params: my_class:”suv” 这主要是想批量产生一些markdown文件，具体详见P437.书上的后一页有一些关于在markdown结尾加上注释和参考文献等信息，暂时也用不到</li>
<li>图像的大小参数：老哥推荐的default: fig.width=6 fig.asp=0.618 out.width = “70%” fig.align = “center”。如果是多个图的话out.width = “50%”/“33%”/“25%” + fig.align = “default”</li>
<li>fig.show = “hold” 可以将图片强制放在代码的最后，而不是插在中间</li>
<li>fig.cap 可以添加caption</li>
<li>dev = “png” 损失了一点图片质量，但是可以换来效率。否则图片是pdf格式</li>
<li>不同格式的帮助文件 ?rmarkdown::html_document()</li>
<li>对于html文件，可以隐藏代码并且可以通过点击来打开：output：+回车+html_document: +回车+ code_folding:hide</li>
<li>{r include=FALSE, cache=FALSE} 不显示任何输出：<em># 可用来载入library</em></li>
<li>用$和$$包围Latex可以得到行间或者单独的公式。后面那个$符号前面不能带空格</li>
<li>换行用大于等于两个空格+回车或者两个回车</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;&#123;r, out.width &#x3D; &quot;400px&quot;&#125;</span><br><span class="line">knitr::include_graphics(&quot;path&#x2F;to&#x2F;image.png&quot;) #调整插入本地图片大小</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.datadreaming.org/post/r-markdown-theme-gallery/" target="_blank" rel="noopener">打印出来不同主题</a></p>
<p><a href="https://stackoverflow.com/questions/33965560/r-markdown-table-with-a-caption" target="_blank" rel="noopener">表格的title</a></p>
<h1 id="杂七杂八的问题"><a href="#杂七杂八的问题" class="headerlink" title="杂七杂八的问题"></a>杂七杂八的问题</h1><ul>
<li><p>当错误信息是中文的时候：</p>
<p>Sys.setenv(LANGUAGE = ‘en’) 再跑一遍程序，然后谷歌</p>
</li>
<li><p>手动更新某个包：tidyverse_update()</p>
</li>
<li><p>?也可以应用在内置数据集上，帮助文档会显示出每列的含义</p>
</li>
<li><p>Over-plotting: 很多函数在画图的时候用了取整，导致很多数据点重叠。</p>
</li>
<li><p>NA stands for ‘Not Available’</p>
</li>
<li><p>seriation包对两个因子变量同时排序，d3heatmap和heatmaply也是关于探求双因子变量关系的包</p>
</li>
<li><p>一般来说，注释#是用来解释why而不是what和how。</p>
</li>
<li><p>想看if的帮助文件需要加上``</p>
</li>
<li><p>对于R里面的函数如果没有调用的话，它甚至都不会生成（lazy evaluation）。</p>
</li>
<li><p>好像对于函数可以用testthat包来进行模拟测试，不太会用以后可以看看</p>
</li>
<li><p>traceback(): prints the functions called that generate the error.</p>
</li>
<li><p>经常在自己的函数里面加一个check输入格式的部分，使之变得robust</p>
</li>
<li><p>options(warn=-1/0) 可以将warning藏起来/显示</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">assign(paste(<span class="string">'X'</span>, i, sep=<span class="string">''</span>), <span class="literal">NULL</span>) <span class="comment">#这段代码可以配合for循环快速产生变量Xi</span></span><br></pre></td></tr></table></figure>

<p>加载包的时候有时候会显示: <code>Reason: image not found</code> </p>
<ul>
<li>解决方法<a href="https://github.com/rstudio/rstudio/issues/2254" target="_blank" rel="noopener">关于rjava</a> ：<code>sudo R CMD javareconf</code></li>
</ul>
<p><a href="https://stackoverflow.com/questions/23050928/error-in-plot-new-figure-margins-too-large-scatter-plot" target="_blank" rel="noopener">Error in plot.new() : figure margins too large</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lapply(paste(<span class="string">'package:'</span>,names(sessionInfo()$otherPkgs),sep=<span class="string">""</span>),<span class="keyword">detach</span>,character.only=<span class="literal">TRUE</span>,unload=<span class="literal">TRUE</span>) <span class="comment"># detach_all_packages</span></span><br></pre></td></tr></table></figure>

<p>我们对一个factor变量，即使把某一类全部删去了，当我们打印的时候，那个空白的level还在里面。这会让plsDA函数失效</p>
<p><a href="https://d.cosx.org/d/419420-r-markdown-pdf/2" target="_blank" rel="noopener">rmarkdown: Unicode char \u8:骞?not set up for use with LaTeX.</a></p>
<p><a href="https://stats.stackexchange.com/questions/11109/how-to-deal-with-perfect-separation-in-logistic-regression" target="_blank" rel="noopener">logistic出现perfect separation</a></p>
<p>有的github包装不上，需要先加载remote包：<a href="https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa" target="_blank" rel="noopener">https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa</a></p>
<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><ul>
<li>mc2d::rtrunc:  truncate distribution generator</li>
<li>if(!require(“astro”)) install.packages(“astro”) 来检测包</li>
</ul>
<p>reshape里面辅助ggplot可以画出来相关系数热度图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cm = cor(dat1[,-<span class="number">1</span>])</span><br><span class="line">melted_cormat &lt;- melt(cm)</span><br><span class="line">ggplot(data = melted_cormat, aes(x=X1, y=X2, fill=value)) + </span><br><span class="line">  geom_tile()</span><br></pre></td></tr></table></figure>

<p><strong>DiagrammeR:</strong> 用来画各类流程图</p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul>
<li>ctl+alt+上：将光标变长，可以好几行一起编辑</li>
<li>在console里面使用cmd+上：可以查看最近敲过的代码</li>
<li>在出现备选函数名的时候，敲击回车或tab都可以选中。</li>
<li>cmd+shift+P: 重新发送刚刚的代码到console</li>
<li>cmd+shift+R: 添加代码之间分隔线</li>
</ul>
<p>#======xxx======== 可以创建可折叠代码段</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>R</category>
      </categories>
  </entry>
  <entry>
    <title>Linux心得</title>
    <url>/2020/07/02/Linux%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>学679的时候记录的学习笔记。后来我将Mac的一些操作也加了进去。</p>
<a id="more"></a>



<h1 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h1><p>cd /workspace 前面那个slash目的是回到主界面在进入workspace 而不是进入当前目录下的workspace<br>rm -rf 直接删除所有类型的文件<br>ssh <a href="mailto:siyuw@lunchbox.stat.wisc.edu">siyuw@lunchbox.stat.wisc.edu</a><br>ls -l: ①文件夹d其他-②read③write④是否可执行 可执行x ⑨最后三个说的是其他人<br>ls -lt 按修改时间倒序排列<br>cat语句可以连接两个文件<br>clear:清屏<br>shuf —-help 可以从一个文件随机选出几行</p>
<ul>
<li>但是MAC没有shuf，只能用gshuf，还得安装一下<code>brew install coreutils</code></li>
</ul>
<p>tail -n +2 “$FILE” &gt; “$FILE.tmp” &amp;&amp; mv “$FILE.tmp” “$FILE” 可以删除文本文件第一行<br>cat 1.txt 2.txt &gt; 3.txt 可以把1.2文件行combine到3文件中<br>wc -l &lt; <filename> 返回文件有多少行</p>
<p>sed ‘2,$d’ ab           #删除第二行到最后一行</p>
<p>python -V #查看python的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wc -l &#96;find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -type f&#96; #print一个文件夹下所有文件的行数</span><br></pre></td></tr></table></figure>

<h1 id="犯过的错误"><a href="#犯过的错误" class="headerlink" title="犯过的错误"></a>犯过的错误</h1><p>bash没保存 反复运行发现没什么变化，以为电脑坏了</p>
<p><strong>Slurm 装R包</strong>：</p>
<ul>
<li>module load R 才可以把R的版本换成3.5</li>
<li>装R的时候需要带上dependencies = TRUE</li>
</ul>
<p><strong>Slurm报错</strong>：slurmstepd: error: Exceeded step memory limit at some point.</p>
<ul>
<li>#SBATCH –mem-per-cpu=10gb </li>
</ul>
<p><a href="https://blog.csdn.net/weiguang1017/article/details/80345058" target="_blank" rel="noopener">mac下插入文件到某一行</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>不要在一个终端窗口里使用 Ctrl-c 和 Ctrl-v 快捷键来执行拷贝和粘贴操作。它们不 起作用。对于 shell 来说，这两个控制代码有着不同的含义，它们在早于 Microsoft Windows （定义复制粘贴的含义）许多年之前就赋予了不同的意义。</p>
<h1 id="一些简单命令"><a href="#一些简单命令" class="headerlink" title="一些简单命令"></a>一些简单命令</h1><p>date 显示时间</p>
<p>cal 显示日历</p>
<p>查看磁盘剩余空间的数量，输入 df</p>
<p>显示空闲内存的数量，输入命令 free。</p>
<p>退出 exit</p>
<p>mv 重命名/剪切  rm删除</p>
<p>如何获取ubuntu管理员权限？<br>①sudo passwd root  （创建root的密码）<br>②su命令进入管理员权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wc -l &lt; file.txt <span class="comment">#可以不显示文件名直接显示行数</span></span><br></pre></td></tr></table></figure>

<p>=~ 来匹配正则式</p>
<p>下载Kaggle数据需要权限：传递cookie <a href="https://wdeback.gitlab.io/post/2018-03-08-how-to-download-kaggle-dataset-from-command-line/" target="_blank" rel="noopener">https://wdeback.gitlab.io/post/2018-03-08-how-to-download-kaggle-dataset-from-command-line/</a></p>
<p><strong>Linux下，删除大于固定大小的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -size +50M1</span><br></pre></td></tr></table></figure>

<p>显示当前路径下，大于50M的文件。（包含子文件夹内的文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -size +50M -exec rm &#123;&#125; \;1</span><br></pre></td></tr></table></figure>

<p>删除当前路径下，大于50M的文件。（包含子文件夹内的文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find shakespeare -type f -exec cat &#123;&#125; \; &gt; file</span><br></pre></td></tr></table></figure>

<p>找到所有文件并把他们合在一起</p>
<p>M-x erase-buffer 删除所有内容</p>
<p>Counting Files in the Current Directory: <code>ls -l | wc -l</code></p>
<p><a href="https://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_02.html" target="_blank" rel="noopener">ARRAY 操作</a></p>
<h1 id="一些操作上的快捷键"><a href="#一些操作上的快捷键" class="headerlink" title="一些操作上的快捷键"></a>一些操作上的快捷键</h1><p>C-L 可以将命令行移动到屏幕的上/中/下</p>
<h1 id="HTCondor"><a href="#HTCondor" class="headerlink" title="HTCondor"></a>HTCondor</h1><p>proc=$$([$(Process)+3586]) 来调节命令序号</p>
<h1 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h1><p>操作指南：<a href="https://slurm.schedmd.com/sbatch.html" target="_blank" rel="noopener">https://slurm.schedmd.com/sbatch.html</a></p>
<h1 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h1><p>新建窗口 emacs -nw</p>
<p>退出 C-x C-c</p>
<p>查找文件：C-x C-f</p>
<p>删除一行 C-k</p>
<p>删除当前C-d</p>
<p>拷贝 M-w</p>
<p>去掉一些空白换行符 tab</p>
<p>去掉一些空白区域 M-p</p>
<p>自动合并段落 M-q</p>
<p>list buffers: C-x C-b </p>
<ul>
<li>按space进入选中的buffer </li>
<li>在bufferlist里面关掉buffer 直接用 k 选中多个 然后enter来删除</li>
</ul>
<p>唤起shell : M-x shell / C-z</p>
<p>删掉输入一般的错误/不想要命令</p>
<p>撤销：C-/</p>
<p>字体： C-_ 缩小    C-shift-+ 放大    C-0 回到原来样子</p>
<p>C-x d 进入文件管理界面</p>
<ul>
<li>按+可以创建新文件夹 </li>
<li>按d可以添加删除标记最后按x执行删除命令 </li>
<li>g刷新</li>
<li>u取消标记</li>
<li><a href="http://lifegoo.pluskid.org/wiki/EmacsAsFileManger.html" target="_blank" rel="noopener">http://lifegoo.pluskid.org/wiki/EmacsAsFileManger.html</a> 里面提到了很多dired的操作</li>
<li><a href="http://www.cnblogs.com/beanmoon/archive/2012/09/22/2697723.html里面提到了很多dired的操作" target="_blank" rel="noopener">http://www.cnblogs.com/beanmoon/archive/2012/09/22/2697723.html里面提到了很多dired的操作</a></li>
</ul>
<p>M-p 重复上一命令</p>
<p>M-x replace-string C-q C-j 可以插入回车</p>
<p>C-v 向下翻页 M-v 向上翻页</p>
<h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>跑R程序可以直接 Rscript xxx.R</p>
<h2 id="学校CHTC介绍"><a href="#学校CHTC介绍" class="headerlink" title="学校CHTC介绍"></a>学校CHTC介绍</h2><p>HTC(高吞吐量计算)与HPC(高性能计算)：</p>
<ol>
<li>HTC分成的若干个部分之间不需要交流信息，而HPC需要</li>
<li>HTC更感兴趣的是可以在很长一段时间内完成多少工作而不是多快。</li>
</ol>
<p>比学校CHTC更大&amp;更不灵活的是UW Grid/ Open Science Grid</p>
<p>可以跑R, Python, Matlab, …</p>
<p>学校用的分布系统是HTCondor</p>
<p>以后如果有自己的项目要申请CHTC，<a href="http://chtc.cs.wisc.edu/form" target="_blank" rel="noopener">http://chtc.cs.wisc.edu/form</a></p>
<p><strong>Submit&amp;Monitor the job</strong>: condor_submit job.sub condor_q 但是这个命令在lunchbox里面跑不了，因为lunchbox用的是sbatch那一套 </p>
<h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h1><p>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。</p>
<p>许多 Linux 发行版默认保存最后输入的 500 个命令。（使用向上箭头）</p>
<p>鼠标左键拖动 = 复制文本</p>
<p>传统 X 行为是指只要把鼠标移动到一个窗口的上方。 它能接受输入，但是直到你单击窗口之前它都不会成为前端窗口。设置聚焦策略为“聚焦跟随着鼠标”，可以使拷贝和粘贴更方便易用。 你能在窗口管理器的配置程序中找到这个设置。</p>
<h1 id="文件系统中跳转"><a href="#文件系统中跳转" class="headerlink" title="文件系统中跳转"></a>文件系统中跳转</h1><p>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录（/home）。每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户对文件进行写入的地方。</p>
<p>相对路径用一个点[.]或者两个点[..]</p>
<p>cd .. 表示返回上一层</p>
<p>cd ./xxx 表示进入下一层 当然 [./] 可以被省略</p>
<p>直接 cd 会回到家目录</p>
<p>cd - 更改工作目录到先前的工作目录。【类似于返回上一步】</p>
<p>cd ~user_name 可以回到其他用户的家目录</p>
<p>ls 无法列出被隐藏的文件（例如用[.]开始的文件）此时可以使用 ls -a 命令</p>
<p>文件名和命令名是大小写敏感的</p>
<p>Linux 没有“文件扩展名”的概念，文件内容或用途由其它方法来决定。</p>
<p>虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用“.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与词间的空格，用<strong>下划线字符来代替</strong>。过些时候，你会感激自己这样做。</p>
<p>Emacs中要达到撤销效果使用的是 C-/ ，同样还可以使用 C-_ 或者 C-x u ，这三个都对应的是Undo命令。</p>
<p>上面说的是撤销文本上的操作，还有个比较常用的命令C-g ，这个是用来撤销命令的，当你输了一半命令发现不对就可以用它了。</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Tableau心得</title>
    <url>/2020/07/02/Tableau%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>为了628的presentation，后来741的report也用了。简单画个小图还是挺美观的。教育版免费。</p>
<a id="more"></a>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>添加WMS server地图（类似于谷歌地图）：<a href="http://ows.terrestris.de/osm/service" target="_blank" rel="noopener">http://ows.terrestris.de/osm/service</a>?</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Tableau</category>
      </categories>
  </entry>
  <entry>
    <title>Matlab心得</title>
    <url>/2020/07/02/Matlab%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在做ME599的时候学习了下。不同语言的Bug还是难de。</p>
<a id="more"></a>



<h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><ul>
<li>读入文件：load</li>
<li>numel(A) = prod(size(A)) 返回A中元素个数</li>
</ul>
<p>pathtool 添加路径</p>
<p>运行一行代码 ❎ 只能运行选中代码，然后Fn+Shift+F7<br>注释用百分号% 代替#<br>「1<del>=2」表示1不等于2 用</del>代替叹号<br>或者|| 和&amp;&amp; 异或xor()<br>a=pi在后面加一个;冒号可以抑制打印<br>disp(sprintf(‘6 decimals: %0.6f’,a)) %结果为 ‘6 decimals: 3.141593’<br>format short/long 可以在打印东西之前写出来 改变打印的位数</p>
<p>矩阵生成</p>
<ul>
<li>用中括号括起来，用分号按行输入</li>
<li>ones(m,n) 生成一个m*n的矩阵，元素全为1.  zeros同理</li>
<li>eye(n)  生成n维单位矩阵</li>
</ul>
<p>rand()生成0-1均匀分布的随机数，可以用rand(m,n)来生成随机矩阵<br>randn() 生成标准正态</p>
<p>clc清屏<br>a=出发数字：步长：结束数字——生成一个向量，步长默认是1<br>hist(w,方格数)生成密度图像<br>size返回矩阵的维数 size(a,1|2)返回第一个或第二个维数<br>length给出一个矩阵最长的维数，所以对一个向量可以直接返回它的长度<br>who 可以显示当前所有变量 whos更详细  clear可以清除一个变量 什么都不加的clear全部清除<br>选择一个向量的前十位：v=priceY(1:10)<br>save hello.mat v: 把数据v存为hello.mat文件<br>a([1 3],:) 矩阵第一行和第三行所有元素<br>A=[A,[1;2;3]]：矩阵A右侧加上一列123<br>A(:)将A元素变成一个列向量输出<br>b1=[a:a]  b2=[a a]/[a,a] b1是上下合并 b2是左右合并<br>a.*b 是把两个矩阵对应位置的数字乘起来作为新元素，所以a和b应该是一样大小的<br>·点其实代表着element-wise operation；所以 v=[1,2,3]   1./v  %1 0.5 0.33</p>
<p>max()返回最大值，</p>
<ul>
<li>可是如果[v,c]=max(a) 那么v是最大值，c是最大值的index</li>
<li>如果对矩阵作用max，会返回每一列的最大值</li>
</ul>
<p>find(a&lt;3) 返回a向量中小于3的index<br>magic(n) 生成一个n阶的矩阵，行和列和对角线和都相同（但是对于每个n只有一种形式）<br>提取矩阵元素的时候，如果只用一个数字，那么默认是按照列来数<br>prod() 连乘<br>floor&amp;ceil地板和天花板函数<br>max(a,[],1|2) 按列|行来取矩阵a的最大值<br>sum(a,1|2) 按列|行进行求和<br>取整个矩阵的最大值：max(max(A))或者max(A(:))</p>
<p>可以用逗号连接命令或者函数调用，会逐个运行。用冒号连接则不会显示结果</p>
<p>循环：for i = 1:10, v(i)=2^i; end. while和if也要和end连用。if也没有括号</p>
<p>exit和quit都可以退出octave</p>
<p>addpath()添加新路径</p>
<ul>
<li>取出向量的第五位到最后一位：A(5:end) 注意这个end</li>
</ul>
<ul>
<li>rng(512) 等同于R里面的set.seed(512)</li>
<li>normrnd = rnorm 不过可以直接在后面加上维数，生成众多随机数</li>
<li><a href="https://cn.mathworks.com/help/matlab/ref/table.html" target="_blank" rel="noopener">创建一个表格</a>：T = table(Age,Height,Weight,BloodPressure,…    ‘RowNames’,LastName) </li>
<li>fminunc 返回函数最小值（维数大于等于2）</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>遍历一个未知大小的矩阵/向量：for i = 1:numel(z)</li>
</ul>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ul>
<li>a(2,:)=[] 删除某一行/列</li>
<li>reshape(data,nrow,ncol) 变形矩阵</li>
<li>a(: , k:end) end代表最后</li>
<li>a=sum(A) %列求和<br>b=sum(A,2) %行求和<br>c=sum(A(:)) %矩阵求和</li>
<li></li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>f = @(x) 2 * x ^ 2 + x; 创建symbolic function</p>
<p>intlinprog - Mixed-integer linear programming (MILP) 混合整数线性规划问题</p>
<h1 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h1><ul>
<li>figure; open a new figure window</li>
<li>flipud(a) 将矩阵a上下翻转</li>
<li>hold on 可以让当前的图留住，将下一幅图继续画在上面。 </li>
<li>xlabel(‘name’)</li>
<li>plot(x,y,’r’)红色</li>
<li>legend(‘1’’2’)加图例</li>
<li>title(‘标题’)</li>
<li>print -dpng ‘name.png’</li>
<li>figure(1);plot();figure(2);plot() 可以同时分别画出来两张图</li>
<li>subplot(1,2,1);plot() 将图像空间分成1*2，现在去画第一个</li>
<li>axis([横坐标最小值 横坐标最大值 纵坐标最小值 纵坐标最大值])</li>
<li>clf清除所有图</li>
<li>imagesc(a) 将矩阵a用颜色画出来</li>
<li>colorbar 在右侧添上一个颜色条</li>
<li>colormap gray将图变成灰色</li>
</ul>
<h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><ul>
<li>ctrl+c : 终止当前程序</li>
</ul>
<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><ul>
<li>SVM: liblinear/libsvm</li>
</ul>
<h1 id="文档发布"><a href="#文档发布" class="headerlink" title="文档发布"></a>文档发布</h1><p><a href="https://cn.mathworks.com/help/matlab/matlab_prog/marking-up-matlab-comments-for-publishing.html" target="_blank" rel="noopener">官方帮助</a></p>
<ul>
<li></li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Matlab</category>
      </categories>
  </entry>
  <entry>
    <title>The Reason for God</title>
    <url>/2020/07/02/The-Reason-for-God/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>《The Reason for God》，中文版《为何是他》是提摩太·凯勒（Timothy Keller）写的一本<strong>信仰答疑解惑书</strong>。其中涉及到了很多“敏感问题”，比如：“为什么上帝会允许苦难”、“为什么充满爱的上帝会送人去地狱” 等等。初读时惊讶的合不拢嘴，连连拍手。中期时开始觉得理性的思考与感性的信心相违背，开始抵制这本书。最后决定把它读完，作为知识来收获，而不是信仰来全盘接受。</p>
<a id="more"></a>

<h1 id="前五章"><a href="#前五章" class="headerlink" title="前五章"></a>前五章</h1><p>2020/5/10 周二<br>基督徒被接受不是因为做的比其他人好，而是耶稣担当了我们的罪过。其他宗教提倡道德提升，就会天然的对那些不信/不做的人，产生自己更高级的感觉。所以成为基督徒之后，我们正常来说不会觉得自己越来越好，而是越来越知道自己的不足，产生优越感也就无从谈起了。</p>
<p>2020/5/12 周二<br>未来的新天新地不仅是一个什么都有的美好世界，而是把我们所有过去的上海，痛苦全部翻转，并且变成更大的喜悦。更像是把水变成酒而不是直接给你一杯好喝的酒。</p>
<p>2020年5月14日</p>
<ul>
<li>“You cannot go on ‘seeing through’ things for ever. The whole point of seeing through something is to see something through it. It is good that the window should be transparent, because the street or garden beyond it is opaque. How if you saw through the garden too? It is no use trying to ‘see through’ first principles. If you see through everything, then everything is transparent. But a wholly transparent world is an invisible world. To ‘see through’ all things is the same as not to see.”</li>
<li>不存在一种文化能够包容所有文化，多元文化支持所有其他的文化，但他本身也是一种文化。如果我的文化有所支持而有所不支持，那我的文化就不同于多元文化，从而不存在一种文化能够包容所有文化。</li>
<li>想象一下LGBT的主席突然说：我认为LGBT是有罪的。同时，一个反对同性恋组织的主席突然觉得LGBT也不错。两个人的结局应该会很类似。所以没有不是什么inclusive/exclusive的问题。</li>
<li>我们既然不能用exclusive/inclusive来判断组织的好坏，怎么判断？我们应该看他们是如何对待不信的群体的。是以慈爱，谦卑来爱他们，还是攻击对抗他们？（难以想象LGBT的人会真的爱双性恋的人，并抱有一个谦卑的心）</li>
</ul>
<p>2020年5月15日</p>
<ul>
<li>Christianity helped Africans to become renewed Africans, not re-made Europeans. 相反的，现在的世俗生活，个人主义与不相信超自然的文化对非洲人来说是deconstructive的。</li>
<li>这里不存在一个什么基督文化，像伊斯兰文化那样。基督文化可以融入到我们自己的文化中，补全和理解我们自己的文化。</li>
</ul>
<p>2020年5月16日</p>
<ul>
<li>The church is a hospital for sinners, not a museum for saints. 所以如果你看到一个基督徒做的不好，比非信徒差劲，很可能他一开始更差。毕竟医院里的病人身体状况还是比正常人差。</li>
<li>他把法利赛人等追求道德提升的人称为fanatics</li>
<li>It was the Bible-believing religious establishment who put Jesus to death. It was the church, not the world, who crucified Christ.</li>
<li>法利赛人的问题在于，渴望通过很高的道德要求，来获得权利//能力，从而比别人优秀，甚至可以和基督比肩。这会导致他们越来越在乎外表。</li>
<li>不抢钱包，可能是因为如果抢钱包的事被别人知道了之后名誉损失很大（honor-shame society），也可能是因为想到了被抢钱包带来的伤害。</li>
<li>Christianity changed those honor-based cultures in which pride was valued rather than humility, dominance rather than service, courage rather than peaceableness, glory rather than modesty, loyalty to one’s own tribe rather than equal respect for all.</li>
<li>Instead of trying to shape our desires to fit reality, we now seek to control and shape reality to fit our desires. 古人和现在人的区别。</li>
<li>It seems to our mind unfair, therefore, that we should determine that it is all right to have sex outside of marriage and later discovered that there is a God who is going to punish us for that.</li>
<li>In one of my after-service discussions a woman told me that the very idea of a judging God was offensive. I said, why aren’t you offended by the idea of a forgiving God ? She looked puzzled.</li>
<li>For the sake of argument, let’s imagine that Christianity is not a product of any one culture but is actually transcultural truth of God. if that were the case we would expect that it would contradict and offend every human culture at some point, because human cultures are ever-changing and imperfect. if Christianity were the truth it would have to be offending and correcting your thinking at some place.</li>
<li>If you love a person and you see someone ruining them—even they themselves—you get angry.</li>
<li>Anger is not the opposite of love, hate is. And the final form of hate is indifference</li>
<li>If I don’t believe that there is a God who will eventually put all things right, I will take up the word and will be sucked into the endless vortex of retaliation. only if I am sure that there is a God who will right all wrongs and settle all accounts perfectly do I have the power to refrain.</li>
<li>Hell begins with a gambling mood, always complaining, always blaming others… but you are still distinct from it. you may even criticize it in yourself and wish you could stop it. but there may come a day when you can no longer. then they will be no YOU left to criticize the mood or even to enjoy it, but just the grumble itself going on forever like a machine. it is not a question of God sending us to hell. In each of us, there is something growing, which will BE HELL unless it is nipped in the bud.</li>
</ul>
<h1 id="第六章-Science-Has-Disproved-Christianity"><a href="#第六章-Science-Has-Disproved-Christianity" class="headerlink" title="第六章 Science Has Disproved Christianity"></a>第六章 Science Has Disproved Christianity</h1><p>他提到了不同的章节我们读的时候要考虑体裁。比如路加福音（eyewitnesses）就可以100%当成历史来读，而诗篇就要当成诗歌来读。当我们面对创世纪1&amp;2章的时候，就像士师记4&amp;5、出埃及记14&amp;15那样，一章是历史而一章是赞歌。他认为创世纪1是赞歌而2是历史。</p>
<blockquote>
<p>他们见了耶稣就拜他。然而还有人疑惑。《马太福音28:17》</p>
</blockquote>
<p>那些门徒，亲眼看到了耶稣的复活，甚至还触摸到了身体，有的人还存留疑惑。这让我想起了拉撒路的故事，亚伯拉罕对那个富人说，如果你的弟兄们是不信的人，那么即使看到了神迹也不会相信</p>
<p>关于神迹miracle，他举了个例子。比如耶稣不会做这种magic tricks：</p>
<blockquote>
<p>See that tree over there? Watch me make it burst into flames!</p>
</blockquote>
<p>相反，他用他的能力去救病人，喂饱肚子饿的人，让死人复活。现如今的人们认为的神迹大多属于上面的magic tricks，是对抗Nature Order。但是耶稣行的神迹是恢复Nature Order。</p>
]]></content>
      <categories>
        <category>Holy</category>
        <category>References</category>
        <category>The Reason for God</category>
      </categories>
  </entry>
  <entry>
    <title>博弈论笔记</title>
    <url>/2020/07/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>来自于Coursera的斯坦福公开课Game Theory。学的虎头蛇尾，兴趣全无。</p>
<a id="more"></a>



<p>博弈有三部分构成：玩家，行为，收益<br>博弈论分为两种基本形式：</p>
<ul>
<li>范式博弈（Normal）：假定所有玩家同时采取行动，</li>
<li>展开博弈（Extensive）：设计不同玩家之间的Timing&amp;Information，一般用树模型。</li>
</ul>
<p>n人的范式博弈：&lt;N,A,μ&gt;</p>
<ul>
<li>N：1~n 表示了参与人数</li>
<li>Ai：Action Set行为集合</li>
<li>μi：效用函数utility/payoff Function</li>
</ul>
<p>常用矩阵来描绘博弈：如果两个玩家的话，行是一个玩家，列是一个玩家，矩阵的元素是一个二维的向量，表示他们各自的收益</p>
<p>反抗政府的那个例子中我们发现，如果其他人的决策对个体的决策有影响的话，就不能用矩阵形式来表示了。</p>
<p>一个简单的常和博弈的例子——匹配硬币:pure competition 效用函数之和是0或是个常数</p>
<ul>
<li><p>两个人正反面相同：A给B一块钱</p>
</li>
<li><p>两个人正反面不同：B给A一块钱</p>
</li>
</ul>
<p>Pure cooperation：每个人的效用函数相同</p>
<p>夫妻两人看电影的例子：可以同时存在竞争和合作</p>
<p>纳什均衡考虑的步骤：</p>
<ol>
<li>其他人会怎么做</li>
<li>我要如何来应对</li>
</ol>
<p>纳什均衡就是每个人都作出最优解所形成的局面<br>纳什均衡是稳定的，因为不是纳什均衡的情况是不稳定的。（随着人们对问题的了解深入，他们会改变他们的主意）</p>
<p>凯恩斯的选美比赛（keynes’s beauty contest game）：英国的报纸上，在几幅美女图片中，选出来你认为最受其他人欢迎的美女。这就是一种要考虑其他人行为而不是单单考虑自己行为的博弈。</p>
<p>又一个game：每个人说出一个1-100的数字，然后最接近大家平均数的2/3的那个人获胜，下面开始解题：</p>
<ol>
<li>每个人猜平均是X，所以会出0.66X,但因为X&lt;=100,所以每个人的数字不会超过67</li>
<li>所以平均会是67及以下，所以会出0.66*67，所以无限循环下去</li>
<li>纳什均衡告诉我们，每个人该出1！</li>
<li>最后结果第一轮是23胜出，又做了一遍是4，结果向着纳什均衡（1）在发展</li>
</ol>
<p>我们将a(-i)定义为除了自己其他人的策略集，a<em>定义为自己的最优策略，最优策略可以不唯一，但一定是出自最优对策集BR(Best response)。最优对策集的假设是其他所有人都会使用策略a(-i),那么BR的定义：<br>ai</em> ∈ BR(a(-i)) iff 对任意ai∈Ai,Ui(ai*,a(-i))&gt;=Ui(ai,a(-i))<br>Best response 不一定只有一个</p>
<p>&lt;a1,…,an&gt; is called a pure strategy Nash equilibrium iff 任意i,ai ∈ BR(a(-i))</p>
<p>Si Strictlly dominate/Very weakly dominate Si’: 对于其他人的任何行为S-i,U(Si,S-i) &gt;(=) U(Si’,S-i)  如果有一个策略比任何其他策略都好，那么他叫dominant</p>
<p>纳什均衡：每个人都出自己的dominant</p>
<p>帕累托最优pareto optimality：</p>
<ul>
<li>因为在衡量全局好坏的时候，你不知道每个个体的效用函数是什么样子的，所以这就像你想提高你的回报，但是这回报是以一种你不知道汇率的不同外汇来分给每一个人。</li>
<li>如果一个outcome O at least as good as O’ 并且对于某些agent，他们strictly prefer O。这时我们就可以说O pareto-dominates O’ 如果一个outcome O 不能再被其他 O’pareto-dominates,那么就称他为帕累托最优。</li>
</ul>
<p>帕累托最优结果可能不唯一：可能有两个outcome谁也不比谁好<br>每个游戏至少有一个帕累托最优</p>
<p>mixed strategy：</p>
<ul>
<li>idea：confuse the opponent by play randomly</li>
<li>与pure strategy的区别就在于，同样是关于行动的分布，pure是只有一个行动的概率是1，其他都是零，而mixed则是有多个可能性大于0的行动</li>
<li>此时效用函数变成了多个小部分效用函数的加权均值</li>
</ul>
<p>纳什定律：Every Finite game has a Nash equilibrium. 有限的意思是总情况空间是有限的。有限的玩家*每人有着有限的行动集</p>
<p>mixed strategy equilibrium: 一个稳态，不过此时参与者并不是只选一种，而是按照某种概率选择多种方案。计算的方式是，先定其中一个人的概率，使得另一个人无论选哪种方案，都会得到一样的回报。（因为如果不一样的话，另一个人就没必要random，直接全部投入最优的解即可）解方程出来之后。再对剩下的人依次求解。最后获得一个平衡。</p>
<p>两个寻找纳什均衡的算法：</p>
<ol>
<li>LCP(Linear Complementarity) formulation(By Lemke-Howson)</li>
<li>Support Enumeration Method</li>
</ol>
<p>PPAD：Polynomial Parity Arguments on Directed graphs.<br>复杂度排序：P&lt;PPAD&lt;NP&lt;NP-complete</p>
<p>开始对支撑集做假设的时候，我们假设两个选手的可能取值差不多。而不是一人有两个方案，一个人有十七个方案。</p>
<p>correlated equilibrium</p>
<p>Rationality: A basic premise: Players maximize their payoffs</p>
<p>如何检查纳什均衡：看看两个玩家在当前条件下有没有动力改变自己的决策。纳什均衡=每个人都没有profitable deviation</p>
<h2 id="Iterative-Removal："><a href="#Iterative-Removal：" class="headerlink" title="Iterative Removal："></a>Iterative Removal：</h2><p>删去被最好行动压制的其他行动</p>
<p>A strictly dominated（被动） strategy can never be a best play, so we can remove it.</p>
<p>但是删掉一个被dominate之后，剩下的里面会再出来一个新的dominated，所以我们要不断的iterate。</p>
<p>不仅可以被pure strategy打败 被mixed打败也可以。所以在没有单纯的strictly dominant的时候，我们可以用组合策略来删除</p>
<p>dominant solvability：可以被最小迭代变成一个pure</p>
<p>对于strictly dominant来说 删除的order并不重要</p>
<p>但如果是weak的话，可能会在删的过程中也删掉一些纳什均衡，这时候order重要，但至少有一个纳什均衡会被保留下来。</p>
<p>两只猪的游戏：用来论证事实上猪也会博弈论</p>
<p>maxmin strategy: maximize worst-case payoff. </p>
<p>Maxmin value(safety level): the minimum payoff guarenteed by maxmin strategy.</p>
<p>minmax strategy: minimize enemy’s best-case payoff. 在零和游戏中，损人=利己</p>
<p>correlated equilibrium：A randomized assignments of (potential related) action ecommandations to agents, such that nobody wants to deviate.</p>
<h2 id="Extensive-Form"><a href="#Extensive-Form" class="headerlink" title="Extensive-Form"></a>Extensive-Form</h2><p>有时，时间也影响着决策。Game Tree:人们轮流采取行动，最后会终结在树的某一个节点上。</p>
<h3 id="Perfect-Information"><a href="#Perfect-Information" class="headerlink" title="Perfect Information"></a>Perfect Information</h3><ul>
<li>参数：N、A、H、Z、chi、rho、sigma、u</li>
<li>N：players。</li>
<li>A: Actions（这时每个人能采取的行动是一样的）</li>
<li>H：choice nodes:  non-terminal</li>
<li>chi: Action-function 将H映射到2^A assign actions to each node</li>
<li>rho: Player-function: assign player to non-terminal node</li>
<li>Z: terminal nodes</li>
<li>sigma: sucessor function 将H*A 映射到H并Z</li>
<li>u: utility function. 对每一个Z映射一个得分</li>
</ul>
<p>注意这棵树是单射。不存在多个节点或者一个节点的多个行为指向到同一个结果</p>
<p>在计算pure strategy 个数的时候，就连那些肯定到不了的节点也要算进去。因为博弈论认为到不了的A和到不了的B也是不一样的</p>
<p>定理：Every perfect information game in extensive form has a PSNE(Pure Strategy Nash Equilibrium)</p>
<h4 id="Induced-Normal-Form"><a href="#Induced-Normal-Form" class="headerlink" title="Induced Normal Form"></a>Induced Normal Form</h4><ul>
<li>将A与B的pure strategy做一个笛卡尔积。树的很多根节点被重复了多次，在树很大的时候会造成指数的数据上涨，不好</li>
<li>并且我们一般不能把一个Normal Form Game变成一个Extensive Form Game。因为有时候Game就是需要两个人同时发出动作，但是Extensive是有先后顺序的</li>
</ul>
<h4 id="Subgame-perfection"><a href="#Subgame-perfection" class="headerlink" title="Subgame perfection"></a>Subgame perfection</h4><ul>
<li>在一个perfect information game 的某个纳什均衡决策中，所有的子决策族都没有profitable deviation。</li>
<li>Backward Induction: 在零和游戏中又被称为minimax。在每个节点处以自己孩子点中最大值作为自己的值</li>
<li>Ultimate Bargaining：举得例子是10份东西两个人分。A提出一个分法，B同意的话就按照这个方法分，B不同意的话两个人都是0。这种情况下A的最好策略应该是9/1 但事实上很多人选择了5/5。有可能是因为总体太小了。当研究人员把总体调的越来越大的时候，人们倾向于给对方更小的比例，并且对方也倾向于接受更小的比例</li>
</ul>
<h3 id="Imperfect-Information"><a href="#Imperfect-Information" class="headerlink" title="Imperfect Information"></a>Imperfect Information</h3><p>玩家不知道对手的全部行动</p>
<ul>
<li>equivalence class：将不同的node分成几个类，这样虽然不知道具体是来自哪一个node，但是我们知道它们不来自于哪些nodes</li>
<li>可以将IIEF-NF-IIEF：开始的IIEF可能会很深，但是变成Normal-Form在变回IIEF的时候，IIEF只有两层了。虽然两个IIEF可能长得不同，但是它们的行动空间是一样的。</li>
</ul>
<h4 id="Imperfect-Recall"><a href="#Imperfect-Recall" class="headerlink" title="Imperfect Recall"></a>Imperfect Recall</h4><p>玩家无法回忆自己曾经选择的node具体是哪一个</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Courses</category>
        <category>博弈论</category>
      </categories>
  </entry>
  <entry>
    <title>算法心得</title>
    <url>/2020/07/02/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>以下知识来自于：</p>
<ul>
<li>普林斯顿在Coursera上面的algorithm网课</li>
<li>python算法书</li>
<li>算法导论</li>
</ul>
<p>希望有朝一日能够继续学习。在上CS577的时候应该会更新这个文档</p>
<a id="more"></a>



<h1 id="Backtracking-放弃法"><a href="#Backtracking-放弃法" class="headerlink" title="Backtracking 放弃法"></a>Backtracking 放弃法</h1><p>backtracking（回溯算法）也叫试探法，它是一种系统地<strong>搜索问题的解</strong>的方法。回溯算法的基本思想是：<u>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</u></p>
<p>“回溯”的具体意思就是<strong>将不可能解或者部分解的候选尽早的舍弃掉</strong></p>
<p>深度优先算法DFS就是一种Backtracking的实例。</p>
<p>回溯算法说白了就是穷举法。不过回溯算法使用<strong>剪枝函数</strong>，剪去一些不可能到达最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</p>
<p>遍历过当前节点后，为了回溯到上一步，要去掉已经加入到结果list中的当前节点。</p>
<ul>
<li>这一步有时候可以用list的append和pop实现</li>
</ul>
<p>回溯法是一个既带有<strong>系统性</strong>又带有<strong>跳跃性</strong>的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，<u>总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索</u>，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<ul>
<li>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。</li>
<li>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<p>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
<p><a href="https://blog.csdn.net/crystal6918/article/details/51924665" target="_blank" rel="noopener">https://blog.csdn.net/crystal6918/article/details/51924665</a></p>
<p>待做的题：</p>
<ol start="51">
<li>N-Queens</li>
<li>N-Queens II</li>
<li>Combination Sum</li>
<li>Combination Sum II</li>
<li>Combination Sum III</li>
<li>Permutations</li>
<li>Permutations II</li>
<li>Subsets</li>
<li>Subsets II</li>
<li>Palindrome Partitioning</li>
</ol>
<h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><p>Union Find 是用来解决动态连通性（Dynamic Connectivity）问题的算法，是并查集的一种数据结构。</p>
<p>现在学的知识只能告诉我们是否联通，算法第二部分则会给出具体的联通路径。</p>
<p>API：Application Programming Interface 应用程序编程接口</p>
<p>等价性（Equivalence Relation）:</p>
<ol>
<li>Reflexive: 自反性</li>
<li>Symmetric：对称性</li>
<li>Transitive：传递性</li>
</ol>
<p>Dynamic Connectivity包含两部分：</p>
<ol>
<li>Find Query: 给定两个点，判断他们是否联通</li>
<li>Union Command: 给定两个点，将他们联通（属于生成过程）</li>
</ol>
<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>建立一个长度为n的列表，连通的点在列表中有着相同的元素。</p>
<p>Find: 当我们想知道p和q是否相通的时候我们只需要判断列表的第q和p位是否具有相同的数字即可。</p>
<p>Union: 将其中一个数字全部变为另一个。具体变的时候Union(a,b)我们将a位置的数字变为b位置的数字</p>
<p>Quick-Find 太慢啦！初始化需要跑完n, union操作需要跑完n, find操作需要1。</p>
<p>复杂度是$n^2$，我们不能接受这样的算法</p>
<p>Quadratic algorithm does not scale with technology.</p>
<h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>建立一个树结构。还是一个长度为n的列表。每个位置对应的数值表示他的父亲节点是谁。</p>
<p>Find：只要p和q有相同的根节点就可以了</p>
<p>Union：将其中一个数字的根节点变成另一个数字的根节点的孩子节点。</p>
<p>Quick-Union 也不快！初始化需要跑完n, union操作需要跑完n, find操作需要n。</p>
<h3 id="Weighted-Quick-Union"><a href="#Weighted-Quick-Union" class="headerlink" title="Weighted Quick Union"></a>Weighted Quick Union</h3><p>我们记录树的size，确保每次都将小树连接到大树的上面</p>
<p>每个根节点的深度不超过logn.初始化需要跑完n, union操作需要跑完logn, find操作需要logn。</p>
<h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>在我们从一个节点回溯找根节点的时候，只要当前停留的节点不是根节点，我们就将这个节点指向根节点。压缩整个树的深度，因为就是深度才带来了时间的长度。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>给定N个点，M个Union。在最极端的情况下：</p>
<table>
<thead>
<tr>
<th>Quick-Find</th>
<th>Quick-Union</th>
<th>Weighted QU</th>
<th>QU+Path CP</th>
<th>WQU+Path CP</th>
</tr>
</thead>
<tbody><tr>
<td>MN</td>
<td>MN</td>
<td>N + M*logN</td>
<td>N + M*logN</td>
<td>N + M*log*N</td>
</tr>
<tr>
<td>Log* 是迭代对数函数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Applications——Percolation"><a href="#Applications——Percolation" class="headerlink" title="Applications——Percolation"></a>Applications——Percolation</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1frk8va07k3j31860yc0ti.jpg" alt=""></p>
<p>很明显，概率越小越不容易渗透。</p>
<p>Phase Transition: 在能不能渗透的某个临界值p，图像会变得十分陡峭。</p>
<p>用蒙特卡洛模拟来找出临界值p：先给一个黑色方块。将其中的黑块一个一个的变成白块，直至渗透。</p>
<p>将每一个方块用一个点来表示。每次一个点亮的白块会call function 0~4次。<br>在第一行上面建立一个虚拟点，连接了第一行的每一个点。在最后一行下面建立一个虚拟点，连接最后一行的每一个点。反复判断这两个创建的虚拟点之间是否存在通路即可。</p>
<p>最后答案是0.592746</p>
<h1 id="Analysis-of-Algorithms"><a href="#Analysis-of-Algorithms" class="headerlink" title="Analysis of Algorithms"></a>Analysis of Algorithms</h1><h2 id="观察法"><a href="#观察法" class="headerlink" title="观察法"></a>观察法</h2><p>Example: 3-Sum: Given N integers, how many triples sum to exactly zero?<br>Brute Force：三层for循环</p>
<p>很常见的一种画时间T和数据量N的图是log-log图。$T = aN^b$</p>
<p>满足指数时间增长的算法可以通过一种方法检验：Doubling Hypothesis<br>用2N的时间除于N的时间来获得一个Ratio。如果这个Ratio趋近于一个常数，就说明差不多是指数增长（log(Ratio) = b），也可以画出log-log图然后进行拟合。</p>
<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>我们首先要记住一些基本操作的耗时。比如说分配一个长度为n的向量时间是O(n)，连接两个字符串的时间也是O(n)</p>
<p>我们一般只算最耗时的那些步骤都被重复了多少次</p>
<p>所以在k-sum的例子中，最耗时的一步是$C_N^k$这一步，O($n^k$)</p>
<p>但是这种获得explcit的方式有点太难了，所以一般也不采用这种方法</p>
<h2 id="Order-Of-Growth"><a href="#Order-Of-Growth" class="headerlink" title="Order Of Growth"></a>Order Of Growth</h2><p>1, log(N), N, Nlog(N), N^2, N^3, 2^N…</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frng0jikt8j30ua0oqjuz.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frng24qffuj311c0rsn26.jpg" alt=""></p>
<h3 id="四种记号"><a href="#四种记号" class="headerlink" title="四种记号"></a>四种记号</h3><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frngs9k2d7j30wo0lqgq6.jpg" alt=""></p>
<p><strong>Common mistake：</strong> Interpreting big-Oh as an approximate model. </p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frnh4vnyhhj319a0zon2v.jpg" alt=""></p>
<h1 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h1><p>Stack: LIFO 后进先出<br>Queue: FIFO 先进先出<br>这两个都可以用linked-list / array来实现</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Resizing-Array"><a href="#Resizing-Array" class="headerlink" title="Resizing Array"></a>Resizing Array</h3><p>在Java实现中，我们需要用户给出array的默认长度。所以更灵活的，我们可以用resizing array。但是可变长度的array会有一个问题，那就是我们每向array末尾添加一个元素的时候，我们需要把之前所有元素都复制一遍，连同最新的元素放到一起。这样的话需要的操作为：$1+2+3+…+N = N(N+1)/2$. 所以我们需要一个更简单的方法来做这个事情。</p>
<h4 id="Repeated-Doubling"><a href="#Repeated-Doubling" class="headerlink" title="Repeated Doubling"></a>Repeated Doubling</h4><p>Q. How to grow array?</p>
<p>A. If array is full, create a new array of <u>twice the size</u>, and copy items.</p>
<p>Cost of inserting first N items: $N + (2^1 + 2^2 + 2^3 + … + N) \sim 3N$.</p>
<p>Q. How to shrink array?</p>
<p>A. halve size of array s[] when array is one-quarter full.</p>
<h3 id="Stack-considerations"><a href="#Stack-considerations" class="headerlink" title="Stack considerations"></a>Stack considerations</h3><p>Overflow and underflow: </p>
<ul>
<li>Underflow: <u>throw exception</u> if pop from an empty stack.</li>
<li>Overflow: use <u>resizing array</u> for array implementation.</li>
</ul>
<p>Null items:</p>
<ul>
<li>We allow null items to be inserted.</li>
</ul>
<p>Loitering:</p>
<ul>
<li>Holding a reference to an object when it is no longer needed.</li>
<li>解决方法是每次在pop之后，将不用的元素设为NULL</li>
</ul>
<h3 id="Linked-List-or-Resizing-Array"><a href="#Linked-List-or-Resizing-Array" class="headerlink" title="Linked-List or Resizing Array"></a>Linked-List or Resizing Array</h3><p>如果我们希望总时间变少而不在乎单个插入/删除的操作时间的话，选择Resizing-Array。如果我们想避免某一个添加/删除很慢很慢的情况，选择Linked-List，因为每一步操作耗时基本是相同的。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Stack里面的push和pop在Queue里面被称为enqueue和dequeue</p>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>有时候元素不是数字或字符这么好操作的东西（Generic Type），就有点麻烦。在各个语言里面实现的时候，Liknked-List比Array更容易实现</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>在Python里面是用dict来实现</p>
<p>The <u>MutableMapping</u> abstract base class, from Python’s <strong>collections</strong> module and discussed in the preceding pages, is a valuable tool when implementing a map.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpywugxnuj30y80kg41s.jpg" alt=""></p>
<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><p>Python的dict功能是用Hash Table实现的，因此查找才辣么快。</p>
<p>The novel concept for a hash table is the use of a <u>hash function to map general keys to corresponding indices</u> in a table.</p>
<p>The <strong>goal</strong> of a hash function, h, is to <u>map each key k to an integer in the range [0,N − 1]</u>, where N is the capacity of the bucket array for a hash table.</p>
<p>If there are two or more keys with the same hash value, then two different items will be mapped to the same bucket in A. In this case, we say that a collision has occurred.</p>
<p>We say that a hash function is “good” if it maps the keys in our map so as to sufﬁciently minimize collisions. For practical reasons, we also would like a hash function to be fast and easy to compute.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpzbnkc5ej30xa0h8jtt.jpg" alt=""></p>
<p>The advantage of separating the hash function into two such components is that the hash code portion of that computation is independent of a speciﬁc hash table size. This allows the development of a general hash code for each object that can be used for a hash table of any size; only the compression function depends upon the table size. This is particularly convenient, <u>because the underlying bucket array for a hash table may be dynamically resized</u>, depending on the number of items currently stored in the map.</p>
<h3 id="几种常见Hash编码方法"><a href="#几种常见Hash编码方法" class="headerlink" title="几种常见Hash编码方法"></a>几种常见Hash编码方法</h3><h4 id="Treating-the-Bit-Representation-as-an-Integer"><a href="#Treating-the-Bit-Representation-as-an-Integer" class="headerlink" title="Treating the Bit Representation as an Integer"></a>Treating the Bit Representation as an Integer</h4><p>Python relies on 32-bit hash codes. If a ﬂoating-point number uses a 64-bit representation, its bits cannot be viewed directly as a hash code.（如果当前信息不超过32-bit，那么他本身就是编码后的hash-code）如果是64-bit可以用32+32/去掉其中一个32/两个32做异或</p>
<h4 id="Polynomial-Hash-Codes"><a href="#Polynomial-Hash-Codes" class="headerlink" title="Polynomial Hash Codes"></a>Polynomial Hash Codes</h4><p>用Bit-representaion会出现的问题：The summation and exclusive-or hash codes, described above, are not good choices for character strings or other variable-length objects that can be viewed as tuples of the form $(x_0,x_1,…,x_{n-1})$, where <strong>the order of the x i ’s is signiﬁcant</strong>.</p>
<p>An alternative hash code, which does exactly this, is to choose a nonzero constant, a = 1, and use as a hash code the value:<br>$$<br>x_0a^{n-1}+x_1a^{n-2}+…+x_{n-2}a+x_{n-1}<br>$$<br>By Horner’s rule (see Exercise C-3.50), this polynomial can be computed as:<br>$$<br>x_{n-1}+a(x_{n-2}+a(x_{n-3}+…+a(x_2+a(x_1+ax_0))))<br>$$<br>We have done some experimental studies that suggest that <u>33, 37, 39, and 41</u> are particularly good choices for a when working with character strings that are English words.</p>
<h4 id="Cyclic-Shift-Hash-Codes"><a href="#Cyclic-Shift-Hash-Codes" class="headerlink" title="Cyclic-Shift Hash Codes"></a>Cyclic-Shift Hash Codes</h4><p>A variant of the polynomial hash code replaces multiplication by a with a cyclic shift of a partial sum by a certain number of bits.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpzy363p5j30xg09440q.jpg" alt=""></p>
<p>python里面的hash(x)可以计算一个x的hash值，However, only <u>immutable data types</u> are deemed hashable in Python. This restriction is meant to ensure that a particular object’s hash code remains constant during that object’s lifespan. Among Python’s built-in data types, <u>the immutable int, ﬂoat, str, tuple, and frozenset</u> classes produce robust hash codes via the hash function. Instances of <u>user-deﬁned classes</u> are treated as unhashable by default, with a TypeError raised by the hash function.</p>
<p>An important rule to obey is that if x == y, then hash(x) == hash(y).</p>
<h3 id="Compression-Functions"><a href="#Compression-Functions" class="headerlink" title="Compression Functions"></a>Compression Functions</h3><p>mapping the hash code integer into the range [0,N −1]. A good compression function is one that <u>minimizes the number of collisions for a given set of distinct hash codes.</u></p>
<h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><p>分治方法将问题划为互不相交的子问题，递归的求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题有公共的子子问题。在这种情况下，DP对每个子子问题只会求解一次，将其<u>保存在一个表格</u>中。动态规划常用来解决<strong>最优化问题</strong></p>
<p>动态规划的四个步骤：</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归的定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造最优解</li>
</ol>
<p>计算一个p*q矩阵和一个q*r矩阵的成绩，需要计算p*q*r个标量乘法</p>
<p>钢条切割中每一个分段都是相同的，所有长度为k的钢条都属于一个子问题。但是矩阵链乘法每一个长度为k的子链都不相同，不属于一个子问题。</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frteyli23mj31260s07qh.jpg" alt=""></p>
<h1 id="Numeric-Optimization"><a href="#Numeric-Optimization" class="headerlink" title="Numeric Optimization"></a>Numeric Optimization</h1><h3 id="Newton’s-Method"><a href="#Newton’s-Method" class="headerlink" title="Newton’s Method"></a>Newton’s Method</h3><p>算法</p>
<p>优点</p>
<ul>
<li>fast convergence (under some condition)</li>
</ul>
<p>缺点</p>
<ul>
<li>Need second order derivative （二阶连续可导，为了防止出现切线斜率为0从而与x轴没有交点，如果此时找到了二阶导数为0的点，就是一个极值点）</li>
<li>Only 1-D</li>
</ul>
<h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>算法</p>
<p>优点</p>
<ul>
<li>n-D</li>
<li>only need first order derivative</li>
</ul>
<p>缺点</p>
<ul>
<li>Speed depends</li>
<li>Rosenbrock函数效果不太好，出现锯齿状（jag）</li>
</ul>
<h3 id="Golden-Section"><a href="#Golden-Section" class="headerlink" title="Golden Section"></a>Golden Section</h3><p>算法</p>
<p>用secant line (割线) 代替 tangent line（切线）</p>
<p>优点</p>
<ul>
<li>No derivative required</li>
<li>Fast</li>
</ul>
<p>缺点</p>
<ul>
<li>Only works on U-shape function. (可以考虑将一个大的函数切成几个小的U-shape部分)</li>
<li>1-D</li>
</ul>
<h3 id="Nelder-Mead"><a href="#Nelder-Mead" class="headerlink" title="Nelder-Mead"></a>Nelder-Mead</h3><p>算法</p>
<p>用一个三角形来估计切线</p>
<p>优点</p>
<ul>
<li>n-D</li>
</ul>
<p>缺点</p>
<ul>
<li>converge slowly</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1fs87tgwbsrj30ge0fiq7x.jpg" alt=""></p>
<h1 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h1><p>对称性+传递性无法推出自反性的例子：平行关系</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Others</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2020/07/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="关于这门MOOC"><a href="#关于这门MOOC" class="headerlink" title="关于这门MOOC"></a>关于这门MOOC</h1><p>Coursera上面吴恩达的机器学习。老老实实学完的，代码都是自己打的，很有成就感。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>要把每次编程作业放在桌面，再cd改到位置</li>
<li>可以直接在命令行type submit来提交</li>
<li>吴恩达不太喜欢gut feelings，更偏好systematic way</li>
</ul>
<a id="more"></a>



<h1 id="GUIDE"><a href="#GUIDE" class="headerlink" title="GUIDE"></a>GUIDE</h1><p>GUIDE default 只有十层 然后开始prune</p>
<p>一棵树的复杂度取决于两点：Tree的复杂度，Node的复杂度。</p>
<p>Node复杂度排序：Piecewise: constant&lt; simple linear&lt; simple polynomial&lt; stepwise&lt; multiple linear</p>
<p>有一个内置的可以建立交互作用的列的方法，在dsc-file里面序列写成0</p>
<p>Importance-Score 是用来提示我们不要漏掉某些在树上没有出现，但是实际也很重要的variable。</p>
<p>Loh说Box-plot应用场景是当我们只有20~50数据的时候，所以现在数据量很大的时候，不能用box-plot做outlier-detection</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>机器学习的定义：在标准P不变的情况下，从经验E中提升自己T操作的能力。<br>机器学习分为：</p>
<ul>
<li>监督学习：对于数据集中的每个数据，都有相应的真实值，以供机器来训练自己。例如：Regression &amp; Classification</li>
<li>无监督学习：对于数据集中的数据，是否能找出一种结构？例如：聚类（cluster）算法、鸡尾酒宴会（分离两种声音）</li>
</ul>
<p>Notations:</p>
<ul>
<li>m:训练集的数据量</li>
<li>h:拟合出来的函数是一个从x到y的映射，例如：Guide输出的R-function</li>
<li>J(θ):平方误差代价函数。J=RSS/2m</li>
<li>:= colon-equal 赋值assignment</li>
<li>n:自变量的个数:x1~xn</li>
</ul>
<p>要注意：h(x)是x的函数而J(θ)是θ的函数<br>J(θ)在只有一个参数的时候是抛物线，有两个参数的时候变成了一个『抛物面』。但是二维图中画不出来，所以便有一招，二维图两个轴分别代表θ0和θ1，然后画出contour plot。</p>
<p>Gradient Descent Algorithm梯度下降法：</p>
<ul>
<li>可以最小化函数。想象自己在一座山上，每次迈出一步，这一步的方向是当前位置下山最快的方向。</li>
<li>算法：repeat until convergence{θj := θj - α * (J对θj求偏导) 对J里面的每个θ同时操作} </li>
<li>α被称为learning rate，也就是下山的时候该迈多大的步子。</li>
<li>随着越来越接近最低点，导数项会变小，步子自然地也会越迈越小。</li>
<li>Batch GD：每一步求导都要用到整个（Batch）训练集。</li>
</ul>
<p>还有种方法叫Normal equation method? 答：就是正常的回归分析</p>
<p>3 * 3矩阵有时候也被写成R，3 * 3被放在了上标里面。n * 1的矩阵是R(4 * 1)，*1可以省略，于是就变成了常见的那个样子。<br>矩阵的(i,j)元素被称为：i,j entry<br>1-indexed &amp; 0-indexed：y1<del>yn &amp; y0</del>yn</p>
<p>Feature Scaling: </p>
<ul>
<li>Idea: Make sure features are on a similar scale.</li>
<li>做法：通过除法，将他们的Range搞到（-1，1）吴恩达自己的建议是（-3，3）</li>
</ul>
<p>经常通过画一个 min(J(θ))—No.of iterations 的图来判断收敛情况。<br>如果一次迭代导致的变化小于10^-3 jiu认为是收敛了<br>如果迭代之后MIN不降反升，那么可能是步子迈得太大，应该缩小α。<br>数学家证明了如果步子足够小，J（θ）应该每次迭代都会下降<br>α太小或者太小都有可能导致收敛的速度过慢。<br>所以如何寻找α？吴恩达先找一个足够大的上界和一个足够小的下界。然后三倍关系去试：0.001-0.003-0.01-0.03-0.1-…<br>存在一些算法来自动帮我们选择多项式回归次数<br>Normal Equation：就是用（x’x）-1x’y来计算β。缺点是在自变量很多的时候，矩阵不好算，而梯度更快（n大于10000）<br>计算n阶矩阵的逆大概需要O(n^3)<br>xTx不可逆一般有两种可能性：</p>
<ol>
<li>有两列高度线性相关</li>
<li>数据量过少或者自变量过多（极端情况就是行数小于列数）对于这种情况，要么删一些列，要么用regularization</li>
</ol>
<p>loss function 也叫 objective function</p>
<h1 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h1><p>除了Gradient Descend 其他方法都不需要自己输入步长$\alpha$并且也比梯度下降更快，缺点只是更复杂一点</p>
<p>主要方法：</p>
<ul>
<li>Gradient Descend</li>
<li>Conjugate Gradient</li>
<li>BFGS</li>
<li>L-BFGS</li>
<li>…</li>
</ul>
<h1 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h1><p>如果我们用线性拟合的话，一些超远处的离群值可能会对整个拟合直线产生巨大影响。</p>
<p>##Logistic</p>
<ul>
<li>用的是logistic/sigmoid function $y = \frac{1}{1+e^{-z}}$ 会产生一个0~1的函数。 Threshold一般设为0.5 也就是在z&gt;0的时候。一般来说z = $\theta^TX$ 所以，$\theta^TX=0$又被称为 Decision Boundry。所以Decision-boundary是一个关于hypothesis的性质而不是关于data set的性质</li>
<li>sigmoid在4.6的时候函数值为0.99. 在-4.6的时候函数值为0.01</li>
<li>Cost function. 如果用常规的square-error的话，最后的损失函数是non-convex的，会有多个局部最小值。Cost function: $cost(h_\theta(x),y) = -log(h_\theta(x))I_{y=1}-log(1-h_\theta(x))I_{y=0} =\ -ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$</li>
<li>哇！我们神奇的发现，使用梯度下降法时，logistic和linear的导数部分具有同样的形式$\theta_j:=\theta_j-\alpha\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x^{(i)}$</li>
<li></li>
</ul>
<h2 id="Multiclass-Classification"><a href="#Multiclass-Classification" class="headerlink" title="Multiclass Classification"></a>Multiclass Classification</h2><p>One v.s. All</p>
<ul>
<li>本质上还是logistic。对于每一个class，做一个属于该class和不属于该class的logistic。得到一个$h_\theta^1(x)$. 以此类推得到其他的。则对于一个新的test sample，我们看哪一个h最大，就将他划为哪一组。这时的y就不是一个单一的0/1随机变量，而是一个1一堆0的随机向量</li>
</ul>
<h1 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h1><ul>
<li>underfitting一般会带来High bias。overfitting会带来high variance</li>
<li>解决overfitting的办法：1、减少features（手动/采用一些变量选择方法）2.Regularization.</li>
</ul>
<h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><p>keep all features, but reduce magnitude/values of parameter.(变量前面的系数变小了) Works well when there are lots of features and each contributes a bit to the response.</p>
<p>Small values for parameter: 1. ‘Simpler Hypothesis’ 2.Less prone to overfitting</p>
<ul>
<li>具体操作：在损失函数后面加上$\lambda/2m$倍的所有系数平方和（除了intercept），shrink all parameters。$\lambda$被称为regularization parameter</li>
<li>在梯度递降法里面多了一项$-\frac{\alpha}{m}\lambda\theta_j$. 在最小二乘法中变成了$\widehat{\beta}=(X’X+\lambda*A)^{-1}X’Y$ 其中A是一个在1,1位置上是0的单位阵</li>
<li>这一招还顺带解决了$X’X$矩阵不可逆的情况，使之可逆</li>
</ul>
<h1 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h1><p>传统方法会有一些问题，比如在Nonlinear-classification的情况下：如果单单用线性拟合的话，在100个feature的时候，我们要动用polynomial轻易就可以达到O(n^3)，实在是太多变量了</p>
<p>大脑有个一个主管学习的区域，无论给他输入什么数据，他慢慢自己都能学会。例子：一个主管听力的皮层在改为接受视觉信号之后学会了主管视觉</p>
<p>六部走：</p>
<ol>
<li>Randomly initialize weights</li>
<li>implement forward propagation to get $h_{\Theta}(x^{(i)})$ for any $x^{(i)}$</li>
<li>compute cost function $J(\Theta)$</li>
<li>implement back-prop to compute partial derivatives</li>
<li>Use gradient-checking the derivatives.</li>
<li>Using advanced optimization method with back-prop to minimize cost function</li>
</ol>
<ul>
<li>parameters 有时也被称作weights</li>
<li>input layer - hidden layer - output layer</li>
<li>$a^{(j)}<em>{i}$表示第j层layer中第i个neuron. $\Theta^{(j)}$表示从第j层到第j+1层的变换（左乘）矩阵，矩阵维数为$S</em>{j+1}*(S_j+1)$最后加的这个1是因为有$a_0$截距项：Forward propagation</li>
<li>跟logistic的一个明显区别：不用原来的自变量x而是用经过hidden-layer变换后的新自变量</li>
<li>logical and/or 可以用sigmoid-function写。给intercept-a-b分别加权(-30,20,20)/(-10,20,20)</li>
<li>一般来说的话，先假设有一个hidden-layer，如果实在想多几个，那么也尽量保证每个hidden-layer的units个数相同。通常来说hidden-layer的units尽量也比feature（input-layer）多一点.</li>
</ul>
<h2 id="back-propagation-反向传播算法"><a href="#back-propagation-反向传播算法" class="headerlink" title="back-propagation 反向传播算法"></a>back-propagation 反向传播算法</h2><ul>
<li>先从左到右算出来函数值，再从右到左算出来导数/误差值。不计算常数项的误差</li>
<li>有时虽然cost-function在递降，但是可能会存在一些小bug，这是我们需要引入gradient-check：2-sided-difference 用切线斜率来估计导数：$[f(x+\epsilon)-f(x-\epsilon)]/2\epsilon$, where $\epsilon \approx 10^{-4}$.</li>
<li>random-initializing: 在$[-\epsilon,\epsilon]$里面取值。rand(dim)*2$\epsilon$-$\epsilon$.</li>
</ul>
<h1 id="Debugging-a-learning-algorithm"><a href="#Debugging-a-learning-algorithm" class="headerlink" title="Debugging a learning algorithm"></a>Debugging a learning algorithm</h1><ul>
<li>Get more training samples：解决过拟合</li>
<li>Try small sets of features(avoid overfitting)：解决过拟合</li>
<li>Try getting addtional features：解决欠拟合</li>
<li>Try adding polynomial features：解决欠拟合</li>
<li>increasing/decresing $\lambda$ in the regularization term</li>
</ul>
<h1 id="Diagnose-the-ML-algorithm"><a href="#Diagnose-the-ML-algorithm" class="headerlink" title="Diagnose the ML algorithm"></a>Diagnose the ML algorithm</h1><ul>
<li><p>error for classificationo problem: </p>
<ol>
<li>Misclassification cost(0,1) </li>
<li>logistic loss: $\frac{1}{m}\sum-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$</li>
</ol>
</li>
<li><p>如果只把data分成70%train-30%test（只分一次），会导致选出来一个针对30%test最优化的算法，也不够generalize。所以我们可以60%train-20%CV-20%test. 先用train来拟合参数，再用CV来选算法，最后用test来估计误差</p>
</li>
<li><p>High-bias = under-fitting. High-variance = over-fitting</p>
</li>
<li><p><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/I4dRkz_pEeeHpAqQsW8qwg_bed7efdd48c13e8f75624c817fb39684_fixed.png?expiry=1522454400000&hmac=1E-Lq6rt765ATz0C9v6hVDu6kI-vvqxkgRDRJjPzv6g" alt=""><br>这个图表示如果Train&amp;CV的误差都很大，那么是under-fitting，如果Train小CV大很可能是over-fitting</p>
</li>
<li><p>在包含regularization的例子中，如果我们选择的$\lambda$很大的话可能会导致under-fitting，相反则会导致over-fitting</p>
</li>
<li><p>所以我们该如何选择$\lambda$?：将$\lambda$从小到大排即是不同的模型，再用cost来拟合，CV来选择（这个CV的cost是不含regular那一项的，同理我们只用含regular的来拟合参数，报告train-error的时候也是不含regular那一项的）<br><img src="http://spark-public.s3.amazonaws.com/ml/images/10.5-quiz-1-option4.png" alt=""></p>
</li>
<li><p>一般来说，用一个复杂的神经网络+regularization，要比用一个简单的神经网络效果要好<br>##Learning curves: </p>
</li>
<li><p>横坐标是sample-size，纵坐标是error。其中error的计算只对用到的数据取平均（从100个样本中用了三个来拟合模型，那最后算cost的时候就只算这三个的平均cost）</p>
</li>
<li><p>在出现high-bias(under-fitting)的时候，增加数据量是没什么用的，但是overfitting的时候，增加数据量有用（模型不变的情况下）</p>
</li>
<li><p><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/bpAOvt9uEeaQlg5FcsXQDA_ecad653e01ee824b231ff8b5df7208d9_2-am.png?expiry=1522454400000&hmac=B5ywTJzWN1IdcfxIx5LZi95HO4qj3LSKt58YMNlcFk8" alt="High Bias"></p>
</li>
<li><p><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/vqlG7t9uEeaizBK307J26A_3e3e9f42b5e3ce9e3466a0416c4368ee_ITu3antfEeam4BLcQYZr8Q_37fe6be97e7b0740d1871ba99d4c2ed9_300px-Learning1.png?expiry=1522454400000&hmac=r2oACMou0U4Qm-LtPW7WwfdD-rd7dRiokQU8jYo61Co" alt="High Variance"></p>
</li>
</ul>
<h1 id="Recommended-Approach"><a href="#Recommended-Approach" class="headerlink" title="Recommended Approach"></a>Recommended Approach</h1><ol>
<li>先采用一个快速容易实现的方法，并且用CV来验证</li>
<li>画出learning-curves来判断我们是否需要更多数据/更多特征</li>
<li>Error-analysis 观看那些残差很大的点（或者是分错类的点），看他们为什么出了错</li>
<li>对各种不同的算法用一种方式来量化比较</li>
</ol>
<p>有时还涉及到要不要stemming/大小写（把discount,discounts看做一个，但也会把universe和university看成一个）这时候很难说效果怎么样，所以只能在CV集合上面测试一下，然后看看出错率</p>
<h2 id="Skewed-class"><a href="#Skewed-class" class="headerlink" title="Skewed class"></a>Skewed class</h2><ul>
<li><p>Precision/Recall: 可以写成一个二乘二矩阵<br>Precison = True prositive/Predicted Positive(第一行)<br>Recall = True prositive/Actual Positive(第一列)</p>
<p><img src="http://spark-public.s3.amazonaws.com/ml/images/11.3-quiz-1-q1.png" alt=""></p>
</li>
<li><p>一般来说都用y=1 来表示那个稀少的类（比如患了癌症）</p>
</li>
</ul>
<h3 id="Trade-off-between-Precision-amp-Recall"><a href="#Trade-off-between-Precision-amp-Recall" class="headerlink" title="Trade off between Precision&amp;Recall"></a>Trade off between Precision&amp;Recall</h3><ul>
<li>我们可以调整logistic的threshold。如果调高的话，会增加precision，降低recall</li>
<li>一种简单的方法是计算$\frac{P+R}{2}$，但明显不好，全部预测为0会得到差不多最好的结果</li>
<li>一种更通用的方法是计算F1-score:$2\frac{PR}{P+R}$。调和平均，（如果有一个0的话基本上F1-score就是0了）</li>
<li></li>
</ul>
<h2 id="Large-Data-Set"><a href="#Large-Data-Set" class="headerlink" title="Large Data Set"></a>Large Data Set</h2><ul>
<li>比的不是谁的算法吊，而是谁的数据量大（希望自己有朝一日能取到一家海量数据的公司）</li>
<li>遇到一个问题，问问自己，如果把这个信息告诉一个这方面的专家，他能不能做出准确的预测，如果能的话，说明这信息是充分的，那我们可以用海量数据来减小误差，如果不能，单纯增加数据量是没用的，我们必须获取其他的特征。</li>
</ul>
<h1 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h1><ul>
<li>cost function: $C\sum_{i=1}^m[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})] + \frac{1}{2}\sum_{i=1}^n\theta_j^2$</li>
<li>hypothesis: $h_\theta(x)=I(\theta^Tx\ge0)$</li>
<li>Large Marigin Intuition: margin指的是分界线距离两类各自边缘的距离，svm会选出来一条线使得这个距离最大，所以更robust。</li>
<li>C如果越大的话（相当于regularization里面的$\lambda$越小），整个SVM就会对离群值越敏感，容易出现过拟合</li>
<li>decision boundary那条线与$\vec{\theta}$ 是垂直的。</li>
<li>疑问：SVM desicion boundary是不是只由最边缘的点决定？</li>
<li>VS logistic：当数据量m远小于参数个数n的时候，用logistic/不带kernal的SVM，如果n比较小（1-1000）而m适中（10-10000），可以用Gaussian-kernal。如果n小m大（50000+）这时跑SVM就慢的一批，只能多加几个feature然后用logistic/不带kernal的SVM</li>
</ul>
<h2 id="Kernal"><a href="#Kernal" class="headerlink" title="Kernal"></a>Kernal</h2><ul>
<li>kernals有好多种（Gaussian…）目的是为了刻画x和landmark之间的similarity。不用kernal又被称为linear-kernal，在数据量不足的时候一般我们不能用太复杂的kernal</li>
<li>一个Kernal一定要满足Mercer’s Theorem</li>
<li>Ng举了一个中间护舒宝形状的X外面是O的分类例子，可以在中间设置两个landmark，然后用kernal来解决</li>
<li>Gauss的参数$\sigma^2$：$\sigma^2$越大，$f_i$的变化就越缓慢，容易导致欠拟合，higher-bias</li>
<li>做Gaussian之前，要对feature做scaling</li>
<li>其他kernal：polynomial-kernal（like $(X^Tl+a)^b$…），string-kernal(针对text类型的数据), chi-square-kernal, histogram-intersection-kernal</li>
</ul>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol>
<li>把每一个数据点都先标记成为landmark</li>
<li>计算feature vector：$f_i=similarity(x,l^{(i)})$ 可以增加常数项：$f_0=1$</li>
<li>预测y=1，当且仅当$\theta^Tf \ge 0$</li>
</ol>
<h1 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h1><h2 id="Clustering-Algorithm"><a href="#Clustering-Algorithm" class="headerlink" title="Clustering Algorithm"></a>Clustering Algorithm</h2><p><img src="https://i.stack.imgur.com/Yl4tV.png" alt="各个聚类方法的scale时间"></p>
<h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><ul>
<li>先随机找到两个点（只分两组的时候）</li>
<li>把其他的点根据距离初始点的距离划分成两大类</li>
<li>用分好的两大类的重心来代替原来的两个点。</li>
<li>循环1-3，直至converge</li>
</ul>
<p>distortion-cost-function：$\frac{1}{m}\sum_{i=1}^m||x^{(i)}-\mu_{c^{(i)}}||^2$</p>
<p>Initialization: 选取k&lt;m, 然后从数据点中随机选取k个作为$\mu_1 \sim \mu_k$. 有时候数据点选择的不好的话，会导致算法优化到局部最优而不是全局最优，这时我们可以做的是：随机选取100次，对于每次选择的k个随机点，我们计算他的cost，最后，在这100个随机cost中，选择cost最小的那个作为我们的initial k个点。</p>
<p>Elbow Method for choosing K：选择那个斜率变化最大点</p>
<h2 id="Dimensionality-Reduction"><a href="#Dimensionality-Reduction" class="headerlink" title="Dimensionality Reduction"></a>Dimensionality Reduction</h2><p>主要用途：</p>
<ul>
<li>为了visualize数据，我们可以把维数强行降到2，然后打印在平面图上</li>
<li>加快分析速度，减少内存使用</li>
</ul>
<p>PCA与linear的一个明显的区别：lm最小化竖着的线段平方，PCA最小化垂直线段的平方。因为lm里面y是我们更关心的点（主要目的就是为了预测y），而PCA中各个x地位是平等的。</p>
<p>步骤：</p>
<ul>
<li>先计算cov矩阵$\Sigma=\frac{1}{m}X^TX$（包含了标准化）</li>
<li>计算$\Sigma$矩阵的eigen：[U, S, V] = svd(Sigma) [其实eig函数也可以做，但是不如svd稳定] 其中U会返回按列排放的特征向量，S是个对角矩阵，存放了每个PC分别解释了多少的方差</li>
<li>最后: $z^{(i)}=U^Tx^{(i)}$</li>
<li>$x_{approx} = Uz^{(i)}$</li>
</ul>
<p>一个选择PCA个数的准则是解释99%/95%的方差</p>
<p>在做PCA的时候，只对train做，而不做CV和test</p>
<p>一个不好的例子：用PCA来防止过拟合（因为少了需要拟合的参数个数）。因为有时候我们在PCA中扔掉了一部分信息，但这部分信息很可能和y很有关，所以为了防止过拟合，不如直接使用regularization。</p>
<p>PCA使用建议：先对raw-data直接做分析，只有当原始数据做不了的时候（比如说太慢了或者内存不够大），再开始尝试PCA</p>
<h1 id="Anomaly-Detection"><a href="#Anomaly-Detection" class="headerlink" title="Anomaly Detection"></a>Anomaly Detection</h1><p>对于那些离群的异常点检测，定义一个p值（一个关于自变量的函数），如果p值过小就被视为离群值。</p>
<p>Machine-learning里面习惯用MLE来估计方差（分母是m）</p>
<h2 id="Gaussian-Distribution"><a href="#Gaussian-Distribution" class="headerlink" title="Gaussian Distribution"></a>Gaussian Distribution</h2><p>具体步骤：</p>
<ul>
<li>假设n个$x^{(i)}$是独立且是正态分布的，用已有的样本来估算均值和方差。</li>
<li>给定一个新样本，他的p值定义为$\prod_{i=1}^n\Phi_i(x_i)$</li>
<li>跟临界值进行大小比较</li>
</ul>
<p>一个实例：</p>
<ul>
<li>假设我们现在的数据多了一个label：正常/不正常，我们现在有10000个正常和20个不正常</li>
<li>先将数据分为三组：train（6000，0）CV（2000，10）Test（2000，10）</li>
<li>用Train那一组来拟合参数（每个变量的均值&amp;方差）</li>
<li>拿出CV，对于一个选定的临界值$\epsilon$，我们将$p(x_i)&lt;\epsilon$的那些样本点赋予y=1(不正常)，其他点赋值y=0. </li>
<li>将y对x进行NN/logistic，计算F1-score。通过不同$\epsilon$的选取，选出其中能使得F1-score最大的$\epsilon$作为最后的临界值。</li>
</ul>
<p>Anomaly-Detection v.s. Supervised-learning</p>
<ul>
<li>一般来说，Supervised-learning一般解决的问题是当两类数量差不多的时候，而当y=1特别少（skewed-class）的时候，我们惯用Anomaly-Detection</li>
<li>S-L一般解决未知数据长的很像test数据的问题，所以准确性更高。但一般skwed-class的异常都是「各有各的异常」，很可能未知的数据在以前就没有出现过，这时候一般都交给A-D来做。</li>
<li>像Spam-Email那个例子中，因为我们有很多Spam可以供训练模型，并且可能一般来说未来出现的垃圾邮件很可能和之前的垃圾邮件长得很像，所以我们采用Supervised-learning</li>
</ul>
<p>How to choose features?</p>
<ul>
<li>首先我们可以画出feature的分布图，如果看起来不是很正态，我们可以做一下box-cox（或者取log）来使得它看起来正态。（但是他说好像如果正态不满足的话好像算法也没啥大问题）</li>
<li>经常还会遇到的一个问题是：我们经常假设如果数据越异常，p(x)就会越小，但是有时候不论是不是异常，p(x)始终都差不多，这时候我们就需要加入新的变量（这里的新不仅可以加入之前没用的变量，还可以是一些变量的函数）。</li>
</ul>
<h2 id="Multivariate-Gaussian-Distribution"><a href="#Multivariate-Gaussian-Distribution" class="headerlink" title="Multivariate Gaussian Distribution"></a>Multivariate Gaussian Distribution</h2><p>如果两个变量之间存在cor，那么原来的圆形置信域就会变成椭圆形，导致一些异常点检测不出来(例子：一三象限方向的椭圆，对于二四象限的异常点有可能检测不出来，因为关于x-y轴的两个投影都不是很小)</p>
<ul>
<li><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fpwrxdd0l3j30qu0miwu5.jpg" alt=""></li>
</ul>
<p>我们只需要将原来的p(x)连乘变成多元正态里面的p(x)就可以了$p(x)=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))$<br>同样使用样本均值和样本协方差矩阵来估计那两个参数</p>
<h2 id="两种分布的对比："><a href="#两种分布的对比：" class="headerlink" title="两种分布的对比："></a>两种分布的对比：</h2><ul>
<li>多元正态自动捕捉了feature之间的协相关，单变量正态需要自己手动添加</li>
<li>单变量要比多元快很多</li>
<li>当数据量m小于变量个数n的时候（或者当feature之间线性相关的时候），多元正态协方差阵不可逆。当m比n大很多的时候（10倍），考虑用多元。</li>
</ul>
<h1 id="Recommander-System"><a href="#Recommander-System" class="headerlink" title="Recommander System"></a>Recommander System</h1><p>就拿电影评分来举例子：</p>
<ul>
<li>Feature-vector: 每个电影可以被量化成一个向量$x^{(i)}$, 第一位是截距项，后面的是每一种类别涉及到的比例（爱情0.5，动作0.8…）</li>
<li>r(i, j) = if user j has rated movie i 示性变量</li>
<li>$y^{(i,j)}$ = rating by user j on movie i</li>
<li>$\theta^{(j)}$ = parameter vector for user j : 观众的喜好向量(爱情5，动作8…)</li>
<li>$m^{(j)}$ = #of movies rated by user j</li>
<li>For user j , movie i, predicted rating: $(\theta^{(j)})^Tx^{(i)}$</li>
<li>Cost-function for each $\theta^{(j)}$: $\frac{1}{2m^{(j)}}\sum_{r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2m^{(j)}}$</li>
<li>Cost-function for all users: 只需要把上面这个cost-function 对所有用户求和即可</li>
</ul>
<h2 id="Collabrative-Filtering"><a href="#Collabrative-Filtering" class="headerlink" title="Collabrative Filtering"></a>Collabrative Filtering</h2><ul>
<li>Optimization algorithm: 还可以给定$\theta$ 反向来求出feature-vector $x^{(i)}$</li>
<li>Try to minimize: $\frac{1}{2}\sum_{r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{k=1}^n (x_k^{(i)})^2$</li>
<li>最后我们对每一个电影都算一下上面的cost然后求和。</li>
</ul>
<p>所以实际上我们可以估计用户的初始$\theta$，然后来拟合feature，再用拟合的feature重新拟合用户的$\theta$，如此循环往复，最后收敛到一个合理的结果。</p>
<p>但是我们可以更进一步，把两种cost-function写在一起，同时对他们整体做minimization，一步到位。这时候也不用填写截距项，因为算法应该会自动添加需要的截距项。开始需要randomly initialize number，为了symmetry-breaking</p>
<p>Low rank matrix factorization: 将预测用户的评分写成一个矩阵：$X\Theta^T$</p>
<p>判断两个电影很像，small $||x^{(i)}-x^{(j)}||$</p>
<h2 id="Mean-Normalization"><a href="#Mean-Normalization" class="headerlink" title="Mean Normalization"></a>Mean Normalization</h2><p>如果一个新用户曾经没有给任何电影评分，那么根据我们上面的cost-function来看，最佳的预测就是该用户的$\theta$是一个零向量。这样我们也不能给他推荐什么电影，没有什么意义。</p>
<p>步骤：</p>
<ul>
<li>对于每个电影，计算当前用户评分的均值。</li>
<li>然后将每个用户对于当前电影的评分减去均值</li>
<li>这时新用户的一排零，就变成了各个电影都是‘‘适中’’评分，我们就可以给他推荐电影啦</li>
</ul>
<h1 id="Dealing-With-Large-Data-Set"><a href="#Dealing-With-Large-Data-Set" class="headerlink" title="Dealing With Large Data Set"></a>Dealing With Large Data Set</h1><p>为什么我们要用更多的数据？</p>
<ul>
<li>我们可以画出learning-curve，然后发现当m很小的时候，$J_{CV}$很大，我们面临了high variance的情况，这时候提高m的数量有助于更好的拟合。但是如果我们发现learning-curve呈现的是high-bias的情况，那么我们就没啥必要提高m的数量了。</li>
</ul>
<h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p>正常的一次性计算所有的梯度下降又被称为Batch-Gradient-Descent：$\theta_j:=\theta_j-\alpha\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x^{(i)}$</p>
<p>步骤：</p>
<ol>
<li>Randomly Shuffle the dataset 随机排序</li>
<li>从第一个数据开始，对每个数据做一个小的单变量梯度递降。$\theta_j:=\theta_j-\alpha (h_\theta(x^{(i)})-y^{(i)})x^{(i)}$ for every j</li>
<li>重复做第二步1-10遍(每一次都重新shuffle)</li>
<li>最后应该会落到全局最优的附近</li>
</ol>
<p>Check for convergence:</p>
<ul>
<li>在每一次更新$\theta$之前，记录当前数据点的$cost(\theta,(x^{(i)},y^{(i)}))$</li>
<li>每更新比如说1000次，计算一下1000个cost的平均</li>
<li>最后将这些平均数进行比较，画个图</li>
<li>一般来说数据取得越大（比如说用5000代替1000），$J_\theta$关于迭代次数的曲线就会越平滑</li>
<li>如果发现$J_\theta$不降反升，那么我们可以试着减少步长$\alpha$（learning-rate）</li>
<li>如果我们想试着最后落入到全局最优点，我们可以逐渐减小步长，let $\alpha = const1/(#iteration+const2)$</li>
<li></li>
</ul>
<h2 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h2><p>正常的Batch每次迭代用到all m examples. Stochastic只用1个。Mini-batch取了个中间地带，每次用b个，其中b也被称为mini-batch size.</p>
<p>步骤：</p>
<ol>
<li>Randomly Shuffle the dataset 随机排序</li>
<li>从第一个数据开始，b个b个的应用梯度下降来迭代$\theta_j$</li>
<li>重复做第二步1-10遍(每一次都重新shuffle)</li>
<li>最后应该会落到全局最优的附近</li>
</ol>
<p>Mini-Batch 如果想要比Stochastic跑得更快，就必须要应用Vectorization</p>
<h2 id="Online-Learning"><a href="#Online-Learning" class="headerlink" title="Online Learning"></a>Online Learning</h2><p>一个数据网站，获取用户的数据，不停的更新原来的$\theta$, learning continuously<br>CTR: 用户搜索一个信息，我们来预测他会不会点击我们给他提供的链接，learning the predicted Click Through Rate</p>
<p>步骤：</p>
<ul>
<li>永久性的循环以下步骤</li>
<li>获得数据（x, y）, 更新$\theta_j:=\theta_j-\alpha (h_\theta(x)-y)x_j$</li>
<li>把数据(x, y)扔掉，只保留更新后的$\theta$</li>
</ul>
<h2 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map Reduce"></a>Map Reduce</h2><p>如果有四百个数据，在计算梯度下降的时候可以把数据分成四份，分给四个电脑去同时并行做。</p>
<p>为什么可以用Map-Reduce：Many learning algorithm can be expressed as computing sums of functions over the training set. 算法可以写成关于数据量的求和</p>
<p>有时候就算没有多台电脑，一个电脑有很多个核，也可以做Multi-core Machines</p>
<p>Open Source：Hadoop</p>
<h1 id="Photo-OCR"><a href="#Photo-OCR" class="headerlink" title="Photo OCR"></a>Photo OCR</h1><p>Photo Optical Character Recognition</p>
<p>主要步骤（pipeline）: </p>
<ol>
<li>Get a Image</li>
<li>Text Detection</li>
<li>Charcter Segmentation</li>
<li>Character Classification</li>
</ol>
<h2 id="Sliding-Windows"><a href="#Sliding-Windows" class="headerlink" title="Sliding Windows"></a>Sliding Windows</h2><h3 id="Pedestrian-Detection"><a href="#Pedestrian-Detection" class="headerlink" title="Pedestrian Detection"></a>Pedestrian Detection</h3><p>Supervised-learning-version: </p>
<ul>
<li>我们给定一些<u>固定大小</u>的人像的正确例子（y=1），和一些不是人像的例子（y=0）</li>
<li>紧接着，我们在原图上从左上角开始一点点向右移（step/sliding-size）如果一个像素一个像素移动的话太慢了，所以我们会让他每次跨的大一点。过完一行，再来一行….直到整个图都被过了一遍</li>
<li>然后，我们将选取框放大一点，再跑一边步骤二（不管选取框是多大，在做检验的时候都要先变成和给定例子training-set中的大小一致）</li>
</ul>
<p>现在让我们回到Text-Detection：</p>
<ul>
<li>text-detection比行人识别的一大难点在于大小不是固定的</li>
<li>所以开始的时候先一个一个像素点过，形成一个黑底图，上面的白色表示可能存在text</li>
<li>下一步是Text-expansion 将临近的白色区域连接起来，看成一大块文字域</li>
</ul>
<p>Character-segmentation 也可以用sliding window来做</p>
<h1 id="Artificial-Data-Synthesis"><a href="#Artificial-Data-Synthesis" class="headerlink" title="Artificial Data Synthesis"></a>Artificial Data Synthesis</h1><ol>
<li>creating data from stretch 无中生有</li>
<li>amplify the small data set 将小数据集变大</li>
</ol>
<p>吴恩达用的是字母识别的例子，无中生有：自己在网上找点字体，自己加点背景上去。以小见大：从已有的字体图片，经过旋转变形生出新的字体图片</p>
<p>Make sure you have a low bias classfier before expending the effort. 如果当前是过拟合的话是需要更多数据，但如果是欠拟合的话，我们首先应该考虑的是在模型里面多放几个变量，而不是通过这种方式使得数据变多。</p>
<p>其次应该问自己的问题是，如果要把当前数据量变成十倍，需要多少工作量？</p>
<h1 id="Ceiling-Analysis"><a href="#Ceiling-Analysis" class="headerlink" title="Ceiling Analysis"></a>Ceiling Analysis</h1><p>在一个pipeline中，先看overall accuracy。然后再去第一个环节，手动把第一个环节准确率调成100%，看看对overall有什么影响。</p>
<p>有助于我们发现pipeline中哪一环节是最需要花时间来提高的</p>
<p>吴恩达嘲讽了一手：说有个小组，花了一年时间专门研究怎么去掉背景，甚至还发了论文，但最后发现准确率从85%提高到了85.1%，并没什么卵用</p>
<h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><h2 id="Sentiment-Analysis"><a href="#Sentiment-Analysis" class="headerlink" title="Sentiment Analysis"></a>Sentiment Analysis</h2><p>There are many types and flavors of sentiment analysis:</p>
<ol>
<li>Fine-grained Sentiment Analysis</li>
<li>Emotion detection</li>
<li>Aspect-based Sentiment Analysis</li>
<li>Intent analysis</li>
<li>Multilingual sentiment analysis</li>
</ol>
<p>Some of the advantages of sentiment analysis:</p>
<ol>
<li>Scalability</li>
<li>Real-time analysis</li>
<li>Consistent criteria</li>
</ol>
<p>Methods and algorithms to implement sentiment analysis systems:</p>
<ol>
<li><p><strong>Rule-based</strong> systems that perform sentiment analysis based on a set of manually crafted rules.</p>
<ul>
<li><p>Classic NLP techniques like <em>stemming</em>, <em>tokenization</em>, <em>part of speech tagging</em> and <em>parsing</em>.</p>
</li>
<li><p>常用方式是建立两个集合，一个好一个坏。对一段文字，我们数其中好的词出现的频率和坏的词出现的频率，哪个多选哪个。一样多就是中性。这个方法坏处在于：</p>
<ol>
<li>只算了单个的词而没有组合起来</li>
<li>添加更多规则之后很容易就变得超级复杂，并且不同的rule之间可能冲突，需要很多的人工进行tune</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Learning-based/Automatic</strong> systems that rely on machine learning techniques to learn from data.</p>
<ul>
<li>不用人工的rule，从文字中抽取feature和label，都一起扔给机器学习算法。</li>
<li><strong>Feature</strong>: 一般是numeric结果。Usually, each component of the vector represents the <u>frequency</u> of a word or expression in a <u>predefined dictionary</u> . The classical approach has been <a href="https://machinelearningmastery.com/gentle-introduction-bag-words-model/" target="_blank" rel="noopener">bag-of-words</a> or <a href="https://www.quora.com/What-is-the-difference-between-bag-of-words-and-bag-of-n-grams" target="_blank" rel="noopener">bag-of-ngrams</a> with their frequency. </li>
<li>More recently, new feature extraction techniques have been applied based on word embeddings (also known as <em>word vectors</em>). This kind of representations makes it possible for words with similar meaning to have a similar representation, which can improve the performance of classifiers. （这一段是为了提高准确率的，但是我没搞懂他是怎么操作的）</li>
<li><strong>Classification Algorithms:</strong> Naïve Bayes, Logistic Regression, Support Vector Machines, or Neural Networks</li>
<li>Metric 判断：Precision, Recall, and Accuracy（是不是也考虑F1）但是老师要求的是RMSE。<a href="https://en.wikipedia.org/wiki/Krippendorff%27s_alpha" target="_blank" rel="noopener">Krippendorff’s Alpha</a> 也是一个好的评分方法，0.67/0.8为界</li>
</ul>
</li>
<li><p><strong>Hybrid</strong> systems that combine both rule based and automatic approaches.</p>
<ul>
<li>Usually, by combining both approaches, the methods can improve accuracy and precision. 周子涵说过什么stacking</li>
</ul>
</li>
</ol>
<p><strong>Irony and Sarcasm</strong> 讽刺语气感觉是个难点。Yeah, sure.有时候表达的是无所谓了就这样吧的意思</p>
<p><strong>Comparisons</strong>: 一些例子：</p>
<ol>
<li><em>This product is second to none.</em></li>
<li><em>This is better than old tools.</em></li>
<li><em>This is better than nothing.</em></li>
</ol>
<p><strong>Emojis</strong>: 疯了。丧心病狂</p>
<p><em>Western emojis</em> (e.g. :D) are encoded in only one character or in a combination of a couple of them whereas <em>Eastern emojis</em> (e.g. ¯ \ _ (ツ) _ / ¯) are a longer combination of characters of a vertical nature. </p>
<p><strong>转折Ordering Effect</strong>：</p>
<p>听说不错，演员也好，票房也高，然而我觉得它糟糕透了。</p>
<h3 id="Subjectivity-classification"><a href="#Subjectivity-classification" class="headerlink" title="Subjectivity classification"></a>Subjectivity classification</h3><p>Goal: Classifying a sentence as <em>subjective</em> or <em>objective</em></p>
<p>Text information can be broadly categorized into two main types: <em>facts</em> and <em>opinions</em>.</p>
<h4 id="Opinion"><a href="#Opinion" class="headerlink" title="Opinion"></a>Opinion</h4><p>There are two kinds of opinions: <em>direct</em> and <em>comparative</em>.</p>
<p>There are also two kinds of opinions: <em>Explicit</em> and <em>Implicit</em>.</p>
<h3 id="Polarity-classification"><a href="#Polarity-classification" class="headerlink" title="Polarity classification"></a>Polarity classification</h3><p>Goal: Classifying a sentence as expressing a <em>positive</em>, <em>negative</em> or <em>neutral</em> opinion</p>
<p><strong>Baseline Algorithms</strong>:</p>
<ol>
<li>Tokenize<ul>
<li>Christopher potts sentiment tokenizer</li>
<li>How to handle negation?<ul>
<li>Das and Chen: add NOT_ 然后把很多NOT_like 这种词也变成一个feature</li>
</ul>
</li>
<li>All words/Only adj ? [It seems all words is better]</li>
</ul>
</li>
<li>Feature Extraction</li>
<li>Classification:<ul>
<li>Naive Bayes<ul>
<li>$\frac{count(w,c)+1}{count(c) + V}$</li>
<li>Binarized / (boolean feature) multinomial naive bayes.<ul>
<li>Word occurance matter more than word frenquency</li>
<li>Prior: $p(c) = \frac{doc\ with\ words}{all\ docs}$ . Prob: <strong>Remove duplicate</strong> in each doc and then same as above.</li>
</ul>
</li>
</ul>
</li>
<li>MaxEnt</li>
<li>SVM</li>
</ul>
</li>
</ol>
<p><strong>正负词汇包：</strong></p>
<ol>
<li><p>The Genearal Inquiry 包含了正面以及负面的词汇</p>
</li>
<li><p>LIWC 单次分类 <a href="http://liwc.wpengine.com/" target="_blank" rel="noopener">http://liwc.wpengine.com/</a></p>
</li>
<li><p>MPQA 单次分类 还包含了程度<a href="http://people.cs.pitt.edu/mpqa/subj_lexicon.html" target="_blank" rel="noopener">http://people.cs.pitt.edu/mpqa/subj_lexicon.html</a></p>
</li>
<li><p>Bing Liu Opinion Lexicon</p>
</li>
<li><p>SentiWordnet</p>
</li>
</ol>
<p>我们不能单纯的用raw count。eg. bad这个词出现的10星评论比2星评论多，是因为2星评论本来就很少。我们应该:<br>​    1. 用likelihood(ratio) $\frac{Target\ words}{Total\ words}$</p>
<ol start="2">
<li>scaled likelihood, make them camparable between words</li>
</ol>
<p>logical negation 也是一个好的feature，更多出现在负面评价里面</p>
<p>除了用别人的词汇包，我们可以自创词汇包：semi-supervised learning of lexicon</p>
<p>Finding <strong>aspects or attributes</strong>: Target of sentiment：</p>
<pre><code>1. Find all highly frequent phrases
2. Filter rule like: *Occur right after a sentiment word*
3. Supervised learning. 先找到商家对应的类别（比如餐厅），然后在餐厅的常见aspect中做一个classifier判断是哪一类</code></pre><p>所以整个流程是:</p>
<ol>
<li>Extract sentences and phrases</li>
<li>Sentiment classifier: 判断是积极/消极/中性</li>
<li>对于不是中性的评论，我们找出他们的类别</li>
<li>汇总在一起</li>
</ol>
<p>还有个问题是：Baseline methods assume classes have equal frequencies. 解决办法：</p>
<ol>
<li>不用accuracy， 最好用F-score</li>
<li>Re-sampling. 变为同样样本数</li>
<li>penalize for misclassification of the rare class</li>
</ol>
<p>对于五分类问题：</p>
<ol>
<li>Linear / Ordinal regression</li>
<li>Specialized model like metric labeling</li>
</ol>
<h2 id="Information-Exaction"><a href="#Information-Exaction" class="headerlink" title="Information Exaction"></a>Information Exaction</h2><p>目的：</p>
<ol>
<li>Find and understand limited relevant parts of texts</li>
<li>Gather INformation from many pieces of texts</li>
<li>NER: Name Entity Recognition</li>
</ol>
]]></content>
      <categories>
        <category>Study</category>
        <category>Courses</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>统计学习笔记</title>
    <url>/2020/07/02/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>记录一下学统计的时候遇到的一些问题</p>
<a id="more"></a>



<h1 id="旧版"><a href="#旧版" class="headerlink" title="旧版"></a>旧版</h1><p>17.11.13<br>###为什么我们要用R里面的anova函数比较多个模型？<br><a href="https://stats.stackexchange.com/questions/115304/interpreting-output-from-anova-when-using-lm-as-input" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/115304/interpreting-output-from-anova-when-using-lm-as-input</a></p>
<p>①First of all, you may be perfectly satisfied with the summary output, and that’s fine. However, the ANOVA table may offer some advantages. First, if you have a categorical / factor variable with more than two levels, the summary output is hard to interpret. It will give you tests of individual levels against the reference level, but won’t give you a test of the factor as a whole</p>
<p>②Another reason you might prefer to look at an ANOVA table is that it allows you to use information about the possible associations between your independent variables and your dependent variable that gets thrown away by the t-tests in the summary output. Consider your own example, you may notice that the p-values from the two don’t match (e.g., for v1, the $p$-value in the summary output is 0.93732, but in the ANOVA table it’s 0.982400). The reason is that your variables are not perfectly uncorrelated</p>
<p>The result of this is that there are sums of squares that could be attributed to more than one of the variables. The t-tests are equivalent to ‘type III’ tests of the sums of squares, but other tests are possible. The default ANOVA table uses ‘type I’ sums of squares, which can allow you to make more precise–and more powerful–tests of your hypotheses</p>
<p>Anova的目的：partition the sums of squares</p>
<p>###Further understanding of Type 123 test of RSS:<br><a href="https://stats.stackexchange.com/questions/20452/how-to-interpret-type-i-type-ii-and-type-iii-anova-and-manova/20455#20455" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/20452/how-to-interpret-type-i-type-ii-and-type-iii-anova-and-manova/20455#20455</a></p>
<p>Lets imagine that there are just two factors A and B (and we’ll throw in the A*B interaction later to distinguish type II SS). Further, lets imagine that nij不完全一样。<br>Now your two factors are correlated with each other.The problem with your factors being correlated is that there are sums of squares that are associated with both A and B. </p>
<p>When computing an ANOVA (or any other linear regression), we want to partition the sums of squares. A partition puts all sums of squares into one and only one of several subsets. (For example, we might want to divide the SS up into A, B and error.) However, since your factors (still only A and B here) are not orthogonal there is no unique partition of these SS. In fact, there can be very many partitions, and if you are willing to slice your SS up into fractions (e.g., “I’ll put .5 into this bin and .5 into that one”), there are infinite partitions. A way to visualize this is to imagine the MasterCard symbol: The rectangle represents the total SS, and each of the circles represents the SS that are attributable to that factor, but notice the overlap between the circles in the center, those SS could be given to either circle.</p>
<p><img src="https://i.stack.imgur.com/Dy8mt.jpg" alt=""></p>
<p>The question is: How are we to choose the ‘right’ partition out of all of these possibilities? Let’s bring the interaction back in and discuss some possibilities:<br>Type I SS:<br>    •    SS(A)<br>    •    SS(B|A)<br>    •    SS(A<em>B|A,B)<br>Type II SS:<br>    •    SS(A|B)<br>    •    SS(B|A)<br>    •    SS(A</em>B|A,B)<br>Type III SS:<br>    •    SS(A|B,A<em>B)<br>    •    SS(B|A,A</em>B)<br>    •    SS(A*B|A,B)</p>
<p>Notice how these different possibilities work. Only type I SS actually uses those SS in the overlapping portion between the circles in the MasterCard symbol. That is, the SS that could be attributed to either A or B, are actually attributed to one of them when you use type I SS (specifically, the one you entered into the model first). In both of the other approaches, the overlapping SS are not used at all. Thus, type I SS gives to A all the SS attributable to A (including those that could also have been attributed elsewhere), then gives to B all of the remaining SS that are attributable to B, then gives to the A<em>B interaction all of the remaining SS that are attributable to A</em>B, and leaves the left-overs that couldn’t be attributed to anything to the error term.</p>
<p>Type III SS only gives A those SS that are uniquely attributable to A, likewise it only gives to B and the interaction those SS that are uniquely attributable to them. The error term only gets those SS that couldn’t be attributed to any of the factors. Thus, those ‘ambiguous’ SS that could be attributed to 2 or more possibilities are not used. If you sum the type III SS in an ANOVA table, you will notice that they do not equal the total SS. In other words, this analysis must be wrong, but errs in a kind of epistemically conservative way. Many statisticians find this approach egregious, however government funding agencies (I believe the FDA) requires their use.</p>
<p>The type II approach is intended to capture what might be worthwhile about the idea behind type III, but mitigate against its excesses. Specifically, it only adjusts the SS for A and B for each other, not the interaction. However, in practice type II SS is essentially never used. You would need to know about all of this and be savvy enough with your software to get these estimates, and the analysts who are typically think this is bunk.<br>There are more types of SS (I believe IV and V). They were suggested in the late 60’s to deal with certain situations, but it was later shown that they do not do what was thought. Thus, at this point they are just a historical footnote.</p>
<p>As for what questions these are answering, you basically have that right already in your question:<br>    •    Estimates using type I SS tell you how much of the variability in Y can be explained by A, how much of the residual variability can be explained by B, how much of the remaining residual variability can be explained by the interaction, and so on, in order.<br>    •    Estimates based on type III SS tell you how much of the residual variability in Y can be accounted for by A after having accounted for everything else, and how much of the residual variability in Y can be accounted for by B after having accounted for everything else as well, and so on. (Note that both go both first and last simultaneously; if this makes sense to you, and accurately reflects your research question, then use type III SS.)</p>
<p>2017.11.14<br>###What does Standardized Residuals mean?</p>
<p>Intuition:every residual has different variance, so we need to consider standardized residuals.</p>
<p>When you compare the cells, the standardized residual makes it easy to see which cells are contributing the most to the chi-square value, and which are contributing the least.If your sample is large enough, the standardized residual can be roughly compared to a z-score. Standardization can work even if your variables are not normally distributed.<br>    •    If the residual is less than -2, the cell’s observed frequency is less than the expected frequency.<br>    •    Greater than 2 and the observed frequency is greater than the expected frequency. 之所以用2是因为95%双边正态</p>
<p>2017.11.15</p>
<p>###One Sample T-test:</p>
<p>为了检验所给数据是否来自同一个均值总体。需要给出一个原假设Ho：μ=μ0</p>
<p>The test statistic is calculated as:<br>R code： t.test(a, mu=120)</p>
<p>2017.11.19<br>###为什么我们要对数据进行变换（比如log）：<br>有时候我们希望残差能满足高斯马尔科夫假设。</p>
<p>2017.11.20<br>###Forward and Backward selection 的主要差别：</p>
<p>Forward selection has drawbacks, including the fact that each addition of a new feature may render one or more of the already included feature non-significant (p-value&gt;0.05). An alternate approach which avoids this is backward selection.The backward method is generally the preferred method, because the forward method produces so-called suppressor effects. These suppressor effects occur when predictors are only significant when another predictor is held constant.</p>
<p>2017.11.25</p>
<h3 id="Added-Variable-Plot-Partial-Regression-Plot"><a href="#Added-Variable-Plot-Partial-Regression-Plot" class="headerlink" title="Added Variable Plot (Partial Regression Plot)"></a>Added Variable Plot (Partial Regression Plot)</h3><p><a href="https://stats.stackexchange.com/questions/125561/what-does-an-added-variable-plot-partial-regression-plot-explain-in-a-multiple" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/125561/what-does-an-added-variable-plot-partial-regression-plot-explain-in-a-multiple</a></p>
<p>可以告诉我们如果变量之间存在线性相关的话，不能在回归模型中单独对Y和某一个X画图。可能会有Omitted-Variable Bias.</p>
<p>主要原理：纵坐标画Y对除了我们关心的Xi之外其他的X拟合出来的残差，横坐标画我们所关心的Xi对其他所有X拟合出来的残差。R中car包里的avPlots可以实现这个功能。</p>
<p>For illustration I will take a less complex regression model Y=β1+β2X2+β3X3+ϵ where the predictor variables X1 and X2 may be correlated. Let’s say the slopes β2 and β3 are both positive so we can say that (i) Y increases as X2 increases, if X3 is held constant, since β2 is positive; (ii) Y increases as X3 increases, if X2 is held constant, since β3 is positive.</p>
<p>Note that it’s important to interpret multiple regression coefficients by considering what happens when the other variables are held constant (“ceteris paribus”). Suppose I just regressed Y against X2 with a model Y=β′1+β′2X2+ϵ′. My estimate for the slope coefficient β′2, which measures the effect on Y of a one unit increase in X2 without holding X3 constant, may be different from my estimate of β2 from the multiple regression - that also measures the effect on Y of a one unit increase in X2, but it does hold X3 constant. The problem with my estimate β′2^ is that it suffers from omitted-variable bias if X2 and X3 are correlated.</p>
<p>To understand why, imagine X2 and X3 are negatively correlated. Now when I increase X2 by one unit, I know the mean value of Y should increase since β2&gt;0. But as X2 increases, if we don’t hold X3 constant then X3 tends to decrease, and since β3&gt;0 this will tend to reduce the mean value of Y. So the overall effect of a one unit increase in X2 will appear lower if I allow X3 to vary also, hence β2′&lt;β2. Things get worse the more strongly X2 and X3 are correlated, and the larger the effect of X3 through β3 - in a really severe case we may even find β2′&lt;0 even though we know that, ceteris paribus, X2 has a positive influence on Y!</p>
<p>A lot of the value of an added variable plot comes at the regression diagnostic stage, especially since the residuals in the added variable plot are precisely the residuals from the original multiple regression. This means outliers and heteroskedasticity can be identified in a similar way to when looking at the plot of a simple rather than multiple regression model. Influential points can also be seen - this is useful in multiple regression since some influential points are not obvious in the original data before you take the other variables into account. In my example, a moderately large X2 value may not look out of place in the table of data, but if the X3 value is large as well despite X2 and X3 being negatively correlated then the combination is rare. “Accounting for other predictors”, that X2 value is unusually large and will stick out more prominently on your added variable plot.</p>
<p>∗∗ More technically they would be the residuals from running two other multiple regressions: the residuals from regressing Y against all predictors other than X2 go on the vertical axis, while the residuals from regression X2 against all other predictors go on the horizontal axis. This is really what the legends of “Y given others” and “X2 given others” are telling you. Since the mean residual from both of these regressions is zero, the mean point of (X2 given others, Y given others) will just be (0, 0) which explains why the regression line in the added variable plot always goes through the origin. But I often find that mentioning the axes are just residuals from other regressions confuses people (unsurprising perhaps since we now are talking about four different regressions!) so I have tried not to dwell on the matter. Comprehend them as “X2 given others” and “Y given others” and you should be fine.</p>
<p>2017.12.3</p>
<h3 id="Imbalanced-Classification-Problems"><a href="#Imbalanced-Classification-Problems" class="headerlink" title="Imbalanced Classification Problems"></a>Imbalanced Classification Problems</h3><p><a href="https://www.analyticsvidhya.com/blog/2016/03/practical-guide-deal-imbalanced-classification-problems/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2016/03/practical-guide-deal-imbalanced-classification-problems/</a></p>
<p>Definition: An imbalanced classification problem is one in which the dependent variable has imbalanced proportion of classes. In other words, a data set that exhibits an unequal distribution between its classes is considered to be imbalanced.</p>
<p>Reason: Below are the reasons which leads to reduction in accuracy of ML algorithms on imbalanced data sets:<br>    1.    ML algorithms struggle with accuracy because of the unequal distribution in dependent variable.<br>    2.    This causes the performance of existing classifiers to get biased towards majority class.<br>    3.    The algorithms are accuracy driven i.e. they aim to minimize the overall error to which the minority class contributes very little.<br>    4.    ML algorithms assume that the data set has balanced class distributions.<br>    5.    They also assume that errors obtained from different classes have same cost (explained below in detail).</p>
<p>Solution：Below are the methods used to treat imbalanced datasets:<br>    1.    Undersampling<br>    2.    Oversampling<br>    3.    Synthetic Data Generation<br>    4.    Cost Sensitive Learning</p>
<p>2017.12.5</p>
<h3 id="Advantages-about-Mid-P-Value"><a href="#Advantages-about-Mid-P-Value" class="headerlink" title="Advantages about Mid P-Value"></a>Advantages about Mid P-Value</h3><p>①The mid P is less conservative (that is more powerful)<br>②For larger samples the P value obtained from a χ² test with Yates’ correction will correspond to the conventional approach, and the P value from the uncorrected test will correspond to the mid P value.——应该是说小样本因为离散程度更高，所以需要mid p-value.大样本一般不用mid p-value</p>
<h3 id="Fisher-Exact-Test"><a href="#Fisher-Exact-Test" class="headerlink" title="Fisher Exact Test"></a>Fisher Exact Test</h3><p><a href="http://www2.fiu.edu/~howellip/Fisher.pdf" target="_blank" rel="noopener">http://www2.fiu.edu/~howellip/Fisher.pdf</a><br>让我重新了解了p值的概念。<br>一下讨论的p-值都建立在原假设H0：π=π0<br>我们往往定义p值的时候，曲线都是随着x的变化，中间高两边低。所以很自然的，就会误以为，p值是对当x等于或者大于（小于）某一特定值的y进行求和。殊不知，其实p值关心的更多是y！如果给出一个中间低两边高的分布。那么<br>①单边p值：算出一个若H0成立时候的均值。若观测值大于均值，那么P值就是大于等于观测值的概率。如果观测值小于均值，那么P值就是小于等于观测值的概率。<br>②双边p值：对于所有小于观测值的情况，进行积分。</p>
<p>2017.12.7</p>
<h3 id="各种Independence之间的关系"><a href="#各种Independence之间的关系" class="headerlink" title="各种Independence之间的关系"></a>各种Independence之间的关系</h3><p><a href="https://onlinecourses.science.psu.edu/stat504/node/108" target="_blank" rel="noopener">https://onlinecourses.science.psu.edu/stat504/node/108</a><br>    1.    Mutual independence – all variables are independent from each other, denoted (A,B,C)  or A⊥⊥B⊥⊥C .<br>    2.    Joint independence – two variables are jointly independent of the third,  denoted (AB,C)  or AB⊥⊥C .<br>    3.    Marginal independence – two variables are independent while ignoring the third, e.g., θAB=1, denoted (A,B) .<br>    4.    Conditional independence – two variables are independent given the third, e.g., θAB(C=k)=1 for all k=1,2,…,K, denoted (AC,BC)  or A⊥⊥B|C .<br>    5.    Homogeneous associations – conditional (partial) odds-ratios don’t depend on the value of the third variable, denoted (AB,AC,BC) .<br>Before we look at the details, here is a summary of the relationships among these models:<br>    ▪    Mutual independence implies joint independence, i.e., all variables are independent of each other.<br>    ▪    Joint independence implies marginal independence, i.e., one variable is independent of the other two.<br>    ▪    Marginal independence does NOT imply joint independence.<br>    ▪    Marginal independence does NOT imply conditional independence.<br>    ▪    Conditional independence does NOT imply marginal independence.</p>
<p>2017.12.11<br>在回归分析图中，经常有一道红线。红线是x-y 坐标关系的非参数拟合，并不是均值。 </p>
<p>2018.1.23</p>
<h3 id="logistic回归的两种报错原因："><a href="#logistic回归的两种报错原因：" class="headerlink" title="logistic回归的两种报错原因："></a>logistic回归的两种报错原因：</h3><p><a href="http://blog.csdn.net/csqazwsxedc/article/details/52033506" target="_blank" rel="noopener">http://blog.csdn.net/csqazwsxedc/article/details/52033506</a></p>
<p>2018.1.27</p>
<h3 id="如何确定Experimental-Unit："><a href="#如何确定Experimental-Unit：" class="headerlink" title="如何确定Experimental Unit："></a>如何确定Experimental Unit：</h3><p><a href="http://www.isogenic.info/html/6__experimental_unit.html#more" target="_blank" rel="noopener">http://www.isogenic.info/html/6__experimental_unit.html#more</a></p>
<p>帮助区别了一个动物/一群动物，甚至有时候还可以在一个实验中存在多种EU</p>
<p>2018.1.29<br>今天和Bean聊天：<br>①iid个体中每一个数据点都提供了和前一个一样多的信息。而如果有相关性，比如说ρ=0.99. 那么基本上第一个数据点就代表了全部信息。后面的数据点与第一个相比都没有提供足够多的信息。<br>②当我们说到充分统计量的时候，老师说每一个x向量的Sample-Size都是n。如果我们有多个数据比如说一个做了10次，一个做了20次。如果是iid的话，我们应该把他们放到一起变成30个。这样减少方差，没必要分成两个来考虑。</p>
<p>2018.1.30<br>Fangfang：在2-sample-t-test中，两个分布可以不用都是Normal。只要他们都是对称的，或者skewed的程度差不多就可。</p>
<h1 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h1><ul>
<li>Gamma 函数不是单调递增的<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Gamma_plot.svg/650px-Gamma_plot.svg.png" alt=""></li>
<li></li>
<li>检验同方差：Bartlett’s test（采用均值和MSE。不是很robust, 最好没有outlier，很需要正态假设）, the Levene’s test（采用中位数和MAE，更robust）</li>
<li>One-way-anova中计算test-power的方式还可以用OC Curves（operating characteristic）$\Phi^2=\frac{n\delta^2}{2a\sigma^2}$其中$\delta$指的是组间最大差值:$max(t_i)-min(t_i)$</li>
<li>在计算线性回归的方差时，RSS=残差平方和/n而不是除n-1，因为原假设下残差均值为0</li>
</ul>
<p>为什么在公式 $y=\beta_0+\beta_1x$ 中，$\hat{\beta_0} \ne \bar{y}$ ?<br>答：因为首先我们知道拟合的直线肯定会经过$(\bar{x},\bar{y})$ . 所以不一定有$\bar{x} = 0$ .除非列正交，导致$\mathbb{1}_nx = 0$.</p>
<p>在所有缺失x但是不缺y的数据中，将x填成$\bar{x}$ ，只会改变拟合直线的截距而不改变斜率。 </p>
<p><img src="https://pic4.zhimg.com/80/v2-85090cf884b42c46ed50148ede175def_hd.jpg" alt=""></p>
<ul>
<li><p>one sample t-test 分母为什么是$\sqrt{n}$ ? 因为$\bar{X}$ 的方差是$\sigma^2 / n$ </p>
</li>
<li><p>Boxplot上下的线应该是1.5IQR，但是会停在1.5IQR以内最大值/最小值（所以有时候那条线可能会比1.5IQR短）</p>
</li>
<li><p>E(X1 + X2) = E(X1) + E(X2) 即使X1, X2不是独立的。因为在double integral的时候$\int X_1f(X_1, X_2) dX_1dX_2$ 会把X2积掉，从而只剩下X1的边缘分布。</p>
</li>
</ul>
<p>对于二维数据，什么时候PCA跟Linear-Regression重合？<br>因为两条线都过X_mean, Y_mean，所以只需要斜率</p>
<ul>
<li>PCA1的斜率：loading_y / loading_x</li>
<li>lm的斜率：cov(X,Y) / var(X)</li>
</ul>
<p>PCA只是Maximize Variance，如果我们想知道什么方向是最Skewness的，我们可以分解更高阶矩</p>
<p>MDS(Multidimensional Scaling)就像是把一个橘子皮撕开，张开在2维平面，而PCA不动橘子，只是改变我们观察的角度。</p>
<p><strong>实对称阵</strong>【需要对称】不同特征值的特征向量正交。</p>
<p><strong>Loh’s Bootstrap Project</strong></p>
<p>一个错误：对一个样本我想获得很多SD版本的CI，比如说我做了500次Bootstrap，我得到了一个SD，我用这个SD去套用了这500次的数据。暗含的意思是我觉得这500次数据的SD都是这个SD。但其实不是，因为SD取决于样本，而样本已经变了。正确的方法应该是，对于每一个bootstrap样本，都进行<strong>nested bootstrap来获取SD</strong></p>
<p>一个错误：计算Coverage的时候，比如我有4000个样本，获得了4000个不同的calibrated-alpha。我算了一下这4000个alpha的均值，然后再取新的4000个样本，用这个均值alpha来计算coverage。老师说不应当，应该直接用这4000个样本配合上对应的4000个不同的alpha直接计算。</p>
<p>我们不能通过R-output有几个变量带星就说明他们significant，要用bonferonni correction…</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Statistics</category>
        <category>统计学习</category>
      </categories>
  </entry>
  <entry>
    <title>聆听音乐答案(第五版)</title>
    <url>/2020/06/30/%E8%81%86%E5%90%AC%E9%9F%B3%E4%B9%90%E7%AD%94%E6%A1%88-%E7%AC%AC%E4%BA%94%E7%89%88/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>因为在网上找不到标准答案，网友的参考答案不是100%准确的，所以决定自己再做一遍，并附上自己的心得体会。这里摘录了《聆听音乐》第五版的答案部分，答案主要参考了两个网站：</p>
<ol>
<li><a href="https://book.douban.com/review/6404967/" target="_blank" rel="noopener">豆瓣网友(自由民)贡献</a></li>
<li><a href="http://college.cengage.com/site_engine/#1439083533" target="_blank" rel="noopener">出版社的官方网站</a>（题目不全，但是准）</li>
</ol>
<p>音乐部分是来自于喜马拉雅的专辑，大家可以自行搜索。</p>
<p>下面<strong>含标题的是自己做过并检查一遍的</strong>，不含标题的是直接复制黏贴，属于【没有灵魂的答案】</p>
<ul>
<li>有点忧伤…做到练习18的时候才想起来要好好记笔记…</li>
</ul>
<a id="more"></a>

<h1 id="答案部分"><a href="#答案部分" class="headerlink" title="答案部分"></a>答案部分</h1><p>1 bbacbaa bacabb bbcbbab</p>
<p>2 3/4, 2/4, 2/4, 3/4, 2/4, 3/4, 3/4, 2/4, 3/4, 2/4</p>
<p>3 ccabcacaab</p>
<p>4 大小小小大 大大小大小</p>
<p>5 1:14 1:30 1:48 1:56 2:04 2:21 2:37 2:45 2:53 3:10</p>
<p>6 16,8,8,16,16,8,8,16,16,16</p>
<p>7 ccaaa adbcb</p>
<p>8 0:09, 0:12, 0:20, 0:34, 0:39, 0:44, 0:58, 1:02, 1:09, b</p>
<h3 id="聆听练习9"><a href="#聆听练习9" class="headerlink" title="聆听练习9"></a>聆听练习9</h3><h5 id="关于音色的整理"><a href="#关于音色的整理" class="headerlink" title="关于音色的整理"></a>关于音色的整理</h5><blockquote>
<p>小号：听了想打人那种。</p>
<p>法国号：有一种金属共鸣，音域比长号高一点</p>
<p>长号：音域低一点的小号，音色脏脏的。</p>
<p>大号：最低音域的铜管。</p>
<p>大管：最低音域的木管。木管按起来会有咔咔的按键音。大管的共鸣比大号更好，有亮亮的音色。</p>
<p>长号和法国号的关系有点像单簧管和双簧管。后者音色亮一点/共鸣更好，而前者比较闷。</p>
<p>有人说单簧管声音更诡异/吓人，双簧管声音像鸭子/鹅。</p>
<p>长笛——音域宽</p>
<p>大提琴——音域不高不低，本来想选中提琴，发现没有</p>
</blockquote>
<p>【单簧管】—— 开始选了法国号，仔细一听确实沉闷，并且有按键声。</p>
<p>低音提琴——音域过低</p>
<p>双簧管——比较刺耳的木管</p>
<p>【大管】——开始选了单簧管，错在了音域/以及单簧管开始没选</p>
<p>长号 —— 铜管 &amp; 音域</p>
<p>【法国号】—— 开始选了大管/排除法选的</p>
<p>小提琴</p>
<p>大号—— 沉闷 &amp; 音色</p>
<h3 id="聆听练习10"><a href="#聆听练习10" class="headerlink" title="聆听练习10"></a>聆听练习10</h3><p>小号 小号 </p>
<p>低音提琴 单簧管 单簧管</p>
<p>大管 单簧管</p>
<p>长笛 长笛</p>
<p>法国号 长笛 长笛</p>
<p>双簧管 双簧管</p>
<p>大提琴 双簧管 双簧管</p>
<p>小提琴 中提琴 小提琴</p>
<blockquote>
<p>2 6 开始搞混了单双簧管… 感觉还是沉闷和清亮的区别</p>
<p>7 8 搞混了大中提琴 还是不知道咋区分</p>
</blockquote>
<h3 id="聆听练习11"><a href="#聆听练习11" class="headerlink" title="聆听练习11"></a>聆听练习11</h3><p>大管 长笛</p>
<p>大号 法国号 小号</p>
<p>长笛 单簧管</p>
<p>小号 长号</p>
<p>小提琴 中提琴 大提琴</p>
<blockquote>
<p>2 4 搞混了大号和长号，仔细一听还是音域的区别，2更低一点</p>
</blockquote>
<p>长笛 大管</p>
<p>长笛 大管 </p>
<p>小号 大号</p>
<p>小提琴 大提琴</p>
<p>12 单，复，单，主，单，复，复，单，复，主。</p>
<p>13 A,B,C,B,A 曲式结构为：ABCBA<br>     A,B 曲式结构为：AB<br>     A,B,A 曲式结构为：ABA<br>     A,B,A 曲式结构为：ABA<br>     A,B 曲式结构为：AB</p>
<p>14 复，圣，复，圣，复，圣，复，圣，复</p>
<p>15 0:46， 1:09， 1:33， 1:40， bbabcc</p>
<p>16 bcaca ccaab</p>
<p>17 bcaaa bcaab</p>
<h3 id="聆听练习18"><a href="#聆听练习18" class="headerlink" title="聆听练习18"></a>聆听练习18</h3><p>斯特罗齐《我想死》BBAAB BABBB</p>
<blockquote>
<p>1 应该是1765的走势</p>
<p>2 我觉得有三个，1-5-6-5 但是没这个选项，所以只好选了四个。</p>
<ul>
<li>喔！原来是中途出现了一个4</li>
</ul>
<p>5 出现了一个 17645的走势（为啥多了一拍）</p>
</blockquote>
<h3 id="聆听练习19"><a href="#聆听练习19" class="headerlink" title="聆听练习19"></a>聆听练习19</h3><p>珀塞尔《当我命丧黄泉》BAAAB DDBCB</p>
<blockquote>
<p>6 这题开始蒙了，怎么也没听出来是几遍，女声一出来确实听不见低音了。后来往上翻了翻才发现原来有固定低音的乐谱。走势应该是先从6逐个半音降到3然后一个123结束。因为前面那一通降感觉不是规律的速度，所以只听123就好了。每听到一个123，就相当于走了一遍</p>
<p>7 我认为唱了三次那一段旋律…可惜没有这个答案。固定低音部分，听到了四个123。</p>
<p>10 </p>
<ul>
<li>Bessie Smith <a href="https://www.youtube.com/watch?v=dYsGYWQT690" target="_blank" rel="noopener">《Lost Your Head Blues》</a> 没听出来有固定低音….</li>
<li>Eminem <a href="https://www.youtube.com/watch?v=eJO5HU_7_1w" target="_blank" rel="noopener">《The Real Slim Shady》</a> 走势应该是 (6)712 21 17 36</li>
</ul>
</blockquote>
<h3 id="聆听练习20"><a href="#聆听练习20" class="headerlink" title="聆听练习20"></a>聆听练习20</h3><p>维瓦尔第《春》CAABB ABCBC</p>
<h3 id="聆听练习21"><a href="#聆听练习21" class="headerlink" title="聆听练习21"></a>聆听练习21</h3><p>巴赫 《G小调管风琴赋格曲》 BAAAB CABDA</p>
<blockquote>
<p>中间主题陈述的时候有一段从小调变成大调，难以听出</p>
</blockquote>
<h3 id="聆听练习22"><a href="#聆听练习22" class="headerlink" title="聆听练习22"></a>聆听练习22</h3><p>巴赫 《醒来吧，一个声音在召唤》 BBDCA ABABD</p>
<blockquote>
<p>感觉有的部分确实加了木管？但是听不太清楚，感觉没有一个完整的声部</p>
<p>这个歌Spotify上没找到一模一样的。很多弦乐版的拖拖拉拉，根本不想醒来。</p>
<p>两个名字：Awake, a voice is calling / Sleepers, awake</p>
</blockquote>
<h3 id="聆听练习23"><a href="#聆听练习23" class="headerlink" title="聆听练习23"></a>聆听练习23</h3><p>亨德尔 《弥赛亚》“哈利路亚”合唱  BACCC CBBBD</p>
<p><strong>下一个该做这里了</strong></p>
<p>24 bcada bbaad</p>
<p>25 acbab acabc</p>
<p>26 babac acccd</p>
<p>27 cbbac abcaa</p>
<p>28 dcbbc abbab</p>
<p>29 cacab aabcb</p>
<p>30 cbbbc caabd</p>
<p>31 MBBMBMMMBB</p>
<p>32 baaaa babca</p>
<p>33 ccaaa bbaaa</p>
<p>34 aadbc abbca</p>
<p>35 abcaa cbcbb</p>
<p>36 bbdbb bcaba</p>
<p>37 caaaa bbbdd</p>
<p>38 cbbab dcaaa</p>
<p>39 ccabb cabaa</p>
<p>40 bbbab bbcbb</p>
<p>41 bbbaa cdaba</p>
<p>42 是是是否否否是否是 更多</p>
<p>43 ehbgaffdac</p>
<p>44 dabbb cbaca</p>
<p>45 caaac abbab</p>
<p>46 abbca abcab</p>
<p>47 bbaba bbaaa</p>
]]></content>
      <categories>
        <category>古典音乐</category>
        <category>聆听音乐</category>
      </categories>
  </entry>
  <entry>
    <title>郭振游门训笔记</title>
    <url>/2020/07/01/%E9%83%AD%E6%8C%AF%E6%B8%B8%E9%97%A8%E8%AE%AD%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>最近才了解到，门徒训练是灵命成长的关键一环。郭振游牧师编写了<a href="http://afcresources.org/contents/zh-cn/p3657.html" target="_blank" rel="noopener">一套门徒小组研习课程</a>。这篇笔记主要是在听他<a href="https://www.youtube.com/playlist?list=PLr2lsVlkvbYvJMh3KwAXMHEGa203H_9Iq" target="_blank" rel="noopener">CD内容</a>的时候整理出来的心得与大家分享。希望大家都能在灵命培养的路上走的更远。</p>
<blockquote>
<p>同时，如果大家觉得他的课程很有用的话，希望能够通过购买正版CD和图书支持他们的事工，谢谢。</p>
</blockquote>
<a id="more"></a>



<h1 id="第一课-做主门徒"><a href="#第一课-做主门徒" class="headerlink" title="第一课 做主门徒"></a>第一课 做主门徒</h1><h2 id="Why-为什么我们需要门徒训练"><a href="#Why-为什么我们需要门徒训练" class="headerlink" title="Why 为什么我们需要门徒训练"></a>Why 为什么我们需要门徒训练</h2><blockquote>
<p>那撒在路旁的，就是人听了道，撒旦立刻来，把撒在他心里的道夺了去。《馬可福音 4:15》</p>
</blockquote>
<ul>
<li>有时候我们自己听道之后容易忘记，是因为被撒旦夺去了。如果一个人生活中没能常常警醒，就会像抹大拉的玛丽亚一样身体上全是鬼。就这生活状态，即使讲道的人再有感动，也很难被记住。<ul>
<li>这也让我联想到，我每天的工作效率和我前一天的睡眠质量很相关。有时我也很生气自己的记忆力为何越来越差，学习效率为何越来越低？殊不知是因为没睡好。提高效率，就要从好的睡眠开始。同样的，如果想得道，那么就要从拒绝撒旦开始。</li>
</ul>
</li>
</ul>
<p>一个好的果实：能结出上百个果实。</p>
<p><strong>只是撒种的话，会带来问题：</strong></p>
<ol>
<li>属灵弃婴，只生不养。<ul>
<li>很多时候我们可能会注重在传播福音，得那些未得之地。得到之后便把他们安排进附近的教会，自己再进行新的一轮传福音。这样做带来的后果可能是【前门大，后门大】。来的人很多，得救的人很多，但是缺少了培养/成长的过程。就像刚埋下的种子不浇水很快就枯干了，所以离开的人也很多。</li>
</ul>
</li>
<li>教会侏儒：头很大，手脚很小。道听了很多，掌握了一套标准答案，但是没有活出来。</li>
</ol>
<blockquote>
<p>凡我所吩咐你们的，都教训他们遵守。我就常与你们同在，直到世界的末了。《馬太福音 28:20》</p>
</blockquote>
<ul>
<li>【世界的末了】让我想到了启示录。在那样悲惨的环境里面，如果没有主的同在，想必是很痛苦的。</li>
</ul>
<p><strong>属灵的蜜月期：</strong></p>
<ul>
<li>我相信很多人都经历过，常有神的话语，祷告很快应验。<ul>
<li>为了坚固信心</li>
</ul>
</li>
<li>久了之后为何夺去？<ul>
<li>也要碰碰钉子。不能光听道，要有一个全盘的了解。需要知道自己的不足以及如何补充。</li>
</ul>
</li>
</ul>
<h2 id="Who-选择谁来参与门徒训练"><a href="#Who-选择谁来参与门徒训练" class="headerlink" title="Who 选择谁来参与门徒训练"></a>Who 选择谁来参与门徒训练</h2><blockquote>
<p>你在许多见证人面前听见我所教训的，也要交托那忠心能教导别人的人。《提摩太後書 2:2》</p>
</blockquote>
<ul>
<li>有一个关键点是”忠心能教导别人的人“，让我想起了”爱人者，人恒爱之“。对于那些看起来有爱心/经常帮助他人的人，我们要毫不犹豫的对他们提供帮助。</li>
<li>能教导别人的人，符合了指数增长的奥秘。<ul>
<li>如果一个人<strong>每天</strong>能带领一个人信主，那么十年的话会有3650人信主</li>
<li>如果一个人<strong>每半年</strong>能带领出来一个门徒/忠心教导别人的人，十年的话会有$2^{20} = 1048576$ 人信主。</li>
<li>这也是精兵计划，通过半年的训练，出来的不会再是信仰的侏儒。</li>
<li>耶稣就是个好的例子。虽然也有登山宝训这种【布道会】，但是他花了大量气力在12门徒的身上。这12门徒后来喂养了很多人。</li>
</ul>
</li>
</ul>
<p>一个好的牧者不能只讲自己想讲的，也要看你的听众需要什么，进行合适的喂养。所以这对听众也有要求：<u>你得知道自己需要什么，并且传达给你的牧者。</u></p>
<p><strong>FAT原则：</strong></p>
<ul>
<li>F: Faithful. 他愿意将这段时间献给神，表忠心</li>
<li>A: Available. 有时间参与</li>
<li>T: Teachable. 肯受教</li>
</ul>
<h2 id="How-如何进行门徒训练"><a href="#How-如何进行门徒训练" class="headerlink" title="How 如何进行门徒训练"></a>How 如何进行门徒训练</h2><p><strong>主日学的一个问题：</strong></p>
<ul>
<li>讲得过多，并且不一定是听众所需要的。所以门徒训练的两大核心是：<ol>
<li>充分的互动，鼓励每个人都讲讲<ul>
<li>以生命影响生命。记得是你在带他，而不是材料在带她。</li>
</ul>
</li>
<li>讲自己的见证（失败的见证也可以）。<ul>
<li>会比单纯的知识更令人印象深刻，带来感动。而感动，很多时候是生命转变的开始。</li>
<li>在郭振游教授讲这里的时候，我印象深刻。随后我意识到，他其实引用了自己的见证（一对学生夫妇），他的见证就令我我印象深刻。</li>
<li>我在想，如果我无法举出自己生活中的见证，不放引用圣经中的例子。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>旧材料 -&gt; 新理解/新思路 -&gt; 新结论</p>
<ul>
<li>本科生和老总的例子：<ul>
<li>本科生经验少/材料少，所以讲的时候更填鸭，材料理解结论一起讲</li>
<li>老总经验多/材料多，所以讲的时候注重只讲理解/思路，让他们自己推导出新结论</li>
</ul>
</li>
<li>在我们鼓励大家互动的时候，对于他人的分享，我们的负担是：如何通过圣经/神的话，来给他提供一个新的视角呢？</li>
<li>这也有助于让他意识到神与他生活的关系，信仰是活泼的。</li>
</ul>
<p><strong>找教会 = 找老婆：</strong></p>
<ul>
<li>W: Worship. 教会需要有很好的崇拜，敬神。</li>
<li>I: Instruction. 注重指导，灵里的培养。</li>
<li>F: Fellowship. 团契互相有爱，互相守望（一方有难，轮流支援）</li>
<li>E: Evangelism. 传播福音，像耶稣一样【给出去】</li>
</ul>
<p><strong>门徒训练的五个目标：</strong></p>
<ol>
<li>提供一个框架，让学生自己填充。<ul>
<li>注重一个整体的感觉，一个秘诀/蓝图。打通任督二脉</li>
<li>有助于提起兴趣，自己探索的过程。<ul>
<li>引导很重要，但是如果引导的对方很气馁，也要注意引导的方向要是对方的兴趣。</li>
</ul>
</li>
</ul>
</li>
<li>以生命影响生命</li>
<li>带去聚会，不能对你过于依赖。<ul>
<li>哥多林教会的问题：”属保罗的“。这样会看不到是神在背后。他不是你的门徒，而是神的门徒。你只是在他的属灵路上陪她走一段。陪伴是手段，路才是目的。</li>
<li>如果过于依赖你，这样你一走，他的信仰就垮了。</li>
<li>不依赖某一个特定的人，有助于弟兄姊妹之间互相勉励。</li>
</ul>
</li>
<li>帮助一起灵修（防止自己灵修的时候出现【灵来灵去都是零】）</li>
<li>代代相传：劝勉他一定要好好学习，以后可以带别人进行门徒训练</li>
</ol>
<p><strong>背诵经文的目的：</strong>会在你需要他们的时候，突然在脑海中弹出来。</p>
<p><strong>如何劝说他人参与：</strong>就算是骗你，也只骗三个月啦，进行风险控制。</p>
<h2 id="实践体会"><a href="#实践体会" class="headerlink" title="实践体会"></a>实践体会</h2><p>07/01/2020</p>
<p>有小伙伴对这句经文感受很深：</p>
<blockquote>
<p>人若不常在我里面，就像枝子丢在外面枯干，人拾起来，扔在火里烧了。</p>
</blockquote>
<p>这无论是不是基督徒，只要不常在主里面，就会失去了功效，从有生命的树枝变成了无生命的柴火。</p>
<p>有一个小伙伴迟到了，不过当他代祷的时候，他真的摸到了我的需要。我不敢相信他居然准确地说出了我的想法。反而是我祷告的时候磕磕绊绊。上帝这样的安排令我羞愧，愿我有更多的爱心。</p>
]]></content>
      <categories>
        <category>Holy</category>
        <category>References</category>
        <category>郭振游门徒训练</category>
      </categories>
  </entry>
</search>
