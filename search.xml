<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo心得体会</title>
    <url>/2020/07/01/Hexo%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/</url>
    <content><![CDATA[<p>Hexo是一个博客编写的框架，这个网站就采用了这个。网上有太多的资料了，这里只列出来我在学习的时候发现的有趣点，整理下来。</p>
<a id="more"></a>

<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><blockquote>
<p>部署Hexo + GithubPages</p>
</blockquote>
<ul>
<li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">参考1</a></li>
<li><a href="https://michael728.github.io/2019/05/19/hexo-blog-full-note/" target="_blank" rel="noopener">参考2</a></li>
</ul>
<blockquote>
<p>如何只显示缩略内容？</p>
</blockquote>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">在md文件中加入<span class="xml"><span class="comment">&lt;!--more--&gt;</span></span> 即可实现手动分割。前面的内容变成了description</span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/weixin_43971764/article/details/97644190" target="_blank" rel="noopener">定义侧边栏新内容</a></p>
<h1 id="Bugs解决"><a href="#Bugs解决" class="headerlink" title="Bugs解决"></a>Bugs解决</h1><p><strong>hexo deploy 之后github上面的文件更新了，但是网页没有更新。</strong></p>
<p>最后的解决方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ rm -rf .deploy</span><br><span class="line">$$ hexo generate</span><br><span class="line">$$ hexo deploy</span><br></pre></td></tr></table></figure>



<p><strong>关于博文发布</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ hexo clean</span><br><span class="line">$$ hexo deploy -g</span><br></pre></td></tr></table></figure>



<p><strong>博文发布之后，发现和本地预览的结果不一样，总转圈，加载不出来。</strong></p>
<p>大佬说是CSS样式的问题，不过我等了一会他自己就好了。。。</p>
<p><strong>搜索引擎无法搜索到我的博客</strong></p>
<ul>
<li>Google：<a href="https://liwengo.top/2019/10/11/google-search-console/" target="_blank" rel="noopener">李子园的解决方法</a></li>
<li>百度：<a href="https://zpjiang.me/2020/01/15/let-baidu-index-github-page/" target="_blank" rel="noopener">zpjiang的解决办法</a></li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Java心得</title>
    <url>/2020/07/02/Java%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>开始学这个是因为普林斯顿的算法，第一课我看了半天，结果也没学写出来。气馁并放弃。</p>
<a id="more"></a>



<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>A sequence of instructions that solves a problem is called an <strong>algorithm</strong>.</p>
<p>A simple Java program contains:</p>
<ul>
<li>A program starts in main(), executing the statements within main’s braces { }, one at a time.</li>
<li>Each statement typically appears alone on a line, and <u>ends with a semicolon</u>, like English sentences end with a period.</li>
</ul>
<p>单行注释与一大块注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.这是单行注释，两个斜杠</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">2.这是多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这样也可以，后面的双斜杠会被忽略 //</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Java supports a third type of comment, known as a JavaDoc comment (discussed elsewhere), which is a specially formatted multi-line comment that can be converted to program documentation in HTML.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>关于输入空格使得代码美观：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yetAnotherVar = myFirstVar;        <span class="comment">// Aligned = operators</span></span><br><span class="line">thirdVar      = yetAnotherVar + <span class="number">1</span>; <span class="comment">//相关联的语句等号也要对齐</span></span><br></pre></td></tr></table></figure>

<p>如果编译器在第五行报错，那么错误肯定会发生在第五行/<u>第五行以前</u></p>
<p>Some errors create an upsettingly long list of error messages. <u>Good practice</u> is to focus on fixing <u>just the first error</u> reported by the compiler, and then re-compiling.</p>
<p><u>A logic error, also called a bug/runtime error</u>, is an error that occurs while a program runs.</p>
<p>In fact, many programmers recommend the good practice of configuring compilers to print even more warnings. For example, javac can be run as <code>javac -Xlint yourfile.java</code></p>
<p>A bit can only have the value of 0 or 1.</p>
<p>Some programmers <u>warn against using floating-point for money</u>, as in 14.53 representing 14 dollars and 53 cents, because money is a countable item</p>
<p>NaN: Not a number</p>
<p><u>public</u> indicates the method may be called from any class in the program, and <u>static</u> indicates the method only uses values that are passed to the method; </p>
<h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>A <u>Scanner</u> is a text parser that can get numbers, words, or phrases from an input source such as the keyboard. Getting input is achieved by first creating a Scanner object via the statement:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner scnr = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>System.in corresponds to <u>keyboard input</u>. Then, given Scanner object scnr, the following statement gets an input value and assigns x with that value:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = scnr.nextInt();</span><br></pre></td></tr></table></figure>

<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p><u>System.out.print</u> 正常打印. <u>System.out.println</u> (note the ln at the end, short for “line”)在打印结束之后自动开始新的一行。Outputting a blank line is achieved by: System.out.println().</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepCalm</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Keep calm"</span>);<span class="comment">// println starts new line after output</span></span><br><span class="line">      System.out.print(<span class="string">"and"</span>);       <span class="comment">// Note: Does NOT print on new output line</span></span><br><span class="line">      System.out.println(<span class="string">"carry on"</span>); <span class="comment">//字符要用双引号括起来，单引号不行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想用一个print打印多个数据，可以用加号连接(默认没有空格直接连接)。</p>
<p>可以采用“\n”来创建新的一行，但是更好的操作是 to use println to output a newline when possible, as println has some technical advantages not mentioned here.</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量类型和变量赋值可以放到同一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> abc = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><u>变量名identifier</u>:</p>
<ul>
<li>must be a sequence of letters (a-z, A-Z), underscore (_), dollar signs ($), and digits (0-9)</li>
<li>must start with a letter, underscore, or dollar sign</li>
<li>case sensitive</li>
</ul>
<p>两种命名哲学：</p>
<ol>
<li>Lower camel case，除了第一个单词之外其他的首字母大写：numApples or peopleOnBus</li>
<li>Underscore separated，用下划线连接：num_apples or people_on_bus</li>
</ol>
<p><u>A good practice</u> followed by many Java programmers is to not use _ or $ in programmer-created identifiers.</p>
<p>变量类型有: int, double, </p>
<p>定义不会更改的变量（Constant/final Variable）：A common convention, or <u>good practice</u>, is to name constant variables using upper case letters with words separated by underscores, to make constant variables clearly visible in code.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> SPEED_OF_SOUND   = <span class="number">761.207</span>;</span><br></pre></td></tr></table></figure>

<p>Because of implicit conversion, statements like </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double someDoubleVar &#x3D; 0;</span><br><span class="line">someDoubleVar &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>are allowed, but discouraged. Using 0.0 or 5.0 is preferable.</p>
<p>变量类型转换：A programmer can precede an expression with <code>(type)</code> to convert the expression’s value to the indicated type.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">avgKidsPerFamily = (<span class="keyword">double</span>)(kidsInFamily1 / kidsInFamily2)</span><br><span class="line"><span class="comment">//但是这样的问题在于没啥子用，应该把double加在两个数字中的一个，而不是加在最外面。</span></span><br></pre></td></tr></table></figure>

<p>整数类型：8-16-32-64 bits对应着byte-short-int-long<br>浮点类型：32-64 bits对应着float-double. Overflow with floating-point results in infinity.</p>
<h1 id="函数-Method"><a href="#函数-Method" class="headerlink" title="函数-Method"></a>函数-Method</h1><p>函数里面的变量在定义的时候被称为参数parameter，在调用时被称为argument</p>
<p>A method can only return one item, not two or more.<br>A void return type means the method returns no value. </p>
<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><p><strong>Math:</strong> Sqrt(x), pow(x,y), abs(x), import java.lang.Math; </p>
<h1 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h1><p>If a program needs a floating-point result from dividing two integers, then <u>at least one of the integers needs to be converted</u> to double so floating-point division is performed.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">""</span>+...) 以防止将...以数字的形式打印</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Laioffer笔记</title>
    <url>/2020/07/02/Laioffer%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参加了Laioffer 2018年底11月的Data班，整理了一下学习笔记。Laioffer学费不菲，但是提供的思路还行。像其他网课一样，我一如既往的虎头蛇尾，兴趣全无。</p>
<a id="more"></a>



<h1 id="课程问题"><a href="#课程问题" class="headerlink" title="课程问题"></a>课程问题</h1><p>课下时间：至少70%放在python coding。课下不需要看统计知识</p>
<p>机器学习：</p>
<ol>
<li>告诉老板，我们大概有5%的人要退订服务了</li>
<li>告诉老板，不知道有多少人会退订服务，但是可以告诉你为什么这些人要退订服务</li>
</ol>
<p>如果P值等于0.05：</p>
<ol>
<li>因为0.05是type1，所以可以反问为什么我们要把犯一型错误的概率定在0.05？如果很严重的话我们可以定的再小一点，如果不在乎的话可以定的大一点。</li>
</ol>
<p>MLE在什么时候不work:</p>
<ol>
<li>样本量太小会有问题。【100万人中求样本方差/样本均值，但是只有一个观测值】【均匀分布的估计】</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>问：选定模型需要理由吗？</p>
<p>答：根据不同的Assumption会有不同的模型</p>
<p>问：所有loss-function都是关于$\epsilon = y-\hat{y}$</p>
<p>答：有些模型写不出来loss-function（比如Tree-based）。但是如果能写出loss的，都是要优化xxx，就会跟error有关系。</p>
<p>问：均值和期望不同吗？</p>
<p>答：mean和expectation两者是完全不同的概念. 即使对应的数值一样，他们表达的意义是完全不同的. 简单地说, <strong>mean是针对实验样本来讨论的统计量, 是与具体数据有关的</strong>, 你的数据不同，Mean就不一样. 而<strong>expectation是对一个随机变量的数学特点的描述</strong>, 它更多表达的是在样本无穷的情况下会体现出的特点. 无论你某一次的样本数据是什么样，无论你某一次计算出来的mean多么不靠谱, 这个随机变量的expectation应该都是不变的. 但是如果你可以找到整个Population的所有情况来计算mean (这件事应该是不可能发生的), 那么它应该与expectation是一样的.</p>
<p>问：为什么线性回归的loss用平方？</p>
<p>答：直接对应线性方程<strong>噪声的高斯假设</strong> 。如果写出来似然函数然后用MLE的方法, joint pdf :<br>$$<br>f(y_1,…y_n|x_1,…x_n) = (\frac{1}{\sqrt{2\pi}\sigma})^nexp{-\frac{1}{2\sigma^2}\sum(y_i-x_i\beta)^2 }<br>$$<br>会发现最后的部分是平方损失，而MLE就是让那部分最小。</p>
<p>做题写代码之前，先想一些特殊的（test）case，让自己的code至少可以满足我们能想到的case。</p>
<p>一般的证明算法正确的方法：数学归纳法</p>
<p>问：<strong>L1 L2 loss的区别以及应用场景：</strong></p>
<p>字典的空间复杂度：key + value</p>
<p>Q: 如何解决Confounder：</p>
<p>A: 如果是regression model的话，要把可能的confounder都包含在model里；如果是two group test的话，要matching on confounder或者segment by confounder。</p>
<p><a href="https://joyeuserrance.wordpress.com/2011/04/22/proof-that-p-values-under-the-null-are-uniformly-distributed/" target="_blank" rel="noopener">P-values under the null are uniformly distributed</a></p>
<h1 id="广泛的知识"><a href="#广泛的知识" class="headerlink" title="广泛的知识"></a>广泛的知识</h1><p>机器学习的能力范围：</p>
<ul>
<li><p>给定一个x，并不能给定一个具体y【这也是为什么模型会犯错误】其实给的是y的一个分布【第一步】。然后我们再从y的分布中获得一个y的具体值【第二步】。</p>
</li>
<li><p>所以有的时候结果不好，可能模型是对的，并且已经做到了极限。是我们自己搞砸了第二步</p>
</li>
</ul>
<p>模型不能脱离与数据而存在【不能单独讨论好坏】</p>
<p>理解：考试成绩[error] = 平均水平[bias2]+某次具体发挥[var]</p>
<ul>
<li>Bias表示的是大量实验中的平均偏差[model在训练数据有稍微变化下的平均输出结果与真实值相比，得到的平均准确性]</li>
<li>Var更强调的是某一次出现的偏差[某一次model的数据结果与这个model的平均水平的差距 的平方的期望]</li>
<li>Bias和Variance是无法被计算的</li>
<li>模型越复杂，var越大。因为提取的信息不具有代表性，数据和模型之间的gap就会越来越大</li>
<li>女娲造人。先骨骼再填肉。骨骼就是model的assumption，填肉就是不同的training data. 每个靶图都是很多次不同的填肉，然后再观测眼睛的颜色。</li>
<li>Jason认为$\lambda$ 属于骨架的一部分，虽然他是个参数… </li>
</ul>
<p>我们最小化training error 是<strong>暗含了一个假设</strong>：最小化training error就是最小化testing error。但这个<strong>假设不成立</strong>，这也是过拟合的来源。我们发现过拟合的时候造成不稳的原因是var比较大，所以我们可以加一项来<strong>控制方差：Regularization</strong></p>
<p>Ridge Regression: L2-penalty    LASSO: L1-penalty<br>实际用的时候LASSO不是很稳定，作为最大缺点，二阶在工业界更常用</p>
<p>CV：</p>
<ol>
<li>可以用来hyperparameter tuning，来选$\lambda$ [grid search/ random search]</li>
<li>可以来 validate model selection 【只能选定某一种模型，而决定不了参数】</li>
</ol>
<p>Encoding 的方式：</p>
<ul>
<li>Label-Encoding 把factor变成数字 ordinal的情况</li>
<li>One-Hot-Encoding</li>
</ul>
<p>问：如何判断两个连续变量是否独立？</p>
<p>答：把连续变量离散化，根据range划分成小格子</p>
<p>问：如何判断一个连续一个离散变量是否独立？</p>
<p>答：试着去证明两个CDF是一样的。KL-divergence</p>
<p>Map-Reduce存在的问题：</p>
<ul>
<li>多个任务串联的时候，需要将中间文件写入磁盘，又得读出来。比较慢。</li>
</ul>
<h1 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h1><p>线性回归的线性到底如何定义？指数分类组？</p>
<p>问：为什么选择残差平方作为loss，为什么不是四次方？</p>
<p>答：好像跟什么高斯分布有关系？</p>
<p>问：为什么不用垂直距离做误差？</p>
<p>什么叫OA？</p>
<p>什么是Backtracking？公共课Class40讲了</p>
<h1 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h1><p>线性回归$y = ax+b$ </p>
<ol>
<li>如果给一个点，欠定方程under-determined equation</li>
<li>两个点：适定方程well-determined equation</li>
<li>多个点：<strong>超定方程over-determined equation</strong></li>
</ol>
<p><strong>五个Assumption: ？？？</strong></p>
<p>关于factor的coding有很多种，不仅有one-hot-coding.(Label encoding/<strong>target encoding</strong> 比较fancy)</p>
<p>One-hot-encoding: 保证了各个factor之间的距离都是一样的（$\sqrt{2}$）<br>    followup：等边三角形也保证了三个factor距离一样啊，并且还是二维的<br>    答案：one-hot-encoding 想要的更多的是方便interpret</p>
<pre><code>followup:出现了很多里面没有的新类别该怎么办
答案：1.新增一个other列

followup：如果有一个class有非常多的值，还可以做one-hot-encoding吗？
答案：产生原因：Feature过多的时候，overfitting（需要更多的数据）
    解决办法：1. 其他encoding（frequence-based encoding）
            2.做个聚类，重新用更小的类别数字代替原先的class</code></pre><p>问题：为什么不能直接将ABC三个班级code成为123？<br>答案：这个model基于距离的（线性模型就是）。但是概率模型（比如Tree-based）就没事</p>
<p><strong>朴素贝叶斯：</strong> 是否是花？ 给定feature (F1,…Fn) 现在要求花是哪一类？需要计算P(C|F1,…Fn) 但是这些Feature同时出现的情况可能不存在。<br>Assumption: P(Fi|C) 和 P(Fj|C)是独立的【条件独立】<br>实际例子：Fraud Activity Detection, 为了分类</p>
<p>统计中的随机性（randomness）：</p>
<ul>
<li>每一次出现都是随机的不可预测的</li>
<li>这些随机的背后<strong>存在着特定规律</strong> （所以如果一个参数属于某个参数空间，传统统计中认为就不属于随机变量）【参数不是随机变量】</li>
<li>不是所有不知道的量都是随机变量</li>
</ul>
<p>如何用random(5)[取值0,1,2,3,4]实现一个random(25)？</p>
<ul>
<li>可以把它写成一个方块，看成面积, $5X_1+X_2$</li>
<li><strong>random(7)怎么办?</strong></li>
</ul>
<p>CLT的来源背景：大量相互独立的叠加，并且<strong>每部分对在综合影响中所起的作用差不多</strong>。</p>
<p>为什么正态的误差服从正态分布？我觉得是因为好算F或者t之类的检验，Jason说有可能是因为我们认为大自然的噪声是独立同分布的，所以他们叠加是一个正态….</p>
<p>高斯假设是关于$\epsilon$ 的，或者是关于$y|x$ .</p>
<h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><p>当y是离散的时候，为什么不能用linear regression？<br>遇到的问题：</p>
<ul>
<li>y|x的分布不符合高斯分布</li>
</ul>
<p>解决办法：</p>
<ul>
<li>将y=0/1 变成0~1的概率p，再用线性拟合</li>
</ul>
<p>遇到的问题：</p>
<ul>
<li>很远的地方的数据会变成leverage point，将线拉的很扁。【可以思考赋予leverage点不同的权重】很确定的点可以小一些权重，而那些模糊区/0和1交叉点的地方需要给一些大的权重。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>变成一条折线，早早的就到了1然后一直是平的。【图形角度入手】发现logistic正好符合sigmoid形式，并且指数组也有很多好性质</li>
</ul>
<p>【从值域的角度理解】</p>
<p>开始的是离散的0和1，我们假设服从伯努利分布Ber(p)变成probability属于[0,1]，然后变成odds$\frac{p}{1-p}$ 属于[0,inf] ,然后$log(\frac{p}{1-p})$ 属于[-inf,inf] </p>
<p>多分类问题可以用</p>
<ol>
<li>one vs all</li>
<li><strong>softmax</strong></li>
</ol>
<p>局限性：仅支持一种非线性。</p>
<p>loss function，通过似然函数（joint pdf）计算出来：<br>$$<br>min\ log(p) = \sum_{i=1}^n[-y_ilog(\frac{1}{1+e^{-\beta x}})-(1-y_i)log(1- \frac{1}{1+e^{-\beta x}})]<br>$$<br>Sss</p>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>二分查找/折半搜索，针对已经排好序的序列。</p>
<p>用两个指针left和right进行操作，每次都比较mid = (left+right)/2 和目标值</p>
<p>时间复杂度log(N) 空间复杂度 constant（每次只在操作left right mid 三个指针）</p>
<ul>
<li>如果mid &lt; target, left = mid + 1</li>
<li>如果mid = target, 找到了</li>
<li>如果mid &gt; target, right = mid -1</li>
<li>如果left &gt;= right，就退出。如果left = right = target就返回left/right，如果不等于就退出。</li>
</ul>
<p>如果是多维的情况，也变成一维的情况，用两个指针来做。</p>
<p>Followup1: 寻找数列中最接近某个数值的数的index:</p>
<ul>
<li>此时，原本的 left = mid + 1/ right = mid -1 就要变成let = mid/ right = mid 因为保不齐目前这个mid虽然不是答案，但是是和答案最近的那个，所以不能轻易抛弃他</li>
<li>但是这样的话有时候会进入死循环，因为mid根本不变。所以至少保证三个数再开始跑，<strong>left &lt; right - 1</strong></li>
<li>并且需要<strong>postprocessing</strong>， 因为循环结束的时候，两个指针有可能不重合，而是距离为1，所有要对left和right再检测一遍</li>
<li>python三目运算符：<code>return left if 左小于右 else right</code></li>
</ul>
<p>Followup2: 寻找数列中最先出现某个数的index:</p>
<ul>
<li>要用followup1的判断方法: left &lt; right - 1 为什么呢？</li>
<li>如果mid &lt; target, left = mid。否则， right = mid</li>
<li>最后postprocessing, <strong>先检测left</strong>，再检测right。【反过来不行，因为我们要返回第一次出现的index】</li>
</ul>
<p>Classic判断方法：left &lt;= right. 变种：left &lt; right - 1. 判断是否可以用classic就是看循环中有没有mid = right 或者 mid = left 这种危险语句</p>
<p>Followup3: 寻找数列中最后出现某个数的index:</p>
<ul>
<li>跟2差不多</li>
<li>如果mid &gt; target, right = mid。否则， left = mid</li>
<li>最后postprocessing, <strong>先检测right</strong>，再检测left。</li>
</ul>
<p>Followup4：Search in rotated sorted array:</p>
<ul>
<li>rotated sorted array就是原本一个有序的数列，从中间砍成两半，然后调换他们的位置</li>
<li>有个好性质，那就是无论切掉几部分，剩下的拼起来还是一个rotated sorted array</li>
<li>通过left right 和mid的相对大小来确定mid左面/右面是一个sorted array</li>
</ul>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><p>线性数据结构</p>
<p>Linked List在内存中不一定是紧密相连的（不需要）</p>
<p>单链表：特点是链表的链接方向是单向的…只能访问下一位。单链表的定义还包括有头有尾，最后一个node.next = None 不会出现首尾相连的情况</p>
<p>Linked List 包含</p>
<ul>
<li>一个数据域，存放了数据</li>
<li>一个链域，存放了链表下一个地址位置</li>
</ul>
<p>刚开始创建的时候，self.next = None 因为还没有被链进链表…而在创建节点的时候肯定需要给一个val。所以init(self,val)就可以了</p>
<p>做swap的时候有时候想改变Node的val，但这样其实不符合职业操守，建议把val看成read-only</p>
<h2 id="Singly-Linked-List"><a href="#Singly-Linked-List" class="headerlink" title="Singly Linked List"></a>Singly Linked List</h2><h3 id="遍历Traverse"><a href="#遍历Traverse" class="headerlink" title="遍历Traverse"></a>遍历Traverse</h3><p>问：关于为什么这个函数要写成在class外面的free function而不写在class里面？</p>
<p>答：我的理解是因为Traverse这个功能<strong>并不是针对某一个具体的链表而设定的</strong>，所以不应该被定义在某个class的内部。定义成free function，也还可以遍历其他的链表。</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>添加元素的话一定要返回头结点head，要不然修改会找不到【如果在头前面加的话，没办法知道新的head】</p>
<p>要加fakehead，因为<strong>头结点不存在前驱节点</strong>，万一要在0位置操作的话</p>
<p>可以插入<strong>fake_head</strong>，整个代码清晰起来，因为所有节点都存在了前驱节点</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>如果删除之后将node.next = None,就会直接被Garbage collection清除掉。因为它没有被任何node指向，也没有指向任何node。</p>
<p>要加fakehead，因为<strong>头结点不存在前驱节点</strong>，万一要在0位置操作的话</p>
<h3 id="Merge-two-sorted-linked-list"><a href="#Merge-two-sorted-linked-list" class="headerlink" title="Merge two sorted linked list"></a>Merge two sorted linked list</h3><p>要添加fake_head 效果很棒</p>
<p>我开始想每次都新建一个listnode，但这样会使得空间复杂度为O(N1+N2)。所以用指针操作比较好，差距还是挺多的</p>
<p>时间复杂度O(N1+N2)；空间复杂度O(1) </p>
<h3 id="Find-middle-node-in-singly-linked-list"><a href="#Find-middle-node-in-singly-linked-list" class="headerlink" title="Find middle node in singly linked list"></a>Find middle node in singly linked list</h3><p>先问一下面试官，如果长度是2K，middle node的定义是什么？</p>
<h2 id="Doubly-linked-list"><a href="#Doubly-linked-list" class="headerlink" title="Doubly linked list"></a>Doubly linked list</h2><p>增添删除操作都是locally</p>
<p>但是还是需要fake_head 解决头结点不存在而需要特殊讨论的问题</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><code>fake_head.next = head; head.prev = fake_head</code> 注意一定要加上head.prev 这句话也要加上。并且在return之前要加上：<code>fake_head.next.prev = None; return fake_head.next</code></p>
<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><p>用<u><strong>归约</strong></u>来解决问题</p>
<p>一个小🌰：斐波那契Fibonacci Sequence：找第n位的元素</p>
<ol>
<li>建立一个list来存放所有的数据<ul>
<li>时间复杂度：O(n) 空间复杂度：O(n)</li>
</ul>
</li>
<li>用两个数字去模拟过程，a,b = b, a+b<ul>
<li>时间复杂度：O(n) 空间复杂度：O(1)</li>
</ul>
</li>
<li>Recursion：定义两个基础case F(0) = 0; F(1) = 1</li>
</ol>
<p>递归一个好处：</p>
<ul>
<li>平铺直叙，怎么想的，基本上代码就是怎么写，顺序都一样</li>
<li>有些问题用递归来写很清晰，实现起来很快</li>
<li>虽然一般来说性能可能没有直接写好，但是我们可以在实现之后再修改。</li>
</ul>
<p>Recursion 一个重要的点在于：找到<strong>Base Case</strong></p>
<p>对于递归传递参数我一直有个误区：<strong>结果传递到了哪里</strong></p>
<ul>
<li><p>其实无论是一个数还是一个数据类型，都需要准确的传递地址。一个数的话，一般在函数外先定义，然后函数内部加一行<code>global x</code> 。</p>
</li>
<li><p>如果是List的话应该不用global 因为地址是可以被查找的。</p>
<p><strong>一个有趣的错误：</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,y)</span>:</span></span><br><span class="line">        self.x += y</span><br><span class="line">        <span class="keyword">return</span> self.x</span><br><span class="line">s = Solution()</span><br><span class="line">s.add(<span class="number">3</span>) <span class="comment">#打印出来3</span></span><br><span class="line">s.add(<span class="number">5</span>) <span class="comment">#打印出来8</span></span><br></pre></td></tr></table></figure>

<p>这时候相当于用到了global变量，而global变量被存了起来。有一种解决办法是每次都重置这个global变量，但是如果频繁调用<code>s = Solution()</code> 看起来微蠢，可以写一个wrapper包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ResultWrapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max = <span class="number">-1</span></span><br><span class="line">        self.solution = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span>:</span></span><br><span class="line">    res = ResultWrapper()</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> res.solution</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>判断是否是二叉排序树：</p>
<ol>
<li>从上到下传递range</li>
<li>中序遍历 + 用一个global最大值</li>
<li>从下往上传递左右子树最大最小值 + 左右子树是不是BST</li>
</ol>
<h2 id="reverse-singly-linked-list"><a href="#reverse-singly-linked-list" class="headerlink" title="reverse singly linked list"></a>reverse singly linked list</h2><p><code>head.next.next = head</code> 这一步好强啊</p>
<p><strong>有一个重要思想</strong> 我们对于多个点的变量（比如<code>node.next.next.prev</code>），一定要看他会不会是None，如果可能会是的话，我们提前加一个判断，以及情况处理。</p>
<p>感觉这个算法厉害之处在于…recursive的部分不影响原来的head部分… 可以通过head.next 来获取<strong>recursive链表的最后一位</strong></p>
<h1 id="Non-linear-Models"><a href="#Non-linear-Models" class="headerlink" title="Non-linear Models"></a>Non-linear Models</h1><h3 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h3><ul>
<li>True Positive 这里的True指的是说的错没错。Positive指的是猜的是1还是0</li>
<li>Precision：在你说的正确里面，有多少是真正正确的。（你给出的答案，准确率是多少）</li>
<li>Recall：所有positive里面，有多少被找到了（召回了多少）。<strong>recall = 曹操</strong></li>
<li>accuracy：两种正确/四种情况</li>
<li>F1-value = precision 和 recall 的调和平均数</li>
</ul>
<p>如果是守旧的人，不希望的事情是spam folder里面有重要文件，而可以忍受spam进入邮箱。那么此时分类的时候就是重视recall而觉得precision没那么重要</p>
<h3 id="ROC-curve"><a href="#ROC-curve" class="headerlink" title="ROC curve"></a>ROC curve</h3><ul>
<li>用logistic的时候我们采用了人为的threshold。而采用这个可以直接反映数值</li>
<li>我们不想人为引入threshold</li>
<li>model不变，testing数据也不变。women画出一个随着threshold变化的准确率曲线</li>
<li>对于imbalance class也可以用</li>
<li>蓝色阴影面积决定了好坏。最差0.5（random），最好1。因为如果小于0.5的话，我们取个反就变成一个大于0.5的好分类器了</li>
<li>这个概率的解释：<strong>真实值排在错误值前面的概率</strong>（positive example is <strong>ranked</strong> more highly than a random chosen negative example）</li>
</ul>
<h3 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h3><p>以前机器学习，只能convex才可以做。现在non-convex也可以做（比如神经网络）</p>
<p>目的：使得总体混乱程度降低</p>
<p>ID3用了Entropy：$I_e = -log_2p_i$  ; $H = \sum_{i=1}^n p_iI_e$</p>
<p>C4.5用了GainRate </p>
<p>ID3倾向于对那些有很多分类的变量给更高的关注</p>
<p>CART：Gini impurity</p>
<p>为什么说决策树不是线性模型？$X_i$ 对y的影响只取决于$X_i$  的大小以及他前面的系数，与其他X都无关。但是决策树还与他的位置有关（也就是变量之间的关系也很重要spliting and priority）</p>
<p>问题：强烈过拟合。</p>
<p>解决办法：</p>
<ol>
<li>预剪枝/后剪枝（pre/post-prunning）</li>
<li>Ensemble: 好多棵树一起做 <u>Bagging</u>/boosting(有点复杂)</li>
</ol>
<h3 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h3><p>一棵树容易over-fitting</p>
<p>解决办法：向模型中加入随机性</p>
<p>有放回的抽样——保证每个元素分布一样。选取的K一般是总共feature的平方向下取整</p>
<p>一般来说不需要pruning</p>
<p>Feature importance value in Random Forest: 但从这个公式里面看不出来影响的正负<br>$$<br>Importance(i) = performance(RF) - performance(RF^{random(i)})<br>$$<br>这个performance可以是MSE/Miss classification cost(用OutOfBag的方法，而不是在添加了这个变量之后的entropy变化)</p>
<h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p>Maximize the minimum margin</p>
<p>也可以做regression，对应的loss：hinge loss</p>
<p><strong>Intuition</strong> : 希望边界直线处，分界更加清晰</p>
<p>缺点：</p>
<ul>
<li>sparse的情况没有logstic好</li>
<li>正常分类没有random forest好</li>
</ul>
<p>优点：</p>
<ul>
<li>没有维度灾难，高维上依旧work</li>
<li>数学上完备</li>
</ul>
<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>没有training stage，上来就开始test</p>
<p>也可以做regression，对最近的N个取均值，但正常一般用来classification</p>
<p>K可以被视作一个超参数，无法通过求出来</p>
<p>有个大问题：每一个预测需要O(N)的时间【计算N对距离】<br>解决办法：以空间换时间，先存好不同颜色的几个区域，local-sensitive-hashing。这是一个approximate的方法，在边界的时候容易出问题</p>
<h1 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h1><p>先用PCA，但是PCA破坏物理意义</p>
<p>目的：</p>
<ol>
<li>为了减少overfitting</li>
<li>为了找寻重要的变量，去掉useless variable</li>
</ol>
<p>有时候一个团队可能会选择解释性好而准确性差一点的模型，因为如果哪一天黑箱模型闹脾气不工作了，谁也没办法…</p>
<p>工业届还倾向于多个model来做一件事情，而不是一个model。这样可以多个team一起合作</p>
<p>一个做法：去除变量之间相关性</p>
<ul>
<li>有人用correlation</li>
</ul>
<p>Ridge 倾向于把几个相关性高的变量系数取的一样。因为在a+b= constant 的时候，$a^2+b^2$ 最小就是a = b 的情况。 </p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>协方差越大能够增加信息量，在很容易变化的一个量上面，如果我们能给出一个具体的值，那么对不确定性的影响降得会最多</p>
<p>首先保证了原信息损失最小，副产品是去除了相关性。并不是奔着去除相关性去的</p>
<p>记得要scale</p>
<h1 id="K-means-聚类"><a href="#K-means-聚类" class="headerlink" title="K-means 聚类"></a>K-means 聚类</h1><p>分类问题：原来有类别，现在新的数据，我们需要知道它是属于哪一类</p>
<p>聚类问题：原先没类别，想知道谁和谁更加接近</p>
<p>具体操作过程：不停地更换中心</p>
<p>另一种LDA（Latent Dirichlet Allocation）</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序Bubble-Sort"><a href="#冒泡排序Bubble-Sort" class="headerlink" title="冒泡排序Bubble Sort"></a>冒泡排序Bubble Sort</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fy2mq8lcomj31680kmtei.jpg" alt=""></p>
<p>从第一位开始，相邻的比较大小并交换。第一次一定会将最大的数字移到队列最后面。比较了n-1次，第二次开始要比较n-2次…以此类推</p>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<h2 id="选择排序Selection-Sort"><a href="#选择排序Selection-Sort" class="headerlink" title="选择排序Selection Sort"></a>选择排序Selection Sort</h2><ul>
<li>In-place comparison sort. 不需要额外空间/需要很少额外空间</li>
<li>It has O(n^2) 复杂度，最好最坏都一样，但是比bubble需要的swap的次数更少</li>
<li>甚至比插入排序insertion sort 还要糟糕</li>
<li>When auxiliary memory is limited, 就可以选它了</li>
</ul>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><p>把第一个数字看成一个有序数列。从第二个数字开始，每次都在有序数列中找到自己的位置并插入。一个一个插入，直到原先全部的数字都被插入到了数列中。</p>
<p>原本硬写，时间复杂度：O(n^2) 空间复杂度：O(n)</p>
<h3 id="改进1："><a href="#改进1：" class="headerlink" title="改进1："></a>改进1：</h3><p>具体code的时候，关键点在于，要提前给那个等待插入的数字<strong>预留一个位置</strong>。所以如果想不增加额外的空间复杂度的话：</p>
<ul>
<li>循环从第二位开始走，<code>cur = lst[idx]; k = idx</code> k标记了预留位置</li>
<li>进入一个while loop：每次让lst[k] 跟lst[k - 1]比，如果发现前面更小就跳出while循环</li>
<li>如果前面更大，就把k-1位置的数字移动到k位置，此时空出来的位置是k-1位，所以我们令 k = k - 1</li>
</ul>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<p>这里的时间复杂度：需要n的时间找位置，需要n的时间来做swap： (n+n) * n个数字</p>
<h3 id="改进2："><a href="#改进2：" class="headerlink" title="改进2："></a>改进2：</h3><p>用binary search找插入的位置</p>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<p>这里的时间复杂度：需要log(n)的时间找位置，需要n的时间来做swap： (n+log(n)) * n个数字</p>
<h2 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序 Quicksort"></a>快速排序 Quicksort</h2><ul>
<li>When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.</li>
<li>It is not a stable sort, meaning that the relative order of equal sort items is not preserved.</li>
<li>Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</li>
<li>On average, the algorithm takes O(n log n) comparisons to sort n items. <strong>In the worst case, it makes O(n2) comparisons</strong>, though this behavior is rare.</li>
<li>Quicksort is a divide and conquer algorithm.</li>
<li>The pivot selection and partitioning steps can be done in several different ways; <strong>the choice of specific implementation schemes greatly affects the algorithm’s performance.</strong></li>
</ul>
<p>如何选择pivot？</p>
<ul>
<li>Lomuto partition scheme：选择最后一个<ul>
<li>This scheme degrades to O(n2) when the array is already in order.</li>
</ul>
</li>
<li>用随机数，然后跟最后一位换一下。防止一直出现最差情况</li>
</ul>
<p>优势在于：inplace-sort 每次return都是None 因为不需要创建新空间</p>
<p>时间复杂度：平均/最好 是O(Nlog(N)) 最差：O(N2) 但是概率超小【每次pivot都选出极值】</p>
<p>空间复杂度：O(log(N)) 都来自于recursion 最差情况是O(N) 【概率超小】</p>
<p><strong>写代码分为三步：</strong></p>
<ol>
<li>主函数quickSort(self, alist, left, right)，接受array 传递出quicksort(self, array,0, len-1) 并且还可以用来return </li>
<li>quicksort(self, alist, left, right): 接受左右位置，从partition函数中获得pivot，递归的主函数</li>
<li>partition(self, alist, left, right)：用random.randint(left, right) 来随机产生pivot的位置，进行分类，然后传递pivot的正确位置</li>
</ol>
<h2 id="归并排序-Mergesort"><a href="#归并排序-Mergesort" class="headerlink" title="归并排序 Mergesort"></a>归并排序 Mergesort</h2><p>排序中的王者</p>
<p>核心问题在于，两个长度为N的有序数列合并，复杂度的讨论:</p>
<ul>
<li>时间复杂度O(2*N) 遍历所有元素</li>
<li>空间复杂度O(2*N) 新建了一个数列</li>
</ul>
<p>归并排序的合并过程：每一次合并操作，都涉及到n个元素的合并，所以时间复杂度和空间复杂度都是O(N)。但是总共会合并log(N)次[层数]，所以时间空间复杂度都是O(Nlog(N))</p>
<p>归并排序的拆分过程：每个数字都被跑了一遍，产生了新的长度为N的array。总共有log(N)层</p>
<p><strong>空间复杂度：O(N+log(N)) = O(N)</strong> 来自于recursion和新产生的数组</p>
<ul>
<li><p>N来自于每一层产生的新数组，至于为什么不是Nlog(N) 因为每一层新产生的空间都会被回收掉，空间复杂度指的是 在程序运行的时候 某个时刻需要的最大空间 而不是累计使用了多大的空间【因为这种情况下累积不起来】</p>
</li>
<li><p>log(N)是来自于recursion。每深入一层，就会多一个O(1) 可以理解为【找个地方来存放要运行的代码】其实是存的是地址，要知道每个递归的开始点和结束点。从哪里出来的/回到哪里</p>
</li>
</ul>
<p><strong>Linked-List 版本的sort没有任何的优势</strong> 老师说只是为了让我们练练写代码</p>
<h2 id="Bucket-Sort-Bin-Sort"><a href="#Bucket-Sort-Bin-Sort" class="headerlink" title="Bucket Sort/ Bin Sort"></a>Bucket Sort/ Bin Sort</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Bucket_sort_1.svg/320px-Bucket_sort_1.svg.png" alt=""></p>
<h1 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h1><p>进队enqueue【安Q】 出队dequeue【弟Q】</p>
<p>实际意义：排队</p>
<p>用链表比较好，因为如果用list的话，deque时间复杂度是O(N)</p>
<p>定义了一个ADT（Abstract Data Type）High-level上面带来的好处是：</p>
<ol>
<li>Seperation of Concerns: 使用者开发者不需要互相关心</li>
<li>Readability and maintainability</li>
</ol>
<p>Python有个内置的队列：deque 这个可以支持两端进两端出</p>
<h2 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h2><p>开始想只增添一个属性min 但是如果dequeue的时候把最小值删除了，就麻烦了。所以这个min可以用<strong>另外一个队列</strong>来维护。时间复杂度amortized O(1) <strong>均摊时间</strong></p>
<h1 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h1><p>入栈 push 出栈pop</p>
<p>实际意义：浏览器回退/编辑文档撤销/邮件列表最新出现在最上面/<strong>函数的调用本身</strong></p>
<p>可以直接用list</p>
<h1 id="Binary-Tree二叉树"><a href="#Binary-Tree二叉树" class="headerlink" title="Binary Tree二叉树"></a>Binary Tree二叉树</h1><p><strong>平衡二叉树Balanced</strong>： 每一个节点的左右子节点深度差 &lt;=1</p>
<p><strong>完全二叉树Complete</strong>：除了最后一层，其它层都是满的。并且最后一层是从左往右排的</p>
<p><strong>二叉搜索树Binary Search Tree</strong>：左子树都小于node，右子树都大于node，不考虑相等情况</p>
<p>递归中的BaseCase都是叶子节点的下一层：<code>If not root: return</code></p>
<p>想逐层打印的话：建一个queue每次pop出一个并且把左右节点push进去</p>
<p>发现BFS可以用stack写，DFS可以用queue写</p>
<h1 id="A-B-Testing"><a href="#A-B-Testing" class="headerlink" title="A/B Testing"></a>A/B Testing</h1><p>Quality control in the product iteration 比如说新上线一个功能想测试</p>
<h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><p>目的：快速找到极值</p>
<p>结构：Complete Binary Tree 分为min/maxheap</p>
<p>创建一个heap：从头元素开始不停地sift up（O(Nlog(N))）。Sift up 能保证前面一直是一个heap，sift down只能保证后面一直是heap，所以可以从最后一个开始不停的sift down(O(N))。</p>
<ul>
<li>时间复杂度小了很多，因为最后一层原来贡献了$\frac{N}{2}logN$ , 它们现在只贡献了0</li>
<li>并且实际操作的话，可以忽略最后一行，从最后一个有孩子的开始sift down. </li>
</ul>
<p>Pop的时候先交换array的最前最后，在那个大元素下降的时候，必须要跟左右孩子中较小的那个换，如果跟那个较大的换，会导致root比孩子数值大的问题</p>
<h1 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h1><p>时间复杂度最多是4logN 不能cover连续的四个Node</p>
<h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><strong>正常存法</strong>：是用list分别存储顶点和连线，缺点：</p>
<ul>
<li>一个很简单的问题都回答不了：给定两个定点A, B。是否存在一条路径连接他们呢？</li>
</ul>
<p><strong>Adjacency Matrix</strong>: 用一个n*n的矩阵存储边的信息，如果直接相连即为1。缺点：</p>
<ul>
<li>如果是个Sparse矩阵的话，浪费空间</li>
<li>添加一个新顶点会变得很难</li>
</ul>
<p>优点：</p>
<ul>
<li>可以自己乘自己，获得是否存在长度为K的路径（以及几条）</li>
</ul>
<p><strong>Adjacency List</strong>: 用字典来存储，每个节点是一个key，每一个与该节点相邻的节点是value。优点：</p>
<ul>
<li>我们不会为那些不存在的边浪费存储空间</li>
<li>查询一条边是否存在很快速</li>
<li>添加一条边也很简单</li>
</ul>
<p><strong>一些常见的问题</strong>：</p>
<ol>
<li>给定两点，是否存在通路？</li>
<li>给定一点，找到所有可达点以及所有邻边</li>
<li>给定一幅图，遍历所有点</li>
</ol>
<h3 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h3><p><strong>BFS遍历</strong>：Gab的例子：找眼镜，一点点摸</p>
<p>对于一个给定的节点，先遍历所有距离为1的节点，再遍历对所有新节点来说距离为1的节点。</p>
<ul>
<li>Time Complexity: 对于所有节点V，我们入栈一次出栈一次，并且我们遍历一次他们的邻边。O(V+E)</li>
</ul>
<p>可以用来找最短路径</p>
<p><strong>DFS遍历</strong>：Gab举了个例子：走迷宫。</p>
<p>通过递归来实现，从过一个点出发，算所有能从这个点走到的点。</p>
<p>可以找到所有连通分量</p>
<p><strong>状态</strong>：</p>
<p>对于有向图，有四种边的类型：Tree/Forward/Backward/Cross edge</p>
<p>对于无向图，有两种边的类型：Tree/Backward edge</p>
<p>所以在编程的时候我们要对每种情况进行分类讨论，是一个很便捷的思路。</p>
<p>无向图寻找环：找是否有Backward Edge。注意要记录一个父亲</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Courses</category>
        <category>Laioffer</category>
      </categories>
  </entry>
  <entry>
    <title>Latex心得</title>
    <url>/2020/07/02/Latex%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>老罗曾说Latex Book 和 S Book 是他看过写的最好的两本书。那我得跟上啊！</p>
<a id="more"></a>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>\docunmentclass{book/report/letter/article} 确定文件类型</li>
<li>\begin{document}文章开始</li>
<li>\end{document} 文章结束</li>
<li>\title{} 添加题目</li>
<li>\author{}添加作者</li>
<li>\maketitle 制作封面-如果不在begin{document}后面加这句话，其他话都白写了</li>
<li>\tableofcontents 加入目录，包括页码</li>
<li>层次结构：part-chapter-section-subsection 用法: \part{}</li>
<li>无序列表：\begin{itemize}  换行\item ***  换行\end{itemize}</li>
<li>自定义列表：将itemize变成enumerate。默认是数字，可以加其他宏包</li>
<li>输入一些\alpha这种特殊字符要在句子前后各加一个$</li>
<li>一般字符需要用\来转义：{, }, %, $, &amp;,#, ~, ^, _ 但是反斜杠需要用\textbackslash</li>
</ul>
<p>换行 \\</p>
<ul>
<li><a href="https://www.latex-tutorial.com/tutorials/figures/" target="_blank" rel="noopener">添加图片</a> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;enumerate&#125; </span><br><span class="line">\item 带编号的列表</span><br><span class="line">\end&#123;enumerate&#125; </span><br><span class="line"></span><br><span class="line">\begin&#123;itemize&#125; </span><br><span class="line">\item 不带编号的列表</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure>








<p>##环境：</p>
<p>  \begin{环境名}[可选参数]{参数}。document可以被看成最大的环境。</p>
<p>常用环境：</p>
<ul>
<li>居中：center</li>
<li>左对齐/右对齐：flushleft/flushright</li>
<li>verbatim：抄录环境内的字符，忽视tex命令。verbatim* 将空格以␣␣的形式标注出来。行内抄录\verb+内容+和\verb*+内容+</li>
<li>定理类环境：<br>\newtheorem{Theorem}{ 定 理 }[section]<br>\newtheorem{Proposition}[Theorem]{命题}<br>\newtheorem{Lemma}[Theorem]{引理}<br>\newtheorem{Definition}[Theorem]{定义}<br>最后加上：<br>\begin{Theorem} \label{thm:math}<br>定理内容。<br>\end{Theorem}</li>
</ul>
<h2 id="间距："><a href="#间距：" class="headerlink" title="间距："></a>间距：</h2><ul>
<li>.\\表示一行的结束 相当于换行符</li>
<li>\hskip(vskip) 长度 或 \hspace{长度} 或 hspace*{长度}</li>
<li>长度单位sp&lt;&lt;pt&lt;=bp&lt;mm&lt;cm&lt;in 还有em表示字母m的宽度，ex表示字母x的高度</li>
<li>不可换行的水平间距：\enspace =0.5em   , =1/6em    \!=-1/6em  ~=空格</li>
<li>可换行的水平间距：\quad=1em  \qquad=2em  \enskip=0.5em \空格=空格 </li>
</ul>
<h2 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h2><ul>
<li>\section{} \subsection … 可以在中括号前面加个星号，避免自动标号</li>
</ul>
<h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><ul>
<li>行内公式用$…$连接</li>
<li>行间公式：\[…\] 连接 \mbox添加有空格的文字。\mathrm添加没空格的文字</li>
<li>为数字a戴上帽子：hat{a}或者hat a 其他符号：\tilde波浪线，\bar一条横线，\vec向量</li>
<li>三种矩阵：中括号bmatrix，圆括号pmatrix，竖线vmatrix。行间公式—\begin{bmatrix}—a_ {1,1}&amp;\dots&amp;a_ {1,n}\\</li>
<li>带编号的表达式：\begin{equation}\label{eq:ex1}</li>
<li>不带编号的多行表达式：\begin{eqnarray*}  都是用\\换行</li>
<li>带编号多行表达式：\begin{eqnarray} 没有标号的行用\nonumber \\换行 最后一行\label{eq:a2}</li>
<li>大算子号：迭代指标写在求和号上下的情况用行间公式括起来。迭代指标写在求和号右侧的用行间公式连接起来。如$\sum_{i=1}^n a_i^2$</li>
<li>其他大算子：连乘\prod 积分\int 环路积分\oint 交集\bigcap 并集\bigcup</li>
<li>圆括号和大括号大小：\Bigg( &gt;bigg &gt;Big &gt;big&gt;什么都不加就是一个(</li>
<li>像分段函数之类的东西，要用\left\{\begin{array}{ll} 配合 \right</li>
<li>不等号 \not=  或者 \ne </li>
<li>元素不属于\not\in 集合不属于 \not\subset</li>
<li>不小于等于 \not\le  不大于等于\not\ge</li>
<li>^上标 _下标</li>
<li>\stackrel{i.i.d}{\sim}  波浪线上添加iid</li>
<li>偏导数用frac + \partial</li>
<li>正比于 \propto</li>
<li>hat如果不够大的话还有widehat reallywidehat….</li>
<li>二项式系数：\binom 或者直接 C_3^2</li>
</ul>
<h2 id="字体与字号："><a href="#字体与字号：" class="headerlink" title="字体与字号："></a>字体与字号：</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>影响字形的参数有：fontencoding-fontfamily-fontseries-fontshape 用花括号括起来</p>
<p>常用的有:</p>
<ul>
<li>缺省\rmfamily  打印机字体\ttfamily 无衬线字体\sffamily</li>
<li>缺省\mdseries 粗体\bfseries</li>
<li>缺省\upshape 意大利体\itshape 斜体\slshape 小号大写字体\scshape</li>
</ul>
<p>还可以通过{\fontspec{Times New Roman} 文本}来特定某一种字体</p>
<p>还可以通过\textbf \textsf \textit{文本}…的方式</p>
<p>\mathcal{花体字} 、mathbb{实数集R}</p>
<h3 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h3><p>格式：{\tiny 文本}</p>
<p>从小到大：tiny-footnotesize-small-normalsize-large-Large-LARGE-huge=Huge</p>
<ul>
<li>还可以固定宽度高度{\fontsize{120}{160} \selectfont 文本}</li>
<li>不过一般来说，TEX文件正文中不需要设置字体/字号</li>
</ul>
<h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><p>\begin{tabular}[pos]{table spec}<br>…<br>\end{tabular}</p>
<ul>
<li>table spec定义了表格的格式:| l | c | rcl | 竖线就是竖线，lrc分别是左/右对齐和居中，还可以用p{width}来创建一个段落单元格</li>
<li>tabular环境中，用&amp;分隔列，\\开始新的一行</li>
<li>\hline 添加一个水平线 \cline{i-j}添加一个第i列到第j列的水平线</li>
</ul>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul>
<li>alt+delete 迅速删除一行t</li>
</ul>
<h1 id="犯过的错误"><a href="#犯过的错误" class="headerlink" title="犯过的错误"></a>犯过的错误</h1><p>使用\\来进行换行操作的时候报错，解决方法：<a href="https://tex.stackexchange.com/questions/4690/error-message-theres-no-line-here-to-end" target="_blank" rel="noopener">https://tex.stackexchange.com/questions/4690/error-message-theres-no-line-here-to-end</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~\\ 使用它来代替 \\</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>Linux心得</title>
    <url>/2020/07/02/Linux%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>学679的时候记录的学习笔记。后来我将Mac的一些操作也加了进去。</p>
<a id="more"></a>



<h1 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h1><p>cd /workspace 前面那个slash目的是回到主界面在进入workspace 而不是进入当前目录下的workspace<br>rm -rf 直接删除所有类型的文件<br>ssh <a href="mailto:siyuw@lunchbox.stat.wisc.edu">siyuw@lunchbox.stat.wisc.edu</a><br>ls -l: ①文件夹d其他-②read③write④是否可执行 可执行x ⑨最后三个说的是其他人<br>ls -lt 按修改时间倒序排列<br>cat语句可以连接两个文件<br>clear:清屏<br>shuf —-help 可以从一个文件随机选出几行</p>
<ul>
<li>但是MAC没有shuf，只能用gshuf，还得安装一下<code>brew install coreutils</code></li>
</ul>
<p>tail -n +2 “$FILE” &gt; “$FILE.tmp” &amp;&amp; mv “$FILE.tmp” “$FILE” 可以删除文本文件第一行<br>cat 1.txt 2.txt &gt; 3.txt 可以把1.2文件行combine到3文件中<br>wc -l &lt; <filename> 返回文件有多少行</p>
<p>sed ‘2,$d’ ab           #删除第二行到最后一行</p>
<p>python -V #查看python的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wc -l &#96;find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -type f&#96; #print一个文件夹下所有文件的行数</span><br></pre></td></tr></table></figure>

<h1 id="犯过的错误"><a href="#犯过的错误" class="headerlink" title="犯过的错误"></a>犯过的错误</h1><p>bash没保存 反复运行发现没什么变化，以为电脑坏了</p>
<p><strong>Slurm 装R包</strong>：</p>
<ul>
<li>module load R 才可以把R的版本换成3.5</li>
<li>装R的时候需要带上dependencies = TRUE</li>
</ul>
<p><strong>Slurm报错</strong>：slurmstepd: error: Exceeded step memory limit at some point.</p>
<ul>
<li>#SBATCH –mem-per-cpu=10gb </li>
</ul>
<p><a href="https://blog.csdn.net/weiguang1017/article/details/80345058" target="_blank" rel="noopener">mac下插入文件到某一行</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>不要在一个终端窗口里使用 Ctrl-c 和 Ctrl-v 快捷键来执行拷贝和粘贴操作。它们不 起作用。对于 shell 来说，这两个控制代码有着不同的含义，它们在早于 Microsoft Windows （定义复制粘贴的含义）许多年之前就赋予了不同的意义。</p>
<h1 id="一些简单命令"><a href="#一些简单命令" class="headerlink" title="一些简单命令"></a>一些简单命令</h1><p>date 显示时间</p>
<p>cal 显示日历</p>
<p>查看磁盘剩余空间的数量，输入 df</p>
<p>显示空闲内存的数量，输入命令 free。</p>
<p>退出 exit</p>
<p>mv 重命名/剪切  rm删除</p>
<p>如何获取ubuntu管理员权限？<br>①sudo passwd root  （创建root的密码）<br>②su命令进入管理员权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wc -l &lt; file.txt <span class="comment">#可以不显示文件名直接显示行数</span></span><br></pre></td></tr></table></figure>

<p>=~ 来匹配正则式</p>
<p>下载Kaggle数据需要权限：传递cookie <a href="https://wdeback.gitlab.io/post/2018-03-08-how-to-download-kaggle-dataset-from-command-line/" target="_blank" rel="noopener">https://wdeback.gitlab.io/post/2018-03-08-how-to-download-kaggle-dataset-from-command-line/</a></p>
<p><strong>Linux下，删除大于固定大小的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -size +50M1</span><br></pre></td></tr></table></figure>

<p>显示当前路径下，大于50M的文件。（包含子文件夹内的文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -size +50M -exec rm &#123;&#125; \;1</span><br></pre></td></tr></table></figure>

<p>删除当前路径下，大于50M的文件。（包含子文件夹内的文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find shakespeare -type f -exec cat &#123;&#125; \; &gt; file</span><br></pre></td></tr></table></figure>

<p>找到所有文件并把他们合在一起</p>
<p>M-x erase-buffer 删除所有内容</p>
<p>Counting Files in the Current Directory: <code>ls -l | wc -l</code></p>
<p><a href="https://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_02.html" target="_blank" rel="noopener">ARRAY 操作</a></p>
<h1 id="一些操作上的快捷键"><a href="#一些操作上的快捷键" class="headerlink" title="一些操作上的快捷键"></a>一些操作上的快捷键</h1><p>C-L 可以将命令行移动到屏幕的上/中/下</p>
<h1 id="HTCondor"><a href="#HTCondor" class="headerlink" title="HTCondor"></a>HTCondor</h1><p>proc=$$([$(Process)+3586]) 来调节命令序号</p>
<h1 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h1><p>操作指南：<a href="https://slurm.schedmd.com/sbatch.html" target="_blank" rel="noopener">https://slurm.schedmd.com/sbatch.html</a></p>
<h1 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h1><p>新建窗口 emacs -nw</p>
<p>退出 C-x C-c</p>
<p>查找文件：C-x C-f</p>
<p>删除一行 C-k</p>
<p>删除当前C-d</p>
<p>拷贝 M-w</p>
<p>去掉一些空白换行符 tab</p>
<p>去掉一些空白区域 M-p</p>
<p>自动合并段落 M-q</p>
<p>list buffers: C-x C-b </p>
<ul>
<li>按space进入选中的buffer </li>
<li>在bufferlist里面关掉buffer 直接用 k 选中多个 然后enter来删除</li>
</ul>
<p>唤起shell : M-x shell / C-z</p>
<p>删掉输入一般的错误/不想要命令</p>
<p>撤销：C-/</p>
<p>字体： C-_ 缩小    C-shift-+ 放大    C-0 回到原来样子</p>
<p>C-x d 进入文件管理界面</p>
<ul>
<li>按+可以创建新文件夹 </li>
<li>按d可以添加删除标记最后按x执行删除命令 </li>
<li>g刷新</li>
<li>u取消标记</li>
<li><a href="http://lifegoo.pluskid.org/wiki/EmacsAsFileManger.html" target="_blank" rel="noopener">http://lifegoo.pluskid.org/wiki/EmacsAsFileManger.html</a> 里面提到了很多dired的操作</li>
<li><a href="http://www.cnblogs.com/beanmoon/archive/2012/09/22/2697723.html里面提到了很多dired的操作" target="_blank" rel="noopener">http://www.cnblogs.com/beanmoon/archive/2012/09/22/2697723.html里面提到了很多dired的操作</a></li>
</ul>
<p>M-p 重复上一命令</p>
<p>M-x replace-string C-q C-j 可以插入回车</p>
<p>C-v 向下翻页 M-v 向上翻页</p>
<h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>跑R程序可以直接 Rscript xxx.R</p>
<h2 id="学校CHTC介绍"><a href="#学校CHTC介绍" class="headerlink" title="学校CHTC介绍"></a>学校CHTC介绍</h2><p>HTC(高吞吐量计算)与HPC(高性能计算)：</p>
<ol>
<li>HTC分成的若干个部分之间不需要交流信息，而HPC需要</li>
<li>HTC更感兴趣的是可以在很长一段时间内完成多少工作而不是多快。</li>
</ol>
<p>比学校CHTC更大&amp;更不灵活的是UW Grid/ Open Science Grid</p>
<p>可以跑R, Python, Matlab, …</p>
<p>学校用的分布系统是HTCondor</p>
<p>以后如果有自己的项目要申请CHTC，<a href="http://chtc.cs.wisc.edu/form" target="_blank" rel="noopener">http://chtc.cs.wisc.edu/form</a></p>
<p><strong>Submit&amp;Monitor the job</strong>: condor_submit job.sub condor_q 但是这个命令在lunchbox里面跑不了，因为lunchbox用的是sbatch那一套 </p>
<h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h1><p>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。</p>
<p>许多 Linux 发行版默认保存最后输入的 500 个命令。（使用向上箭头）</p>
<p>鼠标左键拖动 = 复制文本</p>
<p>传统 X 行为是指只要把鼠标移动到一个窗口的上方。 它能接受输入，但是直到你单击窗口之前它都不会成为前端窗口。设置聚焦策略为“聚焦跟随着鼠标”，可以使拷贝和粘贴更方便易用。 你能在窗口管理器的配置程序中找到这个设置。</p>
<h1 id="文件系统中跳转"><a href="#文件系统中跳转" class="headerlink" title="文件系统中跳转"></a>文件系统中跳转</h1><p>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录（/home）。每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户对文件进行写入的地方。</p>
<p>相对路径用一个点[.]或者两个点[..]</p>
<p>cd .. 表示返回上一层</p>
<p>cd ./xxx 表示进入下一层 当然 [./] 可以被省略</p>
<p>直接 cd 会回到家目录</p>
<p>cd - 更改工作目录到先前的工作目录。【类似于返回上一步】</p>
<p>cd ~user_name 可以回到其他用户的家目录</p>
<p>ls 无法列出被隐藏的文件（例如用[.]开始的文件）此时可以使用 ls -a 命令</p>
<p>文件名和命令名是大小写敏感的</p>
<p>Linux 没有“文件扩展名”的概念，文件内容或用途由其它方法来决定。</p>
<p>虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用“.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与词间的空格，用<strong>下划线字符来代替</strong>。过些时候，你会感激自己这样做。</p>
<p>Emacs中要达到撤销效果使用的是 C-/ ，同样还可以使用 C-_ 或者 C-x u ，这三个都对应的是Undo命令。</p>
<p>上面说的是撤销文本上的操作，还有个比较常用的命令C-g ，这个是用来撤销命令的，当你输了一半命令发现不对就可以用它了。</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Matlab心得</title>
    <url>/2020/07/02/Matlab%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在做ME599的时候学习了下。不同语言的Bug还是难de。</p>
<a id="more"></a>



<h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><ul>
<li>读入文件：load</li>
<li>numel(A) = prod(size(A)) 返回A中元素个数</li>
</ul>
<p>pathtool 添加路径</p>
<p>运行一行代码 ❎ 只能运行选中代码，然后Fn+Shift+F7<br>注释用百分号% 代替#<br>「1<del>=2」表示1不等于2 用</del>代替叹号<br>或者|| 和&amp;&amp; 异或xor()<br>a=pi在后面加一个;冒号可以抑制打印<br>disp(sprintf(‘6 decimals: %0.6f’,a)) %结果为 ‘6 decimals: 3.141593’<br>format short/long 可以在打印东西之前写出来 改变打印的位数</p>
<p>矩阵生成</p>
<ul>
<li>用中括号括起来，用分号按行输入</li>
<li>ones(m,n) 生成一个m*n的矩阵，元素全为1.  zeros同理</li>
<li>eye(n)  生成n维单位矩阵</li>
</ul>
<p>rand()生成0-1均匀分布的随机数，可以用rand(m,n)来生成随机矩阵<br>randn() 生成标准正态</p>
<p>clc清屏<br>a=出发数字：步长：结束数字——生成一个向量，步长默认是1<br>hist(w,方格数)生成密度图像<br>size返回矩阵的维数 size(a,1|2)返回第一个或第二个维数<br>length给出一个矩阵最长的维数，所以对一个向量可以直接返回它的长度<br>who 可以显示当前所有变量 whos更详细  clear可以清除一个变量 什么都不加的clear全部清除<br>选择一个向量的前十位：v=priceY(1:10)<br>save hello.mat v: 把数据v存为hello.mat文件<br>a([1 3],:) 矩阵第一行和第三行所有元素<br>A=[A,[1;2;3]]：矩阵A右侧加上一列123<br>A(:)将A元素变成一个列向量输出<br>b1=[a:a]  b2=[a a]/[a,a] b1是上下合并 b2是左右合并<br>a.*b 是把两个矩阵对应位置的数字乘起来作为新元素，所以a和b应该是一样大小的<br>·点其实代表着element-wise operation；所以 v=[1,2,3]   1./v  %1 0.5 0.33</p>
<p>max()返回最大值，</p>
<ul>
<li>可是如果[v,c]=max(a) 那么v是最大值，c是最大值的index</li>
<li>如果对矩阵作用max，会返回每一列的最大值</li>
</ul>
<p>find(a&lt;3) 返回a向量中小于3的index<br>magic(n) 生成一个n阶的矩阵，行和列和对角线和都相同（但是对于每个n只有一种形式）<br>提取矩阵元素的时候，如果只用一个数字，那么默认是按照列来数<br>prod() 连乘<br>floor&amp;ceil地板和天花板函数<br>max(a,[],1|2) 按列|行来取矩阵a的最大值<br>sum(a,1|2) 按列|行进行求和<br>取整个矩阵的最大值：max(max(A))或者max(A(:))</p>
<p>可以用逗号连接命令或者函数调用，会逐个运行。用冒号连接则不会显示结果</p>
<p>循环：for i = 1:10, v(i)=2^i; end. while和if也要和end连用。if也没有括号</p>
<p>exit和quit都可以退出octave</p>
<p>addpath()添加新路径</p>
<ul>
<li>取出向量的第五位到最后一位：A(5:end) 注意这个end</li>
</ul>
<ul>
<li>rng(512) 等同于R里面的set.seed(512)</li>
<li>normrnd = rnorm 不过可以直接在后面加上维数，生成众多随机数</li>
<li><a href="https://cn.mathworks.com/help/matlab/ref/table.html" target="_blank" rel="noopener">创建一个表格</a>：T = table(Age,Height,Weight,BloodPressure,…    ‘RowNames’,LastName) </li>
<li>fminunc 返回函数最小值（维数大于等于2）</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>遍历一个未知大小的矩阵/向量：for i = 1:numel(z)</li>
</ul>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ul>
<li>a(2,:)=[] 删除某一行/列</li>
<li>reshape(data,nrow,ncol) 变形矩阵</li>
<li>a(: , k:end) end代表最后</li>
<li>a=sum(A) %列求和<br>b=sum(A,2) %行求和<br>c=sum(A(:)) %矩阵求和</li>
<li></li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>f = @(x) 2 * x ^ 2 + x; 创建symbolic function</p>
<p>intlinprog - Mixed-integer linear programming (MILP) 混合整数线性规划问题</p>
<h1 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h1><ul>
<li>figure; open a new figure window</li>
<li>flipud(a) 将矩阵a上下翻转</li>
<li>hold on 可以让当前的图留住，将下一幅图继续画在上面。 </li>
<li>xlabel(‘name’)</li>
<li>plot(x,y,’r’)红色</li>
<li>legend(‘1’’2’)加图例</li>
<li>title(‘标题’)</li>
<li>print -dpng ‘name.png’</li>
<li>figure(1);plot();figure(2);plot() 可以同时分别画出来两张图</li>
<li>subplot(1,2,1);plot() 将图像空间分成1*2，现在去画第一个</li>
<li>axis([横坐标最小值 横坐标最大值 纵坐标最小值 纵坐标最大值])</li>
<li>clf清除所有图</li>
<li>imagesc(a) 将矩阵a用颜色画出来</li>
<li>colorbar 在右侧添上一个颜色条</li>
<li>colormap gray将图变成灰色</li>
</ul>
<h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><ul>
<li>ctrl+c : 终止当前程序</li>
</ul>
<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><ul>
<li>SVM: liblinear/libsvm</li>
</ul>
<h1 id="文档发布"><a href="#文档发布" class="headerlink" title="文档发布"></a>文档发布</h1><p><a href="https://cn.mathworks.com/help/matlab/matlab_prog/marking-up-matlab-comments-for-publishing.html" target="_blank" rel="noopener">官方帮助</a></p>
<ul>
<li></li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Matlab</category>
      </categories>
  </entry>
  <entry>
    <title>Python心得</title>
    <url>/2020/07/02/Python%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用力学。</p>
<a id="more"></a>



<p>未解决的问题</p>
<p>什么是eval？</p>
<h1 id="犯过的错误"><a href="#犯过的错误" class="headerlink" title="犯过的错误"></a>犯过的错误</h1><ul>
<li><p>A little important thing to be cautious:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums[:] &#x3D; nums[n-k:] + nums[:n-k]</span><br></pre></td></tr></table></figure>

<p>can’t be written as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; nums[n-k:] + nums[:n-k]</span><br></pre></td></tr></table></figure>

<p>on the OJ.</p>
<p>The previous one can truly change the value of <strong>old</strong> <em>nums</em>, but the following one just changes its reference to a <strong>new</strong> <em>nums</em> not the value of <strong>old</strong> <em>nums</em>.</p>
</li>
<li><p>在数二进制有多少个1的时候用sum巨慢无比，bin(num)[2:].count(‘1’)是一个更好的选择？</p>
<ul>
<li>不是吧…如果用 &amp; 的话应该会更快？</li>
</ul>
</li>
<li><p>对于123456这种连续的改变，只记录1和7然后用cumulative的方式再变回去会快很多</p>
</li>
<li><p>要是对array是否为none做sanity check当然更好。注意这个叫sanity check</p>
</li>
</ul>
<p><strong>== 和 is 的区别：</strong> 前面是判断等价关系。后面的is是判断identity，也就是两个内存单元的判断。所以有时候对于class的类别，因为没有默认的等价关系，所以都会默认区比较内存单元，会出现这样的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = ListNode(<span class="number">1</span>), ListNode(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> a == b <span class="comment">#会返回False，需要class里面 def __eq__(self, other)</span></span><br><span class="line"><span class="comment">#定义了eq就需要再定义两个事情：def __ne__(self, other); def __hash__(self) 哈希值</span></span><br></pre></td></tr></table></figure>

<p>一般答案的输出集合：Res = [] result的意思</p>
<p>一个已经被decode了的字符s不具有属性s.decode</p>
<p>两个字符串相加，时间复杂度是O(N) 因为后面那个字符需要一个一个添加进去</p>
<p>输入与<strong>输出</strong>并不算在空间复杂度之中（输出也不算）。</p>
<p>计算递归的复杂度，可以画树状图的方式。关于空间复杂度，不是每一层占用的空间，因为函数调用串行执行，一路走到底才会走到其他分支。所以每一层其实只占用一份的空间，其他要不然已经被释放了，要不然还没走到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#有的时候我会用两个stack倒来倒去，就像这样：</span></span><br><span class="line">stack1, stack2 = [root], []</span><br><span class="line"><span class="keyword">while</span> stack1:</span><br><span class="line">    <span class="keyword">while</span> stack1:</span><br><span class="line">        r = stack1.pop()</span><br><span class="line">        ....</span><br><span class="line">        stack2.append(...)</span><br><span class="line">    stack1, stack2 = stack2, stack1</span><br><span class="line"><span class="comment">#今天看到一个老哥的代码：</span></span><br><span class="line">q = collections.deque([root])</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">    r = q.popleft()</span><br><span class="line">    q.append(....) <span class="comment">#感觉更简洁，并且时间复杂度一样</span></span><br></pre></td></tr></table></figure>



<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul>
<li>Python 变量命名规则<ul>
<li>以下划线/字母开始</li>
<li>字母+数字+下划线 来命名</li>
<li>大小写敏感</li>
<li>存在一些保留字符，如果强行赋值的话会报错，但是有些语言就会同意你来重新赋值</li>
</ul>
</li>
<li>Python 2.7里面做的是整数除法【不是四舍五入而是向下取整】但是python3里面是浮点除法<ul>
<li>提示：<code>print 1.0 * 5250/1000</code> 和 <code>print 5250/1000 * 1.0</code> 答案不同</li>
</ul>
</li>
<li>变量类别：<ul>
<li>None 就是NA的意思</li>
<li>很大的整数是long类型的(2**63左右)</li>
<li>float(‘inf’) 和 float(‘-inf’) 表示无穷【大小写无所谓】</li>
</ul>
</li>
<li>raw_input(‘Some Instructions…’) 用户可以输入，默认是字符串。<ul>
<li>如果用input的话，会evaluate式子。比如<code>a = input(&#39;...&#39;); 1+1</code> 【a被传递了2】</li>
<li>默认是一行，如果多行的话需要加while然后逐行输入</li>
</ul>
</li>
<li>语句块不一定都是一个tab也可以是一个空格，只要大家的缩进都相同。【缩进都缩回去了，所以不需要end】良好的coding习惯可以在代码块的下面空一行</li>
<li>三个单/双引号可以注释代码块，在赋值中也是为了在里面输入单引号&amp;双引号</li>
<li>任何非0和非None都会被evaluate成True。只有【0和None】会被evaluate成False</li>
<li>If 0 &lt; 1 : print ‘能运行 ‘ 但是不推荐</li>
<li>逻辑比较：not &gt; and &gt; or 【这个啥意思】</li>
<li>在文件开头加入 # -*- coding: UTF-8 -*- 或者 #coding=utf-8 就可以让python以utf-8进行编码【默认是ASCII】</li>
<li>range只能产生整数序列，numpy.arrange可以产生float数列</li>
<li>python当print的东西是None的时候，返回的不是空白，而是四个英文字母：None</li>
<li>Python is a PASS-BY-OBJECT-REFERENCE programming language<ul>
<li>存储分为stack和heap。stack存放的是reference(变量名)。重新赋值(x = [1])的时候stack里面的reference不变，但是指向了heap（存储了object）里面的一个新的个体。扩充赋值[x.append(1)]这时候heap里的数量没多，元素发生了改变。</li>
<li>平时我们说的占用内存是指heap + stack 合起来的大小</li>
<li>a = [1], b = a, a =[2] 此时b的值是[1]</li>
<li>【某语言】pass by reference: x = [1] 会变成 x = [1] 重新赋值&amp;改变object都会导致值的改变</li>
<li>【某语言】pass by value: 会把object和reference都copy一遍 x = [1] 会变成 x’ = [1]’ 怎么操作跟原来都没关系。</li>
<li>【Python】pass by object reference: x = [1] 会变成 x’ = [1] 重新赋值不会改变，修改的时候会改变</li>
</ul>
</li>
<li>tab 是 increase indent /  shift + tab 是decrease indent</li>
<li>空间复杂度：取决于<strong>额外产生</strong>的空间。因为那些数据占用的地方跟我运行我的程序没关系，并不能用来评估我的这个代码的效率。额外的空间一般都存在内存的heap里面，除了recursion【这里的heap 和stack只是内存的，和另外的heap&amp;stack不是一个东西】</li>
<li>ctr+shift+r 运行代码</li>
<li>//地板除，%显示余数</li>
<li>map支持批量化操作，节省运算速度，不用每一次都解析代码。</li>
<li>ord：Return the Unicode code point for a one-character string</li>
<li>bin(number)[2:] 可以去掉前面的’0b’</li>
<li>elif =else if</li>
<li>s.index(max(s)) 返回s中最大值的index</li>
<li>判断list是否是空的：if list/ if not list</li>
<li>在环境中删除变量。del var</li>
<li>关于xrange与range的区别：range(1,n) allocates memory to store all the 1…n values. But xrange(1,n) generates them on the fly: in each iteration the next number is generated. So it is better memory wise.</li>
<li>del：删除一个变量-如同他从未存在过</li>
<li>print(‘These items are:’, end=’ ‘) end=’’在结尾加上一个空格。默认是换行</li>
<li>time.strftime(格式) 打印当前时间 （import time）</li>
<li>程序需要人为换行的时候可以加一个反斜杠’&#39;</li>
<li><code>print(&quot;There are {:d} robots&quot;.format(Robot))</code> :  :d这里表示了Robot的格式</li>
<li>input(‘展示内容’)可以让录入用户输入的信心，返回的数据类型是str，要通过int()来变成整数</li>
<li>assert 语句：确信某事是真的，如果是假的，则直接报错返回。便于我们检查错误</li>
<li>type函数判断类型</li>
<li>id(variable) 可以返回variable所指向的内存地址，以十进制的方式来表示</li>
<li>python切片操作是左闭右开</li>
<li><strong>reduce()</strong> 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</li>
</ul>
<p><a href="https://stackoverflow.com/questions/36965507/writing-a-dictionary-to-a-text-file" target="_blank" rel="noopener">如何保存set到本地</a></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数是一个动词，执行具体的行为。函数是组织好的，可<strong>重复使用</strong>的，用来实现单一，或相关联功能的代码段。</li>
<li>print函数默认以一个回车’\n’结尾。print(‘a’,end = ‘?’)可以修改。print在打印多个对象之间会默认以一个空格连接：sep=’’可以修改</li>
<li>for和while循环也可以连接else。显而易见的。else总会被运行，除非for/while中间有break。continue 跳过代码中的剩余部分，进行下一循环</li>
<li>如果想在函数里面<strong>使用并修改全局变量</strong>，global x,y,… 可以告诉pyhon接下来函数中的用的x是一个全局变量。</li>
<li>default直接在定义里面写等于，函数中没有默认值的参数必须放在有默认值的参数的前面</li>
<li>可变参数：函数中输入参数的个数是可变的。使用<em>加变量名会把传入的数据生成一个tuple，使用*</em>的话则生成一个字典。</li>
<li>如果return没有搭配任何一个值，则表示return None</li>
<li>Python 中的 pass 语句用于指示一个没有内容的语句块。</li>
<li>print(function._<em>doc_</em>) 可以打印出来function的文档字符串。建议我在编写函数的时候，在函数的第一行就用一对三引号来写一下函数说明</li>
<li><strong>函数只evaluate到return为止</strong>，如果return的条件满足了，之后的代码就不会被执行了。return比break更强，break只能跳出一层，return直接跳出所有东西，结束了函数。</li>
<li>函数可以有多个返回值，可以return x,y 赋值的时候a,b = f()</li>
<li>函数传递的时候可以不按照顺序：<ul>
<li><code>def f=(name,age)</code></li>
<li><code>y = f(age = 12, name = &#39;Jack&#39;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_idx, max_val = max(enumerate(nums), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment">#可以获得max的index</span></span><br></pre></td></tr></table></figure>

<p>函数内定义函数：<a href="https://www.programiz.com/python-programming/closure" target="_blank" rel="noopener">Closure</a></p>
<ul>
<li>we have a closure in Python when <u>a nested function references a value in its enclosing scope</u>. And The enclosing function must <strong>return</strong> the nested function.</li>
<li>在python3 里面可以用 nonlocal 来修改</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><p>continue和break只针对外面的一层，想跳出多层循环的话只能用boolean flag</p>
</li>
<li><p>如果只是用于循环而不需要一个序列的话，用xrange要比range更好。xrange本质上是一个生成器</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">关于尾递归</a></p>
<p><img src="https://i.imgur.com/gU4JRow.jpg" alt=""></p>
</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul>
<li>字符叫char(character) 字符串叫str(string)</li>
<li><code>&#39;1&#39;*2 = &#39;11&#39;;&#39;1&#39;+&#39;2&#39; = &#39;12&#39;</code> 但是除号不能用于 str和int之间。Concatenation</li>
<li>字符串不支持对某个位置进行重新赋值: 字符串是不可变的</li>
<li>u’xxxx’ 表示xxx是用unicode来加密的</li>
<li>list()将字符串变成列表。’’.join()将列表变成字符串</li>
<li>a = ‘word’*5 迅速创建字符</li>
<li>b =  [ str(i) for i in a ]迅速将数字列表转化为字符列表</li>
<li>s.split()可以将字符按照空格切开</li>
<li>判断大小写：str.islower/str.isupper. 大小写互换: str.swapcase()</li>
<li>python中大小写转换：str.upper:全部变为大写、str.lower()：全部变为小写、str.capitalize()字符串的第一个单词的首字母变为大写，其他都是小写、str.title()：字符串的每个单词首字母大写，其他变为小写、</li>
<li>多行字符可用三个单引号或者双引号括起来，甚至可以用’’’’….’’’’ 只要前后引号数量一样即可，毕竟只有单引号双引号这两个可能不够用</li>
<li>虽然加号可以连接多个字符，但这样被认为是不优雅的。’I am’ + str(age) + ‘years old’ 可以写成：’I am {0或者空着} years old’.format(age)。<strong>format</strong>有多种用法: {0:.3f}保留小数点后三位。{0:_^11}使用下划线填充文本使文字在中央，字符长度填充为11位。大括号里面可以什么都不写，也可以写index，也可以写’name’这种具体含义，但是如果写了name需要在format里面变成<code>&#39;My name is {name}&#39;.format(name = &#39;Siyu&#39;)</code> </li>
<li>在字符串的末尾加一个反斜杠’\‘表示字符串将在下一行继续，但是不会变成新的一行. 用反斜杠属于显式行连接，用括号连接则属于隐式行连接。</li>
<li>原始字符串：常在正则表达式中出现，前面带一个r或R。前面带一个u表示是unicode编码</li>
<li>对于不可变对象str操作的时候，比如说 a.replace(‘b’, ‘B’) 其实是创建了一个新的字符，新的字符所有的b都变成了B，而a本什么还是没有发生变化</li>
<li>字符串有函数s.index(‘x’)，返回x在字符串中的位置</li>
<li>x.split(‘ ‘)[index] 可以将以空格分隔的字符拆分成几个，再用index索引取出来</li>
<li>str.zfill(num) 可以往字符前面补0来达到固定位数</li>
<li>ord: 返回字符的asc码. chr()将asc变成字符</li>
<li><code>chr.startswith()</code> 判断是不是以某个字符串开始。<code>if &#39;a&#39; in chr</code> 判断’a’是否在chr中，<code>chr.find(xx)</code> 如果xx在chr中则返回下标，如果不在，则返回1. <code>&#39;xx&#39;.join(List)</code> 将List(字符列表)中的元素用xx连接起来变成一个字符</li>
<li>str.find()字符中找匹配字符，找到了返回位置，没找到返回-1</li>
<li>去掉所有标点符号<code>re.sub(&#39;[%s]&#39; % re.escape(string.punctuation), &#39;&#39;, paragraph)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.strip()<span class="comment">#可以去掉首尾空格</span></span><br></pre></td></tr></table></figure>

<p>两个字符（长度分别为m, n）拼接操作<code>m+n</code> 时间复杂度是O(m+n)</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li>re.findall(r’abc’,s) 从s中找到所有abc并返回abc</li>
<li></li>
</ul>
<h4 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h4><p><a href="https://docs.python.org/3/howto/unicode.html" target="_blank" rel="noopener">https://docs.python.org/3/howto/unicode.html</a> #unicode教程</p>
<p><a href="https://www.compart.com/en/unicode/" target="_blank" rel="noopener">https://www.compart.com/en/unicode/</a> #unicode查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"\N&#123;GREEK CAPITAL LETTER DELTA&#125;"</span>  <span class="comment"># Using the character name</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\x0394"</span>                          <span class="comment"># Using a 8-bit hex value</span></span><br><span class="line"><span class="string">"\u0394"</span>                          <span class="comment"># Using a 16-bit hex value</span></span><br><span class="line"><span class="string">"\U00000394"</span>                      <span class="comment"># Using a 32-bit hex value</span></span><br></pre></td></tr></table></figure>



<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li>当有一列key和一列value的时候，想<strong>合成一个dict</strong>：d = dict(zip(key,value))</li>
<li>根据value找key：list(dicxx.keys())[list(dicxx.values()).index(“001”)]但是多对一的映射不好写</li>
<li>字典的Key值必须是不可变的对象（比如字符）</li>
</ul>
<p>M.get(k, d=None): 从字典M里面找key=k，找不到的话返回d而不是报错</p>
<p>M.setdefault(k, d): If key k exists in the map, simply return M[k]; if key k does not exist, set M[k] = d and return that value.</p>
<p>M.pop(k, d=None): Remove the item associated with key k from the map and return its associated value v. If key k is not in the map, return default value d. 正常删除用：<code>del M[k]</code></p>
<p>M.popitem(): Remove an arbitrary key-value pair from the map, and return a (k,v) tuple representing the removed pair. If map is empty, raise a KeyError.</p>
<p>M.clear(): Remove all key-value pairs from the map.</p>
<p>M.update(M2): Assign M[k] = v for every (k,v) pair in map M2.</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><code>bric = bri.copy()</code> 集合的硬复制，其他种类的硬复制可以通过切片的方式<code>a[:]</code></li>
<li>交集运算：<code>bri &amp; bric # OR bri.intersection(bric)</code>差集: 减号或者^。并集用 |</li>
</ul>
<p>b.issubset(a) 判断b是否是a的子集</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul>
<li>52.4E10采用科学计数法，返回一个floats</li>
<li>平方运算是*<em>：3\</em>*2=81</li>
<li>int(‘num’,base=N) 将N进制的数转换为10进制</li>
<li>bin()[2:] 转化为二进制</li>
<li>print(‘%.4f’ % 1.6) 可以规定输出小数位数</li>
</ul>
<h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><ul>
<li>可变长度的，而其他语言的array都是固定长度的，因此python没有array这个概念…所以对于长度：<ul>
<li>开始有个默认长度，比如说10</li>
<li>不断的插入元素，当达到capacity的时候(80%)</li>
<li>创建一个新的list，具有双倍的长度：20</li>
</ul>
</li>
<li>list支持mixed type</li>
<li>用加号可以连接多个list</li>
<li>lst.extend([xxxx]) 可以同时append多个元素在lst的最后/也可以用加号</li>
<li>可以用del(lst[index]) 来删除固定位置的东西</li>
<li>lst.remove(element) 删除第一个出现的element。如果没有出现，则报错</li>
<li>比较两个字符的大小，从第一个不一样的元素开始比较。如果有一个元素走到头了，剩下的长的元素会被认为是大的那个。字符会变成ASCII码来进行比较</li>
<li>list的索引从0开始，倒数第n个元素可以用「-n」或「len()-n」做索引</li>
<li>排序可以用lst.sort() 或者sorted(lst) <code>A.sort(key = lambda x: x % 2)</code> 按照除2的余数排序</li>
<li>向list中追加元素：list.append(‘new’)</li>
<li>把元素插入制定的位置：list.insert(num,’new’)</li>
<li>list.pop(n),删除第n个元素，什么都不填的话默认删除最后一个元素</li>
<li>可以通过list[k] = ‘new’ 来直接替换第k个位置上的元素</li>
<li>list里面的元素类型可以不同，甚至一个list都可以成为另一个list里面的元素</li>
<li>[12,3]*3 答案是[12,3,12,3,12,3] 乘号是重复整个list元素</li>
<li>list是mutable可变的，而<strong>字符串是不可变的(Immutable)</strong>。所以我们可以对list进行sort直接修改源文件，但是不能这么对字符串操作？</li>
<li>删除元素还可以用<code>del shoplist[0]</code></li>
<li>有时候在试index的时候发现list里面并没有这个数字，这时可以用try来解决</li>
<li>list来删除元素：<code>curr.next = curr.next.next</code></li>
<li>有时候array search的方式可能不是从左到右<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    thing_index = thing_list.index(thing)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    thing_index = <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面两种写法等价</span></span><br><span class="line">dp += min(dp[-i * i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(len(dp) ** <span class="number">0.5</span> + <span class="number">1</span>))) + <span class="number">1</span>, <span class="comment">#注意这个逗号</span></span><br><span class="line">dp += [min(dp[-i * i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(len(dp) ** <span class="number">0.5</span> + <span class="number">1</span>))) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如何找到一个loop的开始？</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fys0mm3y1lj31bd0u01kx.jpg" alt=""></p>
<p>List comprehension: 就是以前说的那个错误的’’生成器’’</p>
<h3 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h3><ul>
<li>元组是不可变的，用括号进行分隔。括号可带可不带，最好带着</li>
<li>元组里面可以包含元组</li>
<li>想生成只有一个元素的tuple需要<code>a = (2,)</code></li>
<li>tuple可以直接赋值<code>(x,y,z) = (1,2,3)</code> 但是我发现list好像也可以</li>
<li>append功能只能通过重新赋值来实现。<code>a = (1,2); a = a + (3,)</code> </li>
</ul>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ul>
<li>xxx in list/tuple：会返回逻辑值</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>模块里面的函数用点来连接：math.ceil()天花板函数</li>
<li>模块在编译中会产生.pyc文件，使得下一次载入包更加快速</li>
<li>使用点来选取模块中的部分</li>
<li>内置的 dir() 函数能够返回由对象所定义的名称列表。 如果这一对象是一个模块，则该列表会包括函数内所定义的函数、类与变量。vars有时候也能干一样的事情</li>
<li></li>
</ul>
<p>17.7.3</p>
<p>可以在终端中输入python来创造一个交互式环境【像R语言的窗口】，输入exit()来退出<br>以.py结尾的文件每一行python代码的运行结果不会自动打印，需要在外面套一个print()<br>python可以直接输入16进制的数 以0x开头<br>print(‘’’…’’’)可以使得输入过程变为多行，此时只要括号没扩上都可以用空格来换行『三个单引号』<br>布尔运算分为and or not<br>None表示空值<br>//表示取除法得数 %取余数<br>想分两行打印s2和s4，两种解决方案：print(s2,s4,sep=’’); print(s2,’\n’+s4)<br>print(str1+str2) 可以将两个字符无缝衔接</p>
<p>ord(‘str’)获取字符的整数表示 chr(num)把编码转换为对应的字符<br>字符创建方式可以用十六进制：a = ‘\u4e2d\u6587’<br>以unicode表示的字符可以编码为指定的bytes：  ‘ABC’.encode(‘ascii’)   ‘中文’.encode(‘utf-8’)<br>把bytes变为str，需要用decode： b’ABC’.decode(‘ascii’)<br>同种编码互相转的话，会报错<br>len(‘str’)可以求出str包含多少字符，也可以求出bytes的字节数：len(b’ABC’)，也可以求出list的元素个数</p>
<p>当源代码中包含中文时，需要在文件开头写上两行：<br>#!/usr/bin/env python3     第一行告诉linux/OSX系统这是一个python可执行程序<br># -<em>- coding: utf-8 -</em>-    第二行告诉要按UTF-8来进行编码</p>
<p>格式化占位符：「亲爱的xxx你好！你xx月的话费是xx，余额是xx」<br>‘Hi, %s, you have %d’ % (‘Michael’,1000)  如果只有一个%？，后面的括号可以省略。<br>常见的占位符有： %d整数 %f浮点数 %s字符串 %x十六进制整数    %%来转义%<br>例子：可以决定是否补0以及小数的位数</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘%2d-%02d’ % (3, 1)<br>‘ 3-01’<br>‘%.2f’ % 3.1415926<br>‘3.14’</p>
</blockquote>
</blockquote>
</blockquote>
<p>拆解Tuple：<br>    x=(1,2,3,4)<br>    a,b,c,d=x</p>
<p>而有序列表Tuple使用小括号，一旦初始化便不能再更改，可以从中提取元素，但不能再进行赋值删除等其他操作。<br>产生只有一个元素的Tuple时，要加一个逗号消除歧义。 t = (1,)</p>
<p>for in循环记得最后加冒号<br>range()可以生成一个整数序列（从0开始），然后还可以再用list()转换<br>break直接跳出循环，continue结束本次循环并直接开始下一轮循环</p>
<p>数据放入dict可以加快查找和插入的速度 d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}，<br>但dict需要占用大量的内存<br>可以直接通过key来放入新的数据 d[‘Adam’]=67<br>‘Thomas’ in d 来判断key「Thomas」是否存在与d<br>dict的key必须是不可变对象，因为这个算法是通过Key来计算位置的，这种叫哈希算法。因此list因为具有可变的性质，不能被作为dict的key。<br>x{‘name’:email}我们可以设置三种循环：<br>    ①for name in x:<br>        print(x[name]) #会输出email<br>    ②for email in x.values():<br>        print(email) #也会输出email<br>    ③for name,email in x,items():<br>        print(name)<br>        print(email)  #会打印出来name和email</p>
<p>d.get(‘str’,-1) 如果’str’存在于d就返回’str’对应的值，否则返回-1<br>d.pop(‘str’)删除d中的str以及它对应的值</p>
<p>set也是一组key的集合，但不存储value。<br>s.add(new)添加新元素     s.remove()可以删除元素<br>两个集合可以做数学上的交集与并集。 s1&amp;s2是交集  s1|s2是并集<br>bool(xx)可以把xx变成True/False<br>hex()十进制to十六进制，bin()十进制to二进制 bin(x^y)比较xy各个位数一样的写0不一样的写1<br>空函数： def nop(): pass   可以用作占位符，先让其他代码能运行起来。</p>
<p>定义函数时可以顺便加上数据类型检查： if not isinstance(x,(int,float))<br>                               raise TypeError(‘bad operand type’)<br>检验多个参数时可用<br>f=[False for x in (a,b,c) if not isinstance(x,(int,float))]<br>if f:<br>raise TypeError(‘Bad Type’)    注意：False首字母大写才表示错误的意思</p>
<p>import math 导入math包 允许使用sin/cos等函数<br>定义参数的时候可以默认参数：def power(x, n=2):  意思便是如果power(2,5)便计算2的五次方，如果power(4)便默认计算4的平方。<br>注意：①必选参数必须放在默认参数之前，②默认参数必须指向不变对象。<br>def add_end(L=[]):<br>    L.append(‘END’)<br>    return L    在不停的调用add_end()时，就会出问题，因为此时默认参数指向了一个可变对象</p>
<p>可变参数：def calc(<em>args):  同时 *args表示把args这个list所有的元素作为可变参数传进去。<br>关键字参数：def person(name, age, *</em>kw): 可以在输入的时候填入除了必选项之外的信息，person(‘Bob’, 35, city=’Beijing’)像这里的city就属于关键字参数<br><strong>extra表示把extra这个dict所有的key-value用关键字参数传入到函数的</strong>kw参数<br>限制关键字参数的名字：def person(name, age, <em>, city, job):命名关键字参数<br>def person(name, age, *args, city, job):后面的city与job就不需要再添加</em>了<br>命名关键字参数也可以有缺省值。<br>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>递归时防止栈溢出的方式：使最后的return仅返回递归函数本身，不能包含表达式。这种方式又被称为尾递归。</p>
<p>创建一个1，3，5…99的列表：list(range(1,100,2))  或者 list(range(100))[1::2]</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Object-oriented是否是面向对象编程主要看是不是具有关键字Class（如汇编和Pascal就没有，他们是面向过程process-oriented）</p>
<h2 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h2><p>我们为什么需要Class？</p>
<ol>
<li>每个object有多个属性</li>
<li>需要针对这些属性建立一些能完成特殊需求的函数：比如查找…</li>
</ol>
<p>Coding style: 像self._value这样，就默认了value这个值是内部封装的一个变量，用户最好不要随意玩耍，这样通过变量名字来暗示这一点</p>
<ul>
<li><code>def __init__(self,):</code> Constuctor：对想操作的对象进行初始化，相当于造出来了一个object。可以把其他的函数看做设计的蓝图，而init可以看做是开始施工</li>
<li><code>class SchoolMember:</code> self 在class的第一行并不出现</li>
<li><code>__del__或者__len__</code> 都有各自的触发条件，本质上跟<code>__init__</code> 属于一类函数。这种函数一般都不会被直接call，有其他方式来调用</li>
</ul>
<p>class listnode(object) #这样会直接生成<strong>new-style class</strong> 额所以老师建议也放一个object进去</p>
<p>class里面的__.xxx 的变量是不能被用户直接调用的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.__value = value</span><br><span class="line">s = xxx(<span class="number">5</span>)</span><br><span class="line">print(s.value) <span class="comment">#会输出5</span></span><br><span class="line">print(s.__value) <span class="comment">#会报错</span></span><br></pre></td></tr></table></figure>







<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul>
<li>f.open(‘file.txt’,’w’) 打开一个本地文件 (‘w’写入模式，’r’只读模式, ‘a’追加模式) （还可以选择’t’文本模式，’b’二进制模式）类似的函数还有f.write, f.close, f.readline.</li>
<li>io.open(…, encoding = ‘utf-8’) 可以选择语言。</li>
<li>pickle.dump/pickle.load 进行文件的封装和拆封</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li><p>在我们有可能遇到异常的时候，可以采取try的方法。我们将所有可能引发异常或错误的语句放在 try 代码块中，并将相应的错误或异常的处理器 （Handler）放在 except 子句或代码块中。 except 子句可以处理某种特定的错误或异常， 或者是一个在括号中列出的错误或异常。如果没有提供错误或异常的名称，它将处理所有错误与异常。</p>
<p>try:</p>
<pre><code>text = input(&apos;Enter something --&gt; &apos;)</code></pre><p>except EOFError:</p>
<pre><code>print(&apos;Why did you do an EOF on me?&apos;)</code></pre></li>
<li><p>可以通过raise语句触发一个用户自定义的Exception类</p>
</li>
<li><p>try…finally 可以使finally的部分100%会被运行，而不会受到前面的代码错误的影响</p>
</li>
<li><p>如果用try finally 进行打开文件+关闭文件的操作 可以用with open来简洁的代替</p>
</li>
</ul>
<p>#数学</p>
<ul>
<li><p>itertools 中的permutations&amp;combinations 可以求出排列组合</p>
</li>
<li><p>float(‘inf’)正无穷</p>
</li>
<li><p>for i,j in enumerate(nums) 要多用</p>
</li>
<li><pre><code class="python">map(operator.sub, sums[k:], sums)可以实现sums数列相差k个元素的取差。引入operator只是给出了个减法函数,类似的还有add,abs...
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- </span><br><span class="line"></span><br><span class="line">为了注意range的用法</span><br><span class="line"></span><br><span class="line">L[0:3]表示从索引0开始取，一直取到索引3前面的那个元素，还可以倒数切片，两个数字之差是几，就切出来几个元素</span><br><span class="line">L[:]可以原样复制一个list L[::-1]可以把列表倒置</span><br><span class="line">字符串也可以看成是一种list，每个元素就是一个字符</span><br><span class="line">默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()</span><br><span class="line">enumerate可以把list变成索引元素对。给元素标上号</span><br><span class="line"></span><br><span class="line">列表生成式的应用：</span><br><span class="line">&gt;&gt;&gt; L &#x3D; [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">&gt;&gt;&gt; [&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]</span><br><span class="line"></span><br><span class="line">生成器generator：将列表生成式中的[]变成() 中的每个元素只是保留了算法，没有展开计算，所以在调用或者打印的时候要用next()或者for循环</span><br><span class="line">例如斐波那契数列：</span><br><span class="line">def fib(max):</span><br><span class="line">    n, a, b &#x3D; 0, 0, 1       注意这里的赋值语句</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b &#x3D; b, a + b      注意这里的计算语句</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">    return &#39;done&#39;</span><br><span class="line"></span><br><span class="line">把上式中的print改成yield就变成了一个generator 需要用for循环来输出值。</span><br><span class="line">生成器在做的时候可以设置成无限循环，在输出的时候控制break来跳出即可</span><br><span class="line"></span><br><span class="line">把list,dict,str等可迭代对象变成迭代器可以使用iter()函数</span><br><span class="line"></span><br><span class="line">凡是对一个list里面的每个元素进行同一个操作的算法都可以用map: list(map(f,[]))</span><br><span class="line">reduce 把一个二元函数作用在一个序列上，reduce(f, [x1, x2, x3, x4]) &#x3D; f(f(f(x1, x2), x3), x4)</span><br><span class="line">from functools import reduce  #用reduce之前要写这样一句话</span><br><span class="line">字符转换成数字：</span><br><span class="line">def char2num(s):</span><br><span class="line">    return &#123;&#39;0&#39;:0,&#39;1&#39;:1,&#39;2&#39;:2,&#39;3&#39;:3,&#39;4&#39;:4,&#39;5&#39;:5,&#39;6&#39;:6,&#39;7&#39;:7,&#39;8&#39;:8,&#39;9&#39;:9&#125;[s]</span><br><span class="line"></span><br><span class="line">filter(f,L&#x3D;[…]) 前面的f是是非判断函数，用来留下L中为True的那些元素</span><br><span class="line">sorted()对一个列表排序，可以接受key：sorted([36, 5，-4], key&#x3D;abs)，反向排序加上 reverse&#x3D;True </span><br><span class="line">函数下返回函数，节省运算时间空间。比如计算求和的时候存储的是一个求和的式子，待到需要运算结果的时候再对那个求和式子进行运算。下面是一个闭包实例：</span><br><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs &#x3D; []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">匿名函数lambda：reduce(lambda x, y: x * y, L)</span><br><span class="line">函数有个__name__的属性，可以拿到函数的名字</span><br><span class="line">装饰器：在代码运行简动态增加功能又不改变函数自身的定义。</span><br><span class="line">import functools</span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)     #这一行目的是使得函数名称不改变</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#39;%s %s():&#39; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">偏函数functools.partial的作用是把一个函数的某些参数固定住（修改了默认值）。int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br><span class="line"></span><br><span class="line">安装第三方库：pip3 install Pillow 在terminal里面</span><br><span class="line"></span><br><span class="line">x^y表示的是异或 相同输出0不同输出1</span><br><span class="line">zip(*map&#x2F;list)可以将这个矩阵转置(如果长度不同取最短)—输出的时候格式会有一些问题</span><br><span class="line"></span><br><span class="line">combined&#x3D;[x for j in nums for x in j] 可以把nums&#x3D;[[2,3],[4,5]]变为[2,3,4,5]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">17.11.17</span><br><span class="line"></span><br><span class="line">def add_numbers(x,y,z&#x3D;None):  </span><br><span class="line">	return x+y+z	</span><br><span class="line">预设了z&#x3D;None之后，如果输入的变量只有两个，程序也可以运行。注意提供默认值的变量必须放在变量的最后</span><br><span class="line">type 可以查看变量类型</span><br><span class="line"></span><br><span class="line">连接字符和数字的时候需要在数字外面套一个str()</span><br><span class="line"></span><br><span class="line">字符串格式处理语言：</span><br><span class="line">	sales_record &#x3D; &#123;&#39;price&#39;: 3.24,&#39;person&#39;: &#39;Chris&#39;&#125;</span><br><span class="line">	sales_statement &#x3D; &#39;&#123;&#125; bought item(s) at a price of &#123;&#125; each&#39;</span><br><span class="line">	print(sales_statement.format(sales_record[&#39;person&#39;],sales_record[&#39;price&#39;]))</span><br><span class="line"></span><br><span class="line">.shape #输出矩阵大小</span><br><span class="line">.reshape(n,m) #将矩阵变成n*m的矩阵 resize好像也可</span><br><span class="line">Numpy：</span><br><span class="line">	numpy.array([],[]) #建立矩阵 如果是连接的话，默认是vertical?</span><br><span class="line">	numpy.arange(0,30,2) 生成一个0-28的步长为2的一维矩阵</span><br><span class="line">	numpy.linspace(出发，终止，个数) 创建一个一维矩阵</span><br><span class="line">	numpy.ones&#x2F;zeros&#x2F;eye&#x2F;diag 创建全是1、全是0、标准阵、对角阵(把一个已知n维向量变成n维矩阵)</span><br><span class="line">	numpy.array([1,2,3]*3)和numpy.repeat([1,2,3],3) #前者是123123123，后者是111222333</span><br><span class="line">	numpy.vstack&#x2F;hstack 竖直（水平）连接两个矩阵</span><br><span class="line">	numpy.random.randint 产生随机数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x.dot(y) 做x,y的点乘</span><br><span class="line">z.T 做transpose</span><br><span class="line">z.dtype 当前type</span><br><span class="line">z.astype(&#39;f&#39;) 变type为f</span><br><span class="line">常用函数.sum&#x2F;max&#x2F;min&#x2F;mean&#x2F;std&#x2F;argmax(输出最大值的index)</span><br><span class="line">.copy 复制出来，要不然的话对复制出来的进行修改，也会改变原数据</span><br><span class="line">想要同时对两个东西进行迭代 可以用zip()</span><br><span class="line">索引-1表示最后一个 :-1表示除去最后一个 ::-1 将数据反向排列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 二叉树</span><br><span class="line"></span><br><span class="line">- 四种遍历方式：层序：一行一行。先序：根左右。中序：左根右。后序：左右根</span><br><span class="line">- 后序遍历最后一个节点是根节点</span><br><span class="line"></span><br><span class="line">可以在self树结构里面挂更多的信息，方便做某些题目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 概念&amp;哲学&amp;错误</span><br><span class="line"></span><br><span class="line">- 在定义函数 时给定的名称称作“形参”(Parameters)，在调用函数时你所提供给函数的值称作“实参”(Arguments)。</span><br><span class="line">- 警告：一般来说，你应该尽量避免使用 from...import 语句，而去使用 import语句。这是为了避免在你的程序中出现名称冲突，同时也为了使程序更加易读。</span><br><span class="line">- EOFerror：end of file</span><br><span class="line"></span><br><span class="line">对于for i in range这种循环操作，如果循环指标i无意义的话可以使用：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">for _ in range(10) #用下划线来代替指标i</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" target="_blank" rel="noopener">Python命名艺术</a></p>
<p><a href="https://stackoverflow.com/questions/41691327/ssl-sslerror-ssl-certificate-verify-failed-certificate-verify-failed-ssl-c#41692664" target="_blank" rel="noopener">nltk.download失败</a></p>
<p><a href="https://blog.csdn.net/u011012422/article/details/84201075" target="_blank" rel="noopener">Error:Cannot start process, the working directory ‘’ does not exist</a></p>
<p>默认的re匹配完之后就会继续从下一个地方找，不会寻找overlap的匹配。<a href="https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches" target="_blank" rel="noopener">stackoverflow</a> 里面两种解法都挺好的，第一种更妙，寻找Pattern前面的字符然后定位。</p>
<h1 id="IPython-Notebook"><a href="#IPython-Notebook" class="headerlink" title="IPython Notebook"></a>IPython Notebook</h1><p><a href="https://stackoverflow.com/questions/36786722/how-to-display-full-output-in-jupyter-not-only-last-result" target="_blank" rel="noopener">解决只有最后一行结果的问题</a> :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure>









<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>argsort 相当于r里面的order</p>
<p>np.floor/ceil 地板/天花板函数</p>
<p><code>np.delete(arr, obj, axis=None)</code> Return a new array with sub-arrays along an axis deleted.</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data * <span class="number">10</span> <span class="comment">#每个数字都乘10</span></span><br><span class="line">data + data <span class="comment">#对应位置相加，相乘也是类似</span></span><br><span class="line">data.shape <span class="comment">#返回维数(行，列) 几乘几（每一维是多少）</span></span><br><span class="line">data.dtype <span class="comment">#返回里面数据的类型</span></span><br><span class="line">data[k,:], data[k] <span class="comment">#取出第k+1行</span></span><br><span class="line">data[:,k] <span class="comment">#取出第k+1列</span></span><br><span class="line">data[<span class="number">5</span>:] <span class="comment">#取出第五个以及之后的</span></span><br><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>], arr2d[<span class="number">0</span>, <span class="number">2</span>] <span class="comment">#这两种写法都可以</span></span><br><span class="line">data.ndim <span class="comment"># 打印出来有几维，比如说一个4*5的二维数组，会打印出来2</span></span><br><span class="line">data.reshape(m,n) <span class="comment"># 变换维数，-1 表示缺省值，系统可以帮我们计算这里填什么</span></span><br><span class="line">arr.T <span class="comment">#转置</span></span><br><span class="line">arr.mean(), np.mean(arr) <span class="comment"># 可以求mean</span></span><br><span class="line">arr.sum(axis = <span class="number">0</span>) <span class="comment"># 求和 0是按列求和，1是按行求和</span></span><br><span class="line">arr.cumsum() <span class="comment"># 累积求和</span></span><br><span class="line">arr.sort(<span class="number">1</span>) <span class="comment">#排序 1指的是按行排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>)) <span class="comment">#生成一个3*6的全0数据</span></span><br><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">#随机生成一组数据，分布未知</span></span><br><span class="line">np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="comment"># create 1d array 左闭右开 2是步长</span></span><br><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32) <span class="comment">#dtype规定类型，默认是float64/int64</span></span><br><span class="line"><span class="comment">#dtype其他类型：np.string_(注意有个下划线), 'u4'/'u8' 分别表示uint32/uint64</span></span><br><span class="line">data.astype(np.float64) <span class="comment">#astype来改变类型，将小数变成整数的时候，直接扔掉了小数部分</span></span><br></pre></td></tr></table></figure>

<p>array的slicing也只是传递了内存地址，软拷贝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.copy() <span class="comment">#硬拷贝，生成一份复制品</span></span><br></pre></td></tr></table></figure>

<p>python支持boolean indexing，这里跟R好像啊</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[name = <span class="string">'BOB'</span>] <span class="comment"># 选出name是bob的那些行</span></span><br><span class="line">data[~(name = <span class="string">'BOB'</span>)] <span class="comment"># 选出name 不 是bob的那些行</span></span><br></pre></td></tr></table></figure>

<h3 id="np系列其他函数"><a href="#np系列其他函数" class="headerlink" title="np系列其他函数"></a>np系列其他函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.dot(arr.T, arr) <span class="comment">#计算点乘/矩阵乘积</span></span><br><span class="line">x @ x.T <span class="comment">#另一种点乘的方式</span></span><br><span class="line">np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)) <span class="comment">#高维转置闪瞎我的眼，先不琢磨了，微难想</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 高维交换坐标轴，这里是交换第2和第三维</span></span><br><span class="line">np.sqrt(arr), np.exp(arr) <span class="comment"># Fast Element-Wise Array Functions</span></span><br><span class="line">np.maximum(x, y) <span class="comment">#### 在比较x，y两个向量的时候，居然是逐个位置进行比较的，最后返回一个向量</span></span><br><span class="line">remainder, whole_part = np.modf(arr) <span class="comment"># 将一个小数的整数部分和小数部分分别取出来</span></span><br><span class="line">np.sqrt(arr, arr) <span class="comment">#这个会将sqrt的结果传给arr，相当于 arr = np.sqrt(arr)?</span></span><br><span class="line">a,b = np.meshgrid(x,y) <span class="comment">#Matlab里面也有这个函数，生成网格矩阵，其中a的每一行是x的复制，b的每一列是y的复制,复制的次数是另一个的维数</span></span><br><span class="line">np.where(cond, xarr, yarr) <span class="comment"># 如果cond是True，返回xarr的值，如果是False，返回yarr的值</span></span><br><span class="line">np.unique(names) <span class="comment">#DISTINCT</span></span><br><span class="line">np.in1d(X,Y) <span class="comment">#逐个判断X的元素是不是在Y里面</span></span><br></pre></td></tr></table></figure>

<p>Boolean 判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line">bools.any() <span class="comment">#True</span></span><br><span class="line">bools.all() <span class="comment">#False</span></span><br></pre></td></tr></table></figure>

<p>数据存入导出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.save(<span class="string">'some_array'</span>, arr) <span class="comment">#导出为一个npy数据</span></span><br><span class="line">np.load(<span class="string">'some_array.npy'</span>) <span class="comment">#导入数据</span></span><br><span class="line"><span class="comment">###多个文件一起存</span></span><br><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr) </span><br><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line">arch[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr) <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>Linear Algebra</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br></pre></td></tr></table></figure>



<p>np.linspace(1.5, 2.5, 9) 左闭右闭 9是数量</p>
<p>np.zeros/ ones/ full[填充常数] / eye [identity array]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1 = a[<span class="number">0</span>, :] <span class="comment"># rank 1 view of the first row 这个是一维的</span></span><br><span class="line">r2 = a[<span class="number">0</span>:<span class="number">1</span>, :] <span class="comment"># rank 2 view of the first row 这个是二维的</span></span><br></pre></td></tr></table></figure>

<p><code>a[(a &gt; 5) &amp; (a &lt; 10)]</code> 用小括号来做boolean array</p>
<p>加减乘除都是point-wise</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(np.dot(a, b.transpose())) <span class="comment"># 2x3, 3x2</span></span><br><span class="line">print(a.T.dot(b)) <span class="comment"># 3x2, 2x3 两种矩阵乘积的方法</span></span><br></pre></td></tr></table></figure>

<p>python支持broadcasting，两个维数不同的矩阵进行加减</p>
<ul>
<li>Rule：<a href="https://docs.scipy.org/doc/numpy-1.15.0/user/basics.broadcasting.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/numpy-1.15.0/user/basics.broadcasting.html</a></li>
<li>维数能操作：从最后一位往前看，每一位都需要满足：<ul>
<li>两个维数相等 </li>
<li>其中一个维数是1 </li>
<li>要是有一个维数更长，多出来的那一部分不用管</li>
</ul>
</li>
</ul>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=(<span class="number">4</span>, <span class="number">4</span>)) <span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> normalvariate <span class="comment">#Multivariate </span></span><br><span class="line">np.random.randint(low, high=<span class="literal">None</span>, size=<span class="literal">None</span>, dtype=<span class="string">'l'</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/22994423/difference-between-np-random-seed-and-np-random-randomstate" target="_blank" rel="noopener">random.seed 与 random.state的区别</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><code>np.random.seed(42) #产生随机种子</code></p>
<p><code>np.random.choice(np.arange(100),size=[10,3],replace=True)</code> 随机抽样</p>
<p><code>np.random.shuffle</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.randn(<span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 用来产生正态N(0, 1)随机数，参数只是维数，如果想改变方差均值，需要在外面自己做变换</span></span><br></pre></td></tr></table></figure>





<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><ul>
<li>info() 返回数据基本信息和数据内容</li>
<li>value_counts() 计数</li>
<li>.head()/ .tail() 返回前五行和最后五行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat_tmp = dat.iloc[:,<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 选取某几列</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans.to_csv(<span class="string">'save.csv'</span>, index = <span class="literal">False</span>) <span class="comment">#df - csv index指的是是否保存rowname</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dataframe.columns.values <span class="comment">#Get header</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/17071871/select-rows-from-a-dataframe-based-on-values-in-a-column-in-pandas" target="_blank" rel="noopener">条件的取出行</a></p>
<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>把一个list缩成一个字典，key就是list里面的元素，value就是元素重复的次数</p>
<ul>
<li>most_common(k) 可以返回k个最多的元素</li>
</ul>
<p><strong>defaultdict</strong>(list) #创立一个value是list的初始dict，可以直接如下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> sequence:</span><br><span class="line">    counts[x] += <span class="number">1</span> <span class="comment">#不用去在意x是否原先在counts里面 会被intialize to 0</span></span><br></pre></td></tr></table></figure>




<h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><ul>
<li>accumulate: 相当于numpy里面的cumsum</li>
</ul>
<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><ul>
<li>sub 减法 用来配合map使用</li>
</ul>
<h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><ul>
<li>nlargest/nsmallest 可以求出序列中前几个最大值/最小值</li>
</ul>
<h2 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h2><p><a href="https://networkx.github.io/documentation/networkx-1.10/index.html" target="_blank" rel="noopener">https://networkx.github.io/documentation/networkx-1.10/index.html</a></p>
<h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p>Mac端Pycharm不能直接画图，需要</p>
<ul>
<li>用代码<code>print(matplotlib.get_backend())</code> 查看输出是否为MACOSX，如果是的话：</li>
<li>参考这个网页：<a href="https://stackoverflow.com/questions/47834643/how-can-i-run-matplotlib-in-pycharm-on-macos" target="_blank" rel="noopener">修改默认画图选项</a></li>
<li>另外注意必须先写<code>import matplotlib</code>, 再写<code>import matplotlib.pyplot as plt</code></li>
</ul>
<p><a href="https://stackoverflow.com/questions/16625507/python-checking-if-point-is-inside-a-polygon" target="_blank" rel="noopener">判断一个点是否在多边形里面</a></p>
<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><ul>
<li>在比较tuple的时候会比较每个元素，而不只是tuple的第一元素。对于数字我们可以用<code>float(&#39;Inf&#39;)</code> 来控制大小，对于字符的话最小值为<code>&#39;&#39;</code>, 最大值目前还没有想法，不过有个老哥提出了<code>&#39;z&#39;*101</code> 我有点好奇</li>
</ul>
<h2 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>

<p>一共有五种预设主题，通过<code>sns.set_style(&#39;whitegrid&#39;)</code> 来修改。</p>
<ul>
<li>darkgrid，whitegrid，dark，white，和ticks</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.distplot <span class="comment">#画出密度分布</span></span><br></pre></td></tr></table></figure>

<h2 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h2><p>制作交互界面</p>
<p><a href="https://morvanzhou.github.io/tutorials/python-basic/tkinter/3-03-example3/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/tkinter/3-03-example3/</a></p>
<h2 id="其他包包"><a href="#其他包包" class="headerlink" title="其他包包"></a>其他包包</h2><p><strong>ast</strong>: </p>
<ul>
<li><a href="https://stackoverflow.com/questions/46144452/writing-a-set-to-an-output-file-in-python" target="_blank" rel="noopener">输出set到本地</a></li>
</ul>
<p><strong>spacy</strong>:</p>
<ul>
<li><a href="https://github.com/hamelsmu/Seq2Seq_Tutorial/issues/1" target="_blank" rel="noopener">无法加载en包</a></li>
</ul>
<h1 id="操作技巧"><a href="#操作技巧" class="headerlink" title="操作技巧"></a>操作技巧</h1><ul>
<li>cmd+/ 快速批量注释。还可以在想注释内容的前后加上三个单引号</li>
<li>help(‘function’) 帮助手册</li>
<li>一行如果想输入多个代码语句，中间用分号连接</li>
<li><em>Command+Option+L</em> 一键使代码符合规范</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Spark心得</title>
    <url>/2020/07/02/Spark%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Laioffer学习的，628第三次yelp正好用上了。</p>
<a id="more"></a>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Apache Spark 读作 阿派cheap（没有p）</p>
<p><a href="https://databricks.com/blog/2015/04/13/deep-dive-into-spark-sqls-catalyst-optimizer.html" target="_blank" rel="noopener">Spark_Optimizer</a></p>
<p>数据类型RDD：Resilient Distributed Datasets (<strong>RDD</strong>) is a fundamental data structure of Spark. It is an immutable distributed collection of objects. Each dataset in <strong>RDD</strong> is divided into logical partitions, which may be computed on different nodes of the cluster.</p>
<p>Spark allows two distinct kinds of operations by the user. There are <strong>transformations</strong> and there are <strong>actions</strong>.</p>
<ul>
<li><strong>Transformations</strong> are operations that will not be completed at the time you write and execute the code in a cell - they will only get executed once you have called a <strong>action</strong>.</li>
<li>Examples of Transformations: select, distinct, groupBy, sum, orderBy, filter, limit</li>
<li><strong>Actions</strong> are commands that are computed by Spark right at the time of their execution.</li>
<li>Examples of Actions: show, collect, count, save</li>
</ul>
<p>%[coding language] 来切换python/R/SQL</p>
<p>display(xxx) 用来展示一下dataframe</p>
<ul>
<li>这个函数厉害的点在于：we can very easily <strong>create some more sophisticated graphs</strong> by clicking the graphing icon that you can see below</li>
</ul>
<p>xxx.explain() 来解释transformation背后的physical plan</p>
<p><code>Xxx.first()</code> 取出header</p>
<p><code>xxx.take(n)</code> 取出前n行</p>
<p><a href="https://docs.databricks.com/user-guide/libraries.html" target="_blank" rel="noopener">Databricks倒入外部包</a></p>
<p>DS/DF 比RDD更快，因为Spark知道了数据的样子</p>
<p>ReduceByKey 比GroupByKey好处：在shuffle之前做了一步聚合操作，压缩数据传输量。</p>
<p>Join是最慢的一个操作。</p>
<p>spark.read.json自动变成DF</p>
<p>df.show()#画个图</p>
<p>df.count()#有几行</p>
<p>df.printSchema()#看看基本信息</p>
<p>df.createOrReplaceTempView(Name) #可以变成一个table，可以之后用SQL</p>
<p>spark.sql(“SELECT…”) #SQL语句，用这种方式取出来的格式是Data.frame</p>
<p>pyspark.sql.row #用来生成DF</p>
<p>spark.createDataFrame(NAME)</p>
<p>vector assembler 可以把columns转化成vector</p>
<h1 id="pyspark"><a href="#pyspark" class="headerlink" title="pyspark"></a>pyspark</h1><p><a href="https://www.analyticsvidhya.com/blog/2016/10/spark-dataframe-and-operations/" target="_blank" rel="noopener">pyspark教程</a></p>
<p><a href="https://stackoverflow.com/questions/46956026/how-to-convert-column-with-string-type-to-int-form-in-pyspark-data-frame" target="_blank" rel="noopener">如何修改列的type</a>：<code>crimeSunday = crimeSunday.withColumn(&#39;X&#39;, crimeSunday[&#39;X&#39;].cast(&#39;float&#39;))</code></p>
<h1 id="Databricks-语法"><a href="#Databricks-语法" class="headerlink" title="Databricks 语法"></a>Databricks 语法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbutils.fs.rm(&#39;FileStore&#x2F;tables&#x2F;628&#x2F;review_100k.json&#39;,True) #删除自己上传的文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>SQL心得</title>
    <url>/2020/07/02/SQL%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>找工作时出了出汗，还在Hackerank上面刷题。现在估计都忘了…</p>
<a id="more"></a>



<h1 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h1><ul>
<li>拿到某一列最大值的那一行数据</li>
</ul>
<h1 id="例题解答"><a href="#例题解答" class="headerlink" title="例题解答"></a>例题解答</h1><ol>
<li><a href="https://www.hackerrank.com/challenges/weather-observation-station-6/forum" target="_blank" rel="noopener">首字母是元音</a><ul>
<li><code>WHERE LEFT(CITY,1) IN (&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;);</code></li>
<li><code>WHERE CITY REGEXP &#39;^[AEIOU]&#39;</code></li>
</ul>
</li>
</ol>
<p><a href="https://www.hackerrank.com/challenges/draw-the-triangle-1/problem" target="_blank" rel="noopener">打印小星星</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="built_in">number</span> = <span class="number">21</span>; <span class="comment">/*这一步应该是设定变量？为什么不用Declare，省事！*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">repeat</span>(<span class="string">'* '</span>, @<span class="built_in">number</span> := @<span class="built_in">number</span> - <span class="number">1</span>) <span class="keyword">from</span> information_schema.tables<span class="comment">/*内置table可供遍历*/</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @COUNTER <span class="built_in">INT</span> = <span class="number">20</span>;</span><br><span class="line">WHILE @COUNTER &gt;= 0</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    PRINT <span class="keyword">REPLICATE</span>(<span class="string">'* '</span>, @COUNTER)</span><br><span class="line">    <span class="keyword">SET</span> @COUNTER = @COUNTER - <span class="number">1</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>







<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>Statement always end in a semi-colon;</li>
<li>注释一般用/**/</li>
<li>Command 一般都用大写来表示</li>
<li>character在这里面被称为TEXT：（四种常见格式：INTEGER, TEXT, DATE, REAL）</li>
<li>missing value 用 NULL 表示</li>
<li>Line breaks don’t mean anything specific in SQL. We could write this entire query in one line, and it would run just fine.</li>
<li><code>AS</code> is a keyword in SQL that allows you to <em>rename</em> a column or table using an alias. 跟sas的label一样，只改变输出不改变原数据</li>
<li><code>DISTINCT</code> is used to return unique values in the output. It filters out all duplicate values in the specified column(s).</li>
<li>判断等号的方式就是一个等于号</li>
<li>FROM some_table a 可以用a来指代这个table</li>
<li>如果没有数据的时候要返回NULL 可以用双重SELECT 也可以把UNION SELECT NULL放在语句中</li>
<li>DROP TABLE xxx 彻底删除数据库</li>
<li>IN/NOT IN 判断属于情况</li>
<li>DELETE可以直接删除某一行观测值</li>
<li>关于时间的函数：<strong>TO_DAYS(wt1.DATE)</strong> return the number of days between from year 0 to date DATE, <strong>subdate</strong>(w1.Date, k)可以把日期往前调k天</li>
<li>mod(id,2)=0 偶数 还可以用id % 2 =0</li>
</ul>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每一行都必须具有一个主键值（主键列不允许NULL值）；</li>
<li>主键列中的值不允许修改或更新；</li>
<li>主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。</li>
</ul>
<p>注释用#或者/**/</p>
<p>不等于可以用&lt;&gt;</p>
<p>Between and 是包含一个闭集</p>
<p>在SELECT语句中，子查询总是从内向外处理。在处理上面的SELECT语句时，DBMS实际上执行了两个操作。</p>
<p>作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。</p>
<p>if(判断，如果真，如果假)</p>
<p><code>ORDER BY RIGHT(NAME,3),ID;</code> 可以根据NAME的最后三个字符来排序</p>
<p>定义一个变量 <code>DECLARE @variable_name variable_type = xxx</code>，赋值可以单独用<code>SET @variable_name = xxx</code> 来操作。不过我发现有时候不DECLARE直接SET也可以。</p>
<p>information_schema.tables 是内置的一个table，有61行</p>
<h1 id="Manipulation"><a href="#Manipulation" class="headerlink" title="Manipulation"></a>Manipulation</h1><ul>
<li>CREATE TABLE celebs(<br> id INTEGER,<pre><code> name TEXT,
age INTEGER</code></pre>  );  创建table 可以在数据类型后面跟上NULL/NOT NULL 来要求是否允许缺失值，默认为NULL。可在接着在后面给出 DEFAULT xxx 来给出默认值。可以直接标注primary key</li>
<li>ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id); 也可以增添主键</li>
<li>外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。</li>
<li>只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识。</li>
<li>INSERT INTO celebs (id, name, age) VALUES (2, ‘Beyonce Knowles’, 33);<br> 插入新数据。insert后面没有分号，每插入一行数据就要用一个insert？并且还可以在括号中列出来想插入哪些列的变量，没被填写的那些除非是auto-increment否则会被NULL代替。</li>
<li>如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。1. 该列定义为允许NULL值（无值或空值）。2. 在表定义中给出默认值。这表示如果不给出值，将使用默认值。如果对表中不允许NULL值且没有默认值的列不给出值，DBMS将产生错误消息，并且相应的行插入不成功。</li>
<li>SELECT * INTO CustCopy FROM Customers; 可以实现复制表的功能。不过不管从多少个表中检索数据，数据都只能插入到一个表中。</li>
<li>UPDATE celebs<br>SET age = 22<br>WHERE id = 1; 将celebs数据中id=1的数据，age改为22 这个WHERE很关键，如果没有的话，【所有数据都会被改变】</li>
<li>要删除某个列的值，可用UPDATE设置它为NULL（假如表定义允许NULL值）。</li>
<li>ALTER TABLE celebs ADD COLUMN<br>twitter_handle TEXT; 增加新的一列</li>
<li>DELETE FROM celebs WHERE<br>twitter_handle IS NULL;  删除推特账号是missing的数据。删除一行/多行</li>
<li>如果要从Products表中删除一个产品，而这个产品用在OrderItems的已有订单中，那么DELETE语句将抛出错误并中止。这是总要定义外键的另一个理由。</li>
<li>在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>DROP TABLE 彻底删除一个表，而不只是删除其内容</li>
</ul>
<p>唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。 </p>
<ul>
<li>表可包含多个唯一约束，但每个表只允许一个主键。</li>
<li>唯一约束列可包含NULL值。 </li>
<li>唯一约束列可修改或更新。 </li>
<li>唯一约束列的值可重复使用。 </li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ul>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>SELECT * FROM celebs;  select会生成一个新的 result table</p>
<ul>
<li>SELECT column1,column2, … FROM table; 【用逗号连接】</li>
<li><code>WHERE</code> clause filters the result set to only include rows where the following <em>condition</em> is true.</li>
<li>IN操作符一般比一组OR操作符执行得更快。IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句。</li>
<li><code>LIKE</code> is a special operator used with the <code>WHERE</code> clause to search for a specific pattern in a column. 像是在按照模式匹配字符串，<strong>不分大小写</strong>。用_下划线来指代任何单个字符，%代表任何单/多个字符</li>
<li>通配符%看起来像是可以匹配任何东西，<strong>但有个例外，这就是NULL</strong>。子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL的行。</li>
<li>方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。此通配符可以用前缀字符^（脱字号）来否定。</li>
<li>通过IS NULL/IS NOT NULL 来判断是否为缺失值(大于小于等于号之类的不行)</li>
<li>BETWEEN 如果是两个字符的话不包含第二个字符，如果是两个数字则包含第二个数字</li>
<li>可以用AND/OR 来连接多个condition</li>
<li>ORDER BY … DESC/ASC 降序或者升序排列（注意DESC放在列名的后面，DESCENDING也可以）。在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</li>
<li>如果有必要，可以混合匹配使用实际列名和相对列位置（1,2,3,…）。</li>
<li>在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误</li>
<li><code>LIMIT</code> is a clause that lets you specify the maximum number of rows the result set will have. This saves space on our screen and makes our queries run faster.<code>LIMIT</code> always goes at the very end of the query. Also, it is not supported in all SQL databases. </li>
<li>Limit x,y = limit y offset x 表示的是从第x+1行开始，返回y个数据</li>
<li>SELECT name,<br> CASE<br>  WHEN imdb_rating &gt; 7 THEN ‘Good’<br>  WHEN imdb_rating &gt; 5 THEN ‘Okay’<br>  ELSE ‘Bad’<br> END AS ‘Rating’ #重命名<br>  FROM movies;  CASE-END判断语句</li>
<li>COUNT(1) 可以辅助分组计数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> Country <span class="keyword">IN</span> (<span class="string">'Germany'</span>,<span class="string">'UK'</span>); <span class="comment">#IN 可以从多个元素中找东西</span></span><br></pre></td></tr></table></figure>



<p>要想从一个表中检索多个列，列名之间必须以逗号分隔，但最后一个列名后不加。</p>
<p>使用通配符有一个大优点。由于不明确指定列名（因为星号检索每一列），所以能检索出名字未知的列。</p>
<p>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 </p>
<p>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">50</span> <span class="keyword">PERCENT</span> * <span class="keyword">FROM</span> Customers; <span class="comment">#可以选出前50%的数据</span></span><br></pre></td></tr></table></figure>





<h2 id="计算字段-amp-常用函数"><a href="#计算字段-amp-常用函数" class="headerlink" title="计算字段&amp;常用函数"></a>计算字段&amp;常用函数</h2><p>TRIM/RTRIM/LTRIM 去掉左右的空格</p>
<p>‘+’ 或者|| 可以用来拼接字符</p>
<p>虽然SELECT通常用于从表中检索数据，但是省略了FROM子句后就是简单地访问和处 理表达式，例如SELECT 3 * 2;将返回6，SELECT Trim(‘ abc ‘);将返回abc，SELECT Now();使用Now()函数返回当前日期和时间。现在你明 白了，可以根据需要使用SELECT语句进行检验。</p>
<p>LEFT/RIGHT 返回最左（右）面的字符</p>
<p>SOUNDEX 返回字符串的SOUNDEX值，匹配发音</p>
<p>PI()返回圆周率</p>
<p>GRESTEST 返回最大值</p>
<h2 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h2><ul>
<li>SELECT COUNT(*) FROM Table; 返回一共有多少行</li>
<li>SUM/MAX/MIN/AVG/ROUND</li>
<li>AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。AVG()函数忽略列值为NULL的行。</li>
<li>在用于文本数据时，MAX()返回按该列排序后的最后一行。MAX()函数忽略列值为NULL的行。</li>
<li>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</li>
<li>GROUP BY 按照某一指标分类。后面可以接数字，表示按照SELECT语句中第几个column来分组</li>
<li>When we want to limit the results of a query based on an aggregate property, use <code>HAVING</code>. <code>HAVING</code> statement always comes after <code>GROUP BY</code>, but before <code>ORDER BY</code> and <code>LIMIT</code>. 事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是，WHERE过滤行，而HAVING过滤分组。</li>
<li>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做也算合法，但许多SQL实现不支持，可能会产生模糊的 错误消息。</li>
</ul>
<p>GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</p>
<p>GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子 句中指定相同的表达式。不能使用别名。</p>
<p>大多数SQL实现不允许GROUP BY列带有长度可变的数据类型</p>
<p>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p>
<p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p>
<p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p>
<h1 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h1><p>由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。（直接SELECT FROM x1, x2, x3;）有时，返回笛卡儿积的联结，也称叉联结（cross join）。</p>
<p>目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内联结（inner join）。</p>
<p>SQL允许对表起别名，来允许在一条SELECT语句中多次使用相同的表。（自联结）</p>
<p>OUTER JOIN 允许左边的表的数据在右边的表中没有出现过（这是 LEFT OUTER JOIN的定义，如果是RIGHT OUTER JOIN 就反过来）</p>
<p>还存在另一种外联结，就是全外联结（full outer join），它检索两个表中的所有行并关联那些可以关联的行。与左外联结或右外联结包含一个表 的不关联的行不同，全外联结包含两个表的不关联的行。（MySQL不支持）</p>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>使用UNION很简单，所要做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。如果组合四条SELECT语句，将要使用三个UNION关键字</p>
<p>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。</p>
<p>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
<p>UNION从查询结果集中自动去除了重复的行；换句话说，它的行为与一条SELECT语句中使用多个WHERE子句条件一样。因为Indiana州有一个 Fun4All单位，所以两条SELECT语句都返回该行。使用UNION时，重复的行会被自动取消。这是UNION的默认行为，如果愿意也可以改变它。事实上，如果想返回所有的匹配行，可使用UNION ALL而不是UNION。</p>
<h2 id="Multiple-Tables"><a href="#Multiple-Tables" class="headerlink" title="Multiple Tables"></a>Multiple Tables</h2><ul>
<li>Combining Tables:<br>SELECT orders.order_id,<pre><code>customers.customer_name</code></pre>FROM orders<br>JOIN customers<pre><code>ON orders.customer_id = customers.customer_id</code></pre></li>
<li>默认的join是 inner-join，如果某一行对应的行数据不匹配的话，就把它删掉。left-join 保全先select的table中所有的信息，将后select中没有的信息用missing来填</li>
<li>CROSS JOIN 返回所有可能种排列组合</li>
<li>UNION 相当于r里面的rbind，直接将两个column一样的table上下组合起来</li>
<li>WITH previous_results AS (<pre><code>SELECT ...</code></pre>   )<br>   SELECT *<br>   FROM previous_results<br>   JOIN other_table<br>  ON … = …; WITH可以将运算中生成的新table一起绑起来</li>
</ul>
<p>##Constrains</p>
<p>They can be used to tell the database to reject inserted data that does not adhere to a certain restriction.</p>
<ul>
<li><p>CREATE TABLE celebs (</p>
<p>  id INTEGER PRIMARY KEY,<br>  name TEXT UNIQUE,<br>  date_of_birth TEXT NOT NULL,<br>  date_of_death TEXT DEFAULT ‘Not Applicable’,<br>);</p>
</li>
<li><p><code>PRIMARY KEY</code>: columns can be used to uniquely identify the row.</p>
</li>
<li><p><code>UNIQUE</code> columns have a different value for every row. This is similar to <code>PRIMARY KEY</code> except a table can have many different <code>UNIQUE</code> columns</p>
</li>
<li><p><code>NOT NULL</code> columns must have a value. </p>
</li>
<li><p><code>DEFAULT</code> columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.</p>
</li>
<li></li>
</ul>
<h1 id="Table-Transformation"><a href="#Table-Transformation" class="headerlink" title="Table Transformation"></a>Table Transformation</h1><p>While working with databases, we often need to transform data from one format to achieve a desired result</p>
<h2 id="Subqueries"><a href="#Subqueries" class="headerlink" title="Subqueries"></a>Subqueries</h2><p>A <strong>non-correlated subquery</strong> is a subquery that can be run independently of the outer query and can be used to complete a multi-step transformation. 选择部分只出现在FROM里面</p>
<ul>
<li>SELECT * FROM flights<br>WHERE origin in (<br>SELECT code<br>  FROM airports<br>  WHERE elevation &lt; 2000<br>); 在一个table中以另一个table为选择条件，找出子表</li>
<li>SELECT a.dep_month,<pre><code>a.dep_day_of_week,
AVG(a.flight_distance) AS average_distance</code></pre>  FROM (<pre><code> SELECT dep_month,
       dep_day_of_week,
        dep_date,
        SUM(distance) AS flight_distance
   FROM flights
  GROUP BY 1,2,3
) a</code></pre> GROUP BY 1,2<br> ORDER BY 1,2; 在一个表内做一些选择与统计量计算</li>
</ul>
<p>In a <strong>correlated subquery</strong>, the subquery can not be run independently of the outer query（选择部分出现在SELECT里面）. The order of operations is important in a correlated subquery: </p>
<ol>
<li>A row is processed in the outer query. </li>
<li>Then, for that particular row in the outer query, the subquery is executed.</li>
</ol>
<ul>
<li>SELECT id FROM flights AS f<br>WHERE distance&lt;(<br>  SELECT AVG(distance)<br>  FROM flights<br>  WHERE carrier = f.carrier); 这个AS f 很关键，要不然无法和下面这个select的flights区分开来</li>
</ul>
<h2 id="Set-Operation"><a href="#Set-Operation" class="headerlink" title="Set Operation"></a>Set Operation</h2><p>Merge 2 rows called a join, merge 2 columns called a union.</p>
<ul>
<li>若是想让UNION包含重复的元素，需要在后面加上关键词 ALL</li>
<li>INTERSECT 连接两个SELECT，只包含相同的行</li>
<li>EXCEPT 连接两个SELECT，只包含第一个有第二个没有的行</li>
</ul>
<h2 id="Conditional-Aggregates"><a href="#Conditional-Aggregates" class="headerlink" title="Conditional Aggregates"></a>Conditional Aggregates</h2><ul>
<li>COUNT(CASE WHEN ) 可以返回特定的求和</li>
<li>SELECT    origin,<br>SUM(a.distance) AS total_flight_distance, <pre><code>SUM(CASE WHEN carrier = &apos;DL&apos; THEN distance ELSE 0 END) as total_delta_flight_distance </code></pre>FROM flights AS a<br>GROUP BY origin; SUM的求和要放在Then后面</li>
</ul>
<h1 id="Date-Time-and-String"><a href="#Date-Time-and-String" class="headerlink" title="Date, Time and String"></a>Date, Time and String</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Dates are often written in the following format(同时也是函数名)</p>
<ol>
<li>Date: YYYY-MM-DD</li>
<li>Datetime or Timestamp: YYYY-MM-DD hh:mm:ss</li>
</ol>
<ul>
<li><pre><code>DATETIME(time1, &apos;+3 hours&apos;, &apos;40 minutes&apos;, &apos;2 days&apos;);</code></pre><p>Would return a time 3 hours, 20 minutes, and 2 days after <code>time1</code>.</p>
</li>
<li><p>YEAR(xxx)来返回年份</p>
</li>
<li><p>获取系统日期：CURRENT_DATE()</p>
</li>
</ul>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul>
<li>SELECT (number1 + number2) 直接四则运算</li>
<li>SELECT CAST(number1 AS REAL) 转换格式</li>
<li>SELECT ROUND(number, precision) 取整</li>
<li>MAX/MIN</li>
</ul>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><ul>
<li>A || ‘ ’ || B 用空格连接A和B</li>
<li>REPLACE(string,from_string,to_string) 字符串替换</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加 或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p>为什么要用视图：</p>
<ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。</li>
<li>在编写查询后，可以方便地重用它而不必知道其基本查询细节。 </li>
<li>使用表的一部分而不是整个表。 </li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。 </li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>视图用CREATE VIEW语句来创建。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</p>
<p>视图常见用途：</p>
<ol>
<li>利用视图简化复杂的联结</li>
<li>用视图重新格式化检索出的数据</li>
<li>用视图过滤不想要的数据</li>
<li>使用视图与计算字段</li>
</ol>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<p>有点难 不知道这个具体是干嘛的</p>
<h1 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h1><p>使用事务处理（transaction processing），通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态。</p>
<p>在使用事务处理时，有几个反复出现的关键词。下面是关于事务处理需要知道的几个术语：</p>
<ul>
<li>事务（transaction）指一组SQL语句； </li>
<li>回退（rollback）指撤销指定SQL语句的过程； </li>
<li>提交（commit）指将未存储的SQL语句结果写入数据库表； </li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事 务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</p>
<p>SQL的ROLLBACK命令用来回退（撤销）SQL语句</p>
<p>一般的SQL语句都是针对数据库表直接执行和编写的。这就是所谓的隐式提交（implicit commit），即提交（写或保存）操作是自动进行的。 在事务处理块中，提交不会隐式进行。不过，不同DBMS的做法有所不同。有的DBMS按隐式提交处理事务端，有的则不这样。 进行明确的提交，使用<strong>COMMIT</strong>语句。</p>
<p>要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 在SQL中，这些占位符称为保留点。在MariaDB、MySQL和Oracle中创建占位符，可使用<strong>SAVEPOINT</strong>语句：</p>
<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在。游标（cursor）是一个存储在DBMS服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>不同的DBMS支持不同的游标选项和特性。常见的一些选项和特性如下。</p>
<ul>
<li>能够标记游标为只读，使数据能读取，但不能更新和删除。 </li>
<li>能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。 </li>
<li>能标记某些列为可编辑的，某些列为不可编辑的。 </li>
<li>规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。 </li>
<li>指示DBMS对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Tableau心得</title>
    <url>/2020/07/02/Tableau%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>为了628的presentation，后来741的report也用了。简单画个小图还是挺美观的。教育版免费。</p>
<a id="more"></a>



<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>添加WMS server地图（类似于谷歌地图）：<a href="http://ows.terrestris.de/osm/service" target="_blank" rel="noopener">http://ows.terrestris.de/osm/service</a>?</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>Tableau</category>
      </categories>
  </entry>
  <entry>
    <title>R心得</title>
    <url>/2020/07/02/R%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>老本行，学。</p>
<a id="more"></a>



<h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><ul>
<li>如何画出线性分割图PDA？用R语言我是没整明白</li>
</ul>
<h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><ul>
<li><p>args(mean)—快速查看mean的参数有哪些</p>
</li>
<li><p>example(mean)—看一个mean的实例</p>
</li>
<li><p>&lt;&lt;- 强制赋值给一个全局变量</p>
</li>
<li><p>ls() &amp; ls.str() 可以查看当前工作空间中存在哪些已定义的变量和函数。ls()不会显示以”.”开头的隐藏变量，可通过ls(all.names=T)强制输出所有变量</p>
</li>
<li><p>rm(list=ls())来删除全局所有变量———注意编程的道德规范</p>
</li>
<li><p>逻辑向量进行比较，any() &amp; all() any中有一个为真则输出真，all中全部为真则输出真, purrr包里还有个some和every</p>
</li>
<li><p>想删除向量里面的na/null :  v[!is.na(v) &amp; !is.null(v)]</p>
</li>
<li><p>names函数可以给向量每个分量起名字</p>
</li>
<li><p>欧几里得算法计算两个数的最大公约数：</p>
<p>gcd &lt;- function(a,b){<br>if(b==0) return(a)<br>else return(gcd(b,a%%b))<br>}</p>
</li>
<li><p>卸载软件包: detach(package:MASS)</p>
</li>
<li><p>data() 查看都有哪些内置的数据</p>
</li>
<li><p>near():用来对比两个近似的数是否相等。near(1/49*49,1)</p>
</li>
<li><p>在赋值语句前后加上小括号，可以输出赋值内容</p>
</li>
<li><p>xor(): 异或. &amp;&amp;和 || 只比较两个向量的第一位</p>
</li>
<li><p>log2(),log10(): 以2和10作为底数。作者推荐用2做底数，因为interpret的时候更有利：答案每少1，变换之前的数就比原来少了一半。</p>
</li>
<li><p>lag(), lead(): 将数组向后和向前移动一位。多用于比较 x==lag(x)</p>
</li>
<li><p>cumsum, cumprod, cummin, cummax, cummean. 累积函数</p>
</li>
<li><p>order依次给出第几小的是第几个，sort将数据从小到大排序，rank给出第一个数是第几小的，会把NA放在最后，同样的数用均值来计算rank。min.rank对同样的数会用最小值来计算rank. 更多选项参见?rank</p>
</li>
<li><p>pipe: %&gt;% 相当于「then」 放在一段语句的最后，省去了为中间变量起名的过程，大大缩短了编程时间. Pipe使用的环境不是当前环境而是新创造出来一个临时环境，所以遇到需要当前环境的函数时会产生一些问题。如果pipe的语句超过了10行或者中间有很多的输入输出，那么不建议用pipe</p>
</li>
<li><p>pipe的另外三种：%T&gt;% : return the lefthand side not the righthand side. %$%: 快速从data.frame里面选出某几个变量。%&lt;&gt;%赋值，但是作者不建议这么做，他认为赋值作为一个很重要的过程，值得花费点时间多写几步换来更清楚的代码</p>
</li>
<li><p>表示离散程度的除了sd&amp;var，还有IQR():0.75分位数与0.25分位数的差。mad(x):1.4826*绝对中位差：用原数据减去中位数后得到的新数据的绝对值的中位数。在数据点包含outlier的时候，后两种效果更好。</p>
</li>
<li><p>first(), last(),nth(x,n): 取出向量中特定位置的元素</p>
</li>
<li><p>range()里面有一个参数finite = T 表示去掉这个向量里面的无穷再取range</p>
</li>
<li><p>identical():判断两个向量是否相等。注意integer和double即使数字一样结果也会返回false。所以这时候改用dplyr::near()</p>
</li>
<li><p>switch(status, status1 = … , status2 = …  ): 可以将多个if条件放到一个框里</p>
</li>
<li><p>cut(aaa, 3, dig.lab = 2, ordered = TRUE): 将aaa从小到大变成三个类别，每个类别中小数点后不超过两位</p>
</li>
<li><p>stop(“错误信息”)：在函数或者循环里加上判断错误信息的语句可以让他变得更robust。内置还有一个函数叫stopifnot()</p>
</li>
<li><p>函数里面的变量可以定义成…  ：可以自动match多个无法被其他方式match的输入。</p>
</li>
<li><p>pipable function分为两类：transformation &amp; side-effect：第二种类似于画个图或者写个文件之类的，对原文件不产生影响，那么这些函数返回值会是那个源文件。</p>
</li>
<li><p>R默认的数字类型是double所以要生成integer需要手动在数字后面加上L</p>
</li>
<li><p>is.finite/is.infinite/is.nan/is.na：判断doube类型的四大天王，其中NaN数据会对后两个函数都给出T</p>
</li>
<li><p>NA/NA_real/integer/character_: NA有四种类型，分别代表logical,double,integer,character.</p>
</li>
<li><p>purrr出了is_logical/…/atomic/list/vector: 用来修正自带is.的问题。vector可分成list和atomic。atomic可以分成numeric,logical和character.numeric可以分成double和integer. is_scalar_atomic还可以顺便检查一下长度是否为1.</p>
</li>
<li><p>rep(1:2,3)结果是121212. rep(1:2, each = 3)结果是111222</p>
</li>
<li><p>set_names()给向量起名。</p>
</li>
<li><p>可以为向量添加attributes：attr(data,’Name’)&lt;-‘…’ attributes(x)输出所有的attributes</p>
</li>
<li><p>factors，date-times/times, tibbles都是vector+attributes的结果</p>
</li>
<li><p>mean函数里面的trim参数：从排过序的原始数据中，从数据的两端分别删除floor(trim * length)个数据再进行平均值计算</p>
</li>
<li><p>keep/discard(logical)：只保留那些True/False</p>
</li>
<li><p>detect/detect_index: 返回第一个True的值和第一个True的位置</p>
</li>
<li><p>head_while/tail_while: 从开头/结尾开始返回连续的所有True的值，如果开头/结尾就是False则返回0.</p>
</li>
<li><p>reduce: Reduce a list to a single value by iteratively applying a binary function</p>
</li>
<li><p>accumulate: Accumulate recursive folds across a list</p>
</li>
<li><p>broom::glance: 对一个fit作用，给出各种参数指标(精简版summary)。tidy给出系数，augment给出原数据加上残差等一系列统计指标</p>
</li>
<li><p>J是矩阵的subsetting   ?????</p>
</li>
<li><p>多维正态联合分布：mvrnorm</p>
</li>
<li><p>多个因子变量进行对比可以用contrasts(z)</p>
</li>
<li><p>substr可以取字符的首字母substr(“china”,1,1)</p>
</li>
<li><p>typeof比mode更新，但class返回的是当前状态下他是一个什么类型</p>
</li>
<li><p>sub(pattern= ‘\,‘ ,replacement=’’, y) 表示将字符串y里面所有的”,”去掉第一个，gsub全局去掉。</p>
</li>
<li><p>bootstrap产生数据保存到一个list里面：f&lt;-function(m) sapply(1:m,function(o) sample(X,replace = TRUE)) ; b&lt;-f(1000)</p>
</li>
<li><p>f&lt;-Vectorize(f) 使一个函数可以进行向量化运算</p>
</li>
<li><p>m&lt;-optimize(f,interval=c(1,4),maximum=TRUE)[[2]] 给出一维函数在某段区间的最大或者最小值</p>
</li>
<li><p>产生一个异质（元素类型不同）的矩阵：从一个异质的列表开始，赋予它维数。</p>
</li>
<li><p>在向量中间插入数据：append(oldvec,newvalues,after=n) 表示在第n个数据后插入新的一个元素</p>
</li>
<li><p>合并几组向量形成一个list：list(com1=v1,com2=v2,com3=v3)  可以用stack将全是向量的list变成一个一列的长向量</p>
</li>
<li><p>从列表中移除取值为空值的元素： lst[sapply(lst,is.null)] &lt;- NULL 赋予NULL是删除列表元素的一种方法</p>
</li>
<li><p>lapply与sapply都可以对列表进行操作，不同点是前者返回一个列表，而后者返回一个向量</p>
</li>
<li><p>矩阵可以通过添加参数 byrow=TRUE 来使数据按行排列</p>
</li>
<li><p>从矩阵中取出一行/一列矩阵：而不是取出一行数据： row&lt;-matrix[1,,drop=FALSE]</p>
</li>
<li><p>若obs是一个列表的列表而不是数据框列表：Map(as.data.frame,obs)变成数据框列表. Map是对向量的操作的函数（可能list本质上是一个向量吧）</p>
</li>
<li><p>反复调用一个函数用replicate</p>
</li>
<li><p>删除一个包detach(‘package: …’)</p>
</li>
<li><p>rnorm函数中输入的是sd而不是var</p>
</li>
<li><p>sweep 将输入的向量减去一个统计量（可以是mean或者其他…）</p>
</li>
<li><p>proc.time()获取代码运行时间</p>
</li>
<li><p>factorial(n)返回n的阶乘</p>
</li>
<li><p>win.graph可以调整图片大小，但是只能在windows上面用，dev.new不限平台</p>
</li>
<li><p>pander 专门用来打印的？</p>
</li>
<li><p>seq_along() 产生对应长度的index</p>
</li>
<li><p>which(dis==min(dist(dat2)), arr.ind = T) 返回特定元素在矩阵中的index</p>
</li>
<li><p>对于一些大数，可以先做log变换再变回去。lgamma(x)可以算log(gamma(x))</p>
</li>
<li><p>返回一个向量的最大值位置，用order然后看最后一位</p>
</li>
<li><p>dist计算多维距离的时候，对于某一个位置如果有NA的话，会默认用其他位置距离的平均值来impute</p>
</li>
<li><p>非参拟合可以用smooth.spline 报错tol的时候一般是因为x只有1个，一般来说至少有四个不同的x才可以正常运行</p>
</li>
</ul>
<p><strong>System.time</strong>: How to interpret the reported times user, system, and elapsed：</p>
<ul>
<li><p>Well, clearly <code>elapsed</code> is the <strong>wall clock time</strong> taken to execute the function, plus some benchmarking code wrapping it </p>
</li>
<li><p>“User CPU time” gives the CPU time spent by the current process (i.e., the current R session) </p>
</li>
<li><p>“system CPU time” gives the CPU time spent by the kernel (the operating system) on behalf of the current process. The operating system is used for things like opening files, doing input or output, starting other processes, and looking at the system clock: operations that involve resources that many processes must share. Different operating systems will have different things done by the operating system.</p>
</li>
<li><p>为什么有时候elapsed time远远大于其他两个之和？<a href="https://stackoverflow.com/questions/13688840/what-caused-my-elapsed-time-much-longer-than-user-time" target="_blank" rel="noopener">https://stackoverflow.com/questions/13688840/what-caused-my-elapsed-time-much-longer-than-user-time</a></p>
</li>
<li><p>为什么有的时候<a href="https://stackoverflow.com/questions/18654497/mclapply-user-time-larger-than-elapsed-time" target="_blank" rel="noopener">user time larger than elapsed time</a></p>
</li>
<li><p>table函数等价于python里面的Counter()</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">methods(print) <span class="comment"># print 本身先判断数据类型，再给出不同的print做法</span></span><br></pre></td></tr></table></figure>

<p>如果想取出特定summary中的某一部分，可以<u>用str先看一下structure</u>，确定好位置之后再直接输出。</p>
<p><a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/hexmode.html" target="_blank" rel="noopener">10-16 base转换</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data %&gt;%</span><br><span class="line">	`colnames&lt;-`(c(<span class="string">"Population"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>)) <span class="comment">#Pipeline 里面改column name</span></span><br></pre></td></tr></table></figure>

<p>当前的包安装不上的时候：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">'/Users/moran/Desktop/Epi_2.33.tar.gz'</span>,repos = <span class="literal">NULL</span>, type=<span class="string">"source"</span>)</span><br></pre></td></tr></table></figure>

<p>tryCatch里面赋值的时候，要用&lt;&lt;-而不是&lt;-</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><p>在使用for循环的时候，<strong>如果给output预先分配好空间的话，那么整体的运行速度会快很多</strong>，这里可以使用vector(mode = ‘logical’, length= 12).</p>
</li>
<li><p>可以用函数seq_along(n)来代替 1:n 来规避n=0的时候的错误</p>
</li>
<li><p>以后不要在循环里面写出c(当前，新内容)这种效率低的语法，可以先把结果存在一个list里面，然后再使用unlist，list的空间也要先赋好。purrr::flatten_dbl()更严格，如果不是一个double的list会报错。如果是字符型的，用paste(output, collapse = “”)。如果是一堆列向量，用dplyr::bind_rows(output)</p>
</li>
<li><p>多多使用while语句（simulation中常用，针对循环次数不确定，但是一个标准确定的时候）。所有for都可以改成while但是不是所有while都可以改成for</p>
</li>
<li><p>函数嵌套函数，apply系列的替代函数：map():list. map_lgl/int/dbl/chr 分别对应的不同数据类型</p>
</li>
<li><p>map+pipe时，遇到自定义函数可以用map(~lm(mpg ~ wt, data = .))来代替map(function(df) lm(mpg ~ wt, data = df))</p>
</li>
<li><p>例子：models %&gt;%   map(summary) %&gt;%   map_dbl(~.$r.squared) 最后一个可以替换成 map_dbl(“r.squared”)</p>
</li>
<li><p>有时候一个循环的一部分出了错，但是整个程序中那些正确的值也无法输出，这时候我们用safely()这个函数可以返回一个二维列表，第一列是result，第二列是error。如果最后输出结构太复杂可以用transpose()来修正。</p>
</li>
<li><p>在我们不想知道为什么错了的时候可以用possibly(原函数, 「替」)这样的话只要报错，都用「替」来替代</p>
</li>
<li><p>还有一个函数叫quietly(): 跟safely差不多，输出的结果更简单清晰。</p>
</li>
<li><p>当我们迭代的变量大于一个的时候，用pmap()。两个的时候是map2()</p>
</li>
<li><p>当我们迭代的是函数而不是变量的时候：invoke_map(f, parameter)</p>
</li>
<li><p>walk/walk2/pwalk：call a function for its side effect rather that its return value.</p>
</li>
<li><p>.Last.value  最近的一个计算结果</p>
</li>
<li><p>source(“”) 可以读取文本文件(.R后缀的文件)并执行其内容  可选参数：echo=TRUE ——在执行的同时显示源代码</p>
</li>
<li><p>print(pi,digits=4) / cat(format(pi,digits=4),”\n”) 可以改变输出数据的位数，format是用来设定数据的格式</p>
</li>
<li><p>cat(“…”,file=”filename”)  来使输出结果到filename的文件里，不过如果反复使用，要加append=TRUE。改进则要使用到文件的链接，且无需append=TRUE： con&lt;-file(“..”,”w”)  cat(data,file=con)</p>
</li>
<li><p>list.files()  显示当前工作目录里面的文件</p>
</li>
<li><p>save(data,file=”filename”) 存为一个二进制文件 </p>
</li>
<li><p>dput(data,file=”filename”)  存为一个ASCII码文件，操作是将该数据以structure函数的方式打印，直接拷贝再赋值给其他变量即可，reproduce the data。</p>
</li>
<li><p>dump(“data”,file=”filename”) 与dput效果一样，只是多了一组引号</p>
</li>
<li><p>next = continue break = break</p>
</li>
</ul>
<h1 id="画图："><a href="#画图：" class="headerlink" title="画图："></a>画图：</h1><ul>
<li>plot(cex=0.2) 调整数据点大小</li>
<li>一个例子：curve(sin(x),from=-10,to=10,ylim=c(-2,2),main=”函数sin(x)”,col=”red”,lty=3,lwd=2,ylab=”y轴sin(x)”)<br>abline(h=1);abline(h=-1)</li>
<li>hist(freq=F)输出density密度 freq=T 输出frequency频数</li>
<li>chull画凸形</li>
<li>将图片和文字打印到pdf里：pdf(‘file’); plot(….) ; gridExtra::grid.table(data.frame); dev.off()</li>
<li>plot.new() 打印空白图片</li>
</ul>
<p><a href="https://www.stat.ubc.ca/~jenny/STAT545A/block14_colors.html" target="_blank" rel="noopener">16进制颜色介绍</a></p>
<p>将数字转成16进制可以用as.hexmode()这个函数，R=G=B这个颜色将是黑(0)灰白(255)</p>
<p><a href="https://www.rapidtables.com/web/color/html-color-codes.html" target="_blank" rel="noopener">HTML文件中的颜色</a></p>
<p><a href="http://www.sthda.com/english/wiki/visualize-correlation-matrix-using-correlogram" target="_blank" rel="noopener">corrplot</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">guides(fill = guide_legend(reverse = <span class="literal">TRUE</span>)) <span class="comment"># 翻转legend顺序 离散</span></span><br><span class="line">guides(colour = guide_legend(reverse=<span class="literal">T</span>)) <span class="comment"># 翻转legend顺序 连续</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/11774703/adding-text-to-a-grid-table-plot" target="_blank" rel="noopener">如何在打印table并且加上title和footnote?</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 想以一个data.frame的每一列为变量画图，想加图例(并且调整图例的顺序)</span></span><br><span class="line">df &lt;- data.frame(x1 = rnorm(<span class="number">100</span>),x2 = rnorm(<span class="number">100</span>)-<span class="number">0.5</span>, x3 = rnorm(<span class="number">100</span>)+<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ggplot(df)+</span><br><span class="line">  geom_density(aes(x = x1, fill = <span class="string">'liu'</span>),alpha = <span class="number">0.2</span>)+</span><br><span class="line">  geom_density(aes(x = x2, fill = <span class="string">'yu'</span>),alpha = <span class="number">0.2</span>)+</span><br><span class="line">  geom_density(aes(x = x3, fill = <span class="string">'meng'</span>),alpha = <span class="number">0.2</span>)+</span><br><span class="line">  scale_fill_manual(yumeng,values=c(liu=<span class="string">"red"</span>, yu=<span class="string">"blue"</span>, meng=<span class="string">"purple"</span>), breaks = c(<span class="string">'liu'</span>, <span class="string">'yu'</span>, <span class="string">'meng'</span>))<span class="comment"># breaks用来调整图例的顺序</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rug 在基本图中添加数据点所对应的横纵坐标小竖线</p>
</li>
<li><p>geom_bar + errorbar 想画横线在上下：<a href="https://stackoverflow.com/questions/35424162/problem-placing-error-bars-at-the-center-of-the-columns-in-ggplot" target="_blank" rel="noopener">如何对齐</a> <a href="https://stats.stackexchange.com/questions/8137/how-to-add-horizontal-lines-to-ggplot2-boxplot" target="_blank" rel="noopener">如何加横线</a></p>
</li>
</ul>
<p><a href="https://stackoverflow.com/a/18055838" target="_blank" rel="noopener">保存ps半透明图片</a></p>
<h2 id="GGplot："><a href="#GGplot：" class="headerlink" title="GGplot："></a>GGplot：</h2><p>分为七个主要部分：dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.</p>
<ul>
<li>ggplot(data=<data>):负责创建坐标系，之后的图会贴在上面。</li>
<li>aes()里面的可调参数有x, y, color, alpha(color的黑白版), size(单位mm), shape(一个图最多6个，共有0-24种), group(单纯的分组而不加区别)</li>
<li>如果不是想按照某个变量来分组，而是想对所有数据进行统一操作，需要将命令放在aes外面，整个函数里面。</li>
<li>stroke=num: 点的边界宽度</li>
<li>注意连接函数的加号不能放在新一行的开头，要放在旧一行的结尾</li>
<li>facet_wrap(~class, nrow=) 将原有的plot根据class来分成小图</li>
<li>facet_grid(A~B) 将原有的plot根据AB来分成行列小图（A可以为.）这样就变成了nrow=1的facet_wrap</li>
<li>show.legend=FALSE 放在整个函数里面，隐藏图例</li>
<li>可以将geom的函数共同的mapping挪到ggplot函数里面，也可以在随后的函数中重新定义mapping（改变setting）甚至是data（取子集）来覆盖或者增添条件。</li>
<li>coord_flip()坐标系转置（常用于转置箱型图以及处理x名字过长）</li>
<li>coord_quickmap()自动选择x-y的合适比例</li>
<li>coord_polar()极坐标</li>
<li>labs(x=, y=, title=, subtitle=, caption=(底注)) 添加注释，只要是一切能改的</li>
<li>如果想打印数学符号，可以用quote()，更多数学语言的包尽在plotmath</li>
<li>count(data,cut_width(num)): 把关于连续变量的密度图以特定宽度统计个数, cut_number则是以特定数据量进行划分。</li>
<li>coord_cartesian(ylim=c(0,50)):  在画条形图的时候有的x观测量相对之下超小，在图上难以观察，于是用这个函数可以将很矮小的条拉起来。</li>
<li>改变图例的展示方式：guides/guide_legend/guide_colourbar</li>
<li>有时候我们对数据进行log变换，但是这样的话axes就变得不好解释，所以我们可以选择对x和y轴的scale进行变换：scale_x_log10()</li>
<li>theme(legend.position = “none”) 将图例去掉，分散在图中。一般来说position可以取left/right/top/bottom。还有很多其他的theme比如theme_bw（background-white）</li>
<li>colorbrewer这个包针对色盲人群做了优化</li>
<li>如果想对固定颜色种类：scale_colour_manual(values = c(Republican = “red”, Democratic = “blue”))</li>
<li>scale_color_x / scale_fill_x(x还可以特别设为gradient/gradient2/viridis)</li>
<li>ggsave可以保存最近的一张图片，但是大小尺寸都是根据当前窗口自适应的，不是很reproducible，所以我们最好自己固定尺寸</li>
<li>如果想画多个图在一个画板上。将每一个ggplot保存成p1-p4. gridExtra::grid.arrange(p1, p2, p3, p4, ncol=2)</li>
<li>如果想用颜色区分多条线并且加图例：aes(x=x,y=y3,color = ‘y3’) </li>
<li>想自定义颜色的话：scale_colour_manual( values=c(‘springgreen4’, ‘tomato3’, ‘lightskyblue’,’orange’))</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">linetype=<span class="string">"dotted"</span> <span class="comment">#可以决定线的形状</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">annotate(<span class="string">"text"</span>, x = <span class="number">7.5</span>, y = <span class="number">0.9</span>, label = <span class="string">"ratio = 96%"</span>) <span class="comment"># 在图中标记注释</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">theme(panel.background = element_rect(fill = <span class="string">'blue4'</span>), panel.grid.major =element_blank(), panel.grid.minor = element_blank()) <span class="comment">#可以改变背景色+网格</span></span><br></pre></td></tr></table></figure>

<p><a href="https://ggplot2.tidyverse.org/reference/theme.html" target="_blank" rel="noopener">更改theme 比如说字体方向等…</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">scale_fill_discrete(name = <span class="string">"Group Mean"</span>) <span class="comment">#更改legend title</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">scale_x_discrete(limits=c(<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>)) <span class="comment"># 可以改变X轴顺序</span></span><br></pre></td></tr></table></figure>

<p><a href="https://rpkgs.datanovia.com/ggpubr/reference/ggpar.html" target="_blank" rel="noopener">ggpubr</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">theme(axis.text=element_text(size=<span class="number">12</span>),</span><br><span class="line">        axis.title=element_text(size=<span class="number">20</span>)) <span class="comment"># 调大坐标轴字体</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">facet_wrap(~variable,ncol=<span class="number">4</span>,scales=<span class="string">"free"</span>)+ <span class="comment"># 根据variable直接画出多个图而不用grid.arrange</span></span><br><span class="line">  theme(strip.text.x = element_text(size = <span class="number">30</span>)) <span class="comment"># 调整facet_wrap的变量字体</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/46783163/r-ggplot2-boxplots-with-wilcoxon-significance-levels-and-facets-show-only-sig" target="_blank" rel="noopener">Stat_compare_mean如何只画出来显著的变量</a></p>
<h2 id="geom系的函数："><a href="#geom系的函数：" class="headerlink" title="geom系的函数："></a>geom系的函数：</h2><ul>
<li>geom_smooth() 拟合图，method中可选lm, glm, loess… aes中可选linetype=class 来对不同的class进行分别拟合. se=T/F来控制是否画出线周围的灰色置信区域。span越大，拟合图就越光滑</li>
<li>geom_bar()个数柱状图, 可以修改stat=选择其他统计量.bar函数默认的stat是count，同样的，stat_count函数的默认geom也是bar，这种情况下，可以用stat_count来代替geom_bar。color选择外框颜色，fill选择填充颜色(可以等于其他变量，画出分层色彩的柱状图。也可以等于NA，就是不涂色)。<a href="https://stackoverflow.com/questions/30183199/ggplot2-plot-mean-with-geom-bar" target="_blank" rel="noopener">Plot Group Mean</a></li>
<li>bar中position=（identity：每种类别都画出具体位置，但比如有的最小值小于其他的最大值，就会导致重叠的问题。fill：将所有集合都变成高度1，然后内部填充颜色，有助于比较不同集合之间的成分比例。dodge：每个集合都是好几个小柱状图，解决了重叠的问题。Jitter：给每个数据点加一个小随机误差，解决over-plotting问题）</li>
<li>stat_summary()对于每种类别画出一条垂直的竖线，两个端点和中间一个黑点代表着最大值最小值和中位数/均值</li>
<li>geom_jitter()等同于geom_point(position=’jitter’)</li>
<li>geom_count也是来解决over-plotting的，把数据重合点用一个更大的点来表示。也用来画出两个因子变量的联合图</li>
<li>geom_freqpoly(): 另一种密度图像，用线来代替条形。有时候各个类别的个数相差很多，而如果我们想看类别内的分布情况，需要标准化，在ggplot主函数的mapping中令aes(x=price,y=..density..)这样每条线下面的面积都是1</li>
<li>geom_boxplot()：对于无序的变量，可以用reorder(x,y,FUN=median)来根据中位数从左至右排序,varwidth=T用来使每个箱型图的宽度与数据量成正比 <a href="https://stackoverflow.com/questions/33524669/labeling-outliers-of-boxplots-in-r" target="_blank" rel="noopener">如何加outlier的label</a></li>
<li>geom_tile(mapping=aes(fill=n)) 为count填色</li>
<li>geom_bin2d geom_hex 都是对两个连续变量画出分块密度图。前者是方形，后者是六边形（需要安装包hexbin）。</li>
<li>geom_ref_line(h = ?): 添加一条白色指示线</li>
<li>geom_text()是geom_point的扩展板，带个label可以在点附近写东西</li>
<li>geom_label(nudge_y=？)将geom_text里面的文字外面套了一个矩形框，可以将矩形框上移？个单位</li>
<li>但是以上两种geom都解决不了重叠的问题，这时候就要用到ggrepel::geom_label_repel 再配合一下给对应的点圈出来，就很清晰了</li>
<li>geom_rect(xmin,xmax,ymin,ymax): 框住兴趣点</li>
<li>geom_segment(x,y,xend,yend): 画一个箭头</li>
<li>scale_name-of-the-aesthetic_name-of-the-scale: scale一般都会默认选，除非要改变default。scale里面两个重要的参数breaks=和labels = NULL对axes进行操作</li>
<li>geom_vline(): 添加一条竖线</li>
<li>geom_errorbar(aes(ymin=len, ymax=len+sd), width=.2, position=position_dodge(.9))  柱状图中画出置信区间</li>
</ul>
<p><a href="https://ggplot2.tidyverse.org/reference/scale_grey.html" target="_blank" rel="noopener">如何画出灰色图片</a></p>
<p><a href="https://stackoverflow.com/questions/30183199/ggplot2-plot-mean-with-geom-bar" target="_blank" rel="noopener">geom_bar画出groupmean</a></p>
<h2 id="ggpubr"><a href="#ggpubr" class="headerlink" title="ggpubr"></a>ggpubr</h2><p>ggboxplot(data = dat_tmp,x = ‘X’, y = ‘Y’, color = ‘X’, palette = ‘set1’, add = “jitter”,outlier.shape = NA)</p>
<ul>
<li>Add = jitter 可以画出所有点</li>
<li>但是有了add = jitter之后 离群的点会出现两次，outlier.shape = NA 可以只显示一次</li>
</ul>
<h1 id="数据基本处理："><a href="#数据基本处理：" class="headerlink" title="数据基本处理："></a>数据基本处理：</h1><ul>
<li><p>as_tibble(): 将data.frame变成tibble</p>
</li>
<li><p>tibble(x=…, y=…, z=…)：直接生成tibble</p>
</li>
<li><p>print(tibble, width = Inf)这样在打印的时候会把所有列都打出来</p>
</li>
<li><p>tribble：复杂一点但是易读懂的tibble生成方式。<del>x,</del>y,~z  ‘a’,2,3,’b’,4,5…</p>
</li>
<li><p>取某一列的时候可以用$也可以用[]来取出tibble, [[]]来取出数据。如果用pipe方式的话需要加一个点。data %&gt;% .$x</p>
</li>
<li><p>enframe(): 将一个列变量变成一个两列的tibble，有名字的话名字变成第一列，没有的话将第二列复制一遍放在第一列</p>
</li>
<li><p>deframe(): 干的事情和enframe相反，讲一个两列的tibble变成一个向量，第一列被当成名字</p>
</li>
<li><p>data &lt;- read.table(“”,sep=”\t”,header=T,fileEncoding=”UCS-2LE”) 把数据从excel里面拷到txt必须这么输入，要不然会有隐藏字符看不到</p>
</li>
<li><p>read.table() 参数：stringAsFactor=F 不将字符转化为因子  na.strings=”.”  缺失值在这组数据中以”.”来标记  注意read.table默认header=F</p>
</li>
<li><p>scan(“filename”,what=list(data=character(0),high=numeric(0)))</p>
<p>其他参数： n=number nlines=number skip=number na.strings=list 分别表示读取number个数据后停止，读取number行后停止，先跳过number行在读取，将list中的字符串解释为na。scan可以从网页中读取数据</p>
</li>
<li><p>load(‘file’)从本地读进去一个数据。一般都是以.Rdata结尾。.Rdata也是save语句的默认格式</p>
</li>
</ul>
<p>tally 统计group mean</p>
<h2 id="tidyr"><a href="#tidyr" class="headerlink" title="tidyr"></a>tidyr</h2><ul>
<li>gather(xxx, key = ‘a’, value = ‘b’): 如果在tibble的第一行存在一些数据而非数据名（就像2*2联表中的列那样），那么我们就把这些数据放在xxx的位置，为他们产生一个新变量叫做a，而原本的数据框里面的数据也有了一个新的名字叫做b，这样就把这些数据所在的列变成了两列，a和b。可以添加na.rm=T参数</li>
<li>spread(data, key = ‘a’, value = ‘b’): 针对有些时候某一列a中包含的都是变量名，而b列分别存了这些变量的值，所以我们只用这两个参数就可以把数据清洗干净。</li>
<li>separate(data, col1, into = c(‘col2’, ‘col3’), sep = ‘/‘): 若有一列中包含了两列的数据，并且用’/‘字符分隔的，那么我们可以用这个函数将col1分成col2和col3. 如果我们不确定是怎么分割的，可以将sep换成convert = TRUE，我们还可以给sep附一个数字向量，他会在对应的位置进行分割</li>
<li>unite(colnew, col1, col2, sep=’’): 将原来的col1和col2合并成colnew</li>
<li>complete(data,col1,col2): 将col1和col2的所有组合都检查一遍，如果没有的就添加成NA</li>
<li>fill(data, col): 有时候的NA出现是因为想表示这些空的数据跟上面的数据一样，所以就不用再写一遍了。这时候我们可以用fill来告诉计算机col列所有的NA都用在它上面离它最近的数据填充</li>
</ul>
<h2 id="readr"><a href="#readr" class="headerlink" title="readr"></a>readr</h2><ul>
<li>read_csv():逗号分隔。read_csv2()：分号分隔。read_tsv():tab分隔。read_delim()：不管什么分隔都ok。read_fwf()：固定宽度文件（可用里面的参数fwf_widths()来固定宽度，或fwf_positions()来确定位置）read_table():列和列之间用空格分隔。read_log()：apache style还不懂这是什么</li>
<li>read_csv: 默认是把第一行作为列名，所以如果我们不想要开始的n行：skip=n, 我们不想要开头带井号的行：comment=’#’，或者直接这些数据都没有名字：col_names=F. 或者可以col_names=c(…)来创建新的名字. na=’’告诉计算机这个文件中na是以什么方式存下来的。</li>
<li>parse_*(): *可以为logical, integer, double, number, character , factor, datetime, time, date : 将输入的字符转换成其他格式，如果有错的话，可以用problem()来查看为何出错</li>
<li>对于number来说，各个国家地区的书写方式不同，如果小数点不是.而是’,’ 那么我们可以在最后加上，locale = locale(decimal_mark = ‘,’) 同时parse_number()这个函数忽略掉数字前和后的字符，所以如果是123.45，点之后的45会被忽略掉，读成123. 而$100也会读成100. 最后，如果是像美国这种每三个数字就加一个逗号的问题，number可以解决，而对于除了逗号其他的组间分隔符，要用parse_number(‘…’, locale = locale(grouping_mark = ‘?’))</li>
<li>对于strings来说，问题就只有编码的不同产生的问题。现在大家都用UTF-8，但是一些老文件可能不是。所以如果我们知道这些字符的编码，可以用parse_character(… , locale = locale(encoding = ‘某种编码’)) 如果我们不知道编码的话，可以用内置函数来猜。guess_encoding(charToRaw(‘char’)) 其中charToRaw是将char变成源代码。当然大部分情况下他们也猜不准，除非数据量很大。</li>
<li>关于时间。date返回从1970-1-1以来的天数。date-time返回从1970-1-1以来的秒数。time返回从前一天晚上12点到现在的秒数. date-time接受八位加T加六位的字符。date接受八位，time接受六位。（都是默认，可以根据情况不同而有所调整）。关于时间还有很多灵活地参数表示，这里先不说了…R4ds书上P135有说到。</li>
<li>guess_parser()来猜测某个字符是什么类型。parse_guess()用猜测的类型进行parse</li>
<li>readr工作的时候会选取前1000列来guess（代码中guess_max=1000），再用guess的结果进行parse，但有时候前1000行不具有代表性，所以问题就来了，这时候我们可以用problems(x)或者stop_for_problems(x)进行查验，并对col_types = cols(x=col_double()…) 放入readr中重新读。因为readr只查前1000，我们也可以用tail(data)来检验一下最后的几条数据看看是否符合预期。有时我们也用col_types = cols(.default = col_character()) 全部读成character，再用type_convert进行修正。</li>
<li>写出函数：write_csv(), write_tsv(). 默认采用UTF-8编码。如果我们想输出一个CSV文件给excel 可以用write_excel_csv()会在文件的开头告诉excel我们是用UTF-8进行编码的。但是以上类型会在有NA的时候出一些小问题。这里我们引入一种专为R应用的函数write_rds()&amp;read_rds(),文件也要以rds为后缀。还有一种方法是所有编程语言通用的feather格式。write_feather()和read_feather()同样需要后缀为feather.</li>
<li>其他格式：haven:读spss和sas文件。readxl：读xls和xlsx文件。DBI（以及RMySQL，RSQLite，RPostgreSQL）可以对数据跑SQL语句并且返回一个data.frame. jsonlite: for JSON. xml2: for XML</li>
<li>readfwf :像SAS一样按照固定的格式读取文件：fixed with format</li>
</ul>
<p>##dplyr:</p>
<ul>
<li>tibbles格式是一种特殊的data.frame(四种基本格式：int整数，dbl实数，chr字符，dttm日期加时间，lgl逻辑，fctr类别，date日期)</li>
<li>between(x,left,right): 判断x是否大于等于left小于等于right，返回逻辑值</li>
<li>rename(data, new_name=old_name) : 对列改名</li>
<li>inner_join对于key只在x或者y的数据予以删除。outerjoin中left_join保留x中所有，right_join保留y中所有，full_join保留全部。</li>
<li>对于left_join.如果key是一对一，一对多，多对一都ok。但是如果是多对多的时候，会产生笛卡尔积。</li>
<li>left_join选择key的方式，默认是by = NULL 即对xy所有重合的列名进行join，第二种by=c(‘col’)根据选定的key进行join，第三种by=c(‘a’=’b’)对于x中的a和y中的b进行比较。</li>
<li>merge(x,y, all.x = T, all.y = T)和join系列效果一样，只不过join系列一是看得清楚，二是算得快并且不容易出错。SQL也能做，但是看不懂，先不嗦了</li>
<li>semi_join(x,y) 保留x中所有match了y的观测值。anti_join(x,y)丢掉x中所有match了y的观测值</li>
<li>intersect() ,union() ,setdiff(x,y). 最后一个函数返回x\y .集合语言可以对tibble的观测值进行作用</li>
</ul>
<p>###六种基本函数</p>
<p>格式：第一个位置放置data.frame，后面的都是用不加引号的变量名对数据进行操作，最后返回一个data.frame。</p>
<ul>
<li>filter():根据变量筛选观测值集合. 注意filter会自动去掉逻辑式中False和NA的观测值，如果需要保留NA，则要使用is.na() | xxx</li>
<li>arrange()：将观测值以某些指标进行排列.默认升序，降序用desc(col.names). NA会被放在最后</li>
<li>select()：选出特定变量. -(name1:name2) 表示去掉name1到name2中间的全部列。还可以用其他辅助函数：starts_with(‘xx’), ends_with, contains(), matches(‘’)满足特定正则表达式，num_range(‘x’,1:3)选出x1,x2和x3, one_of(vars)选出字符表示的列名集合（但我发现不用one_of直接对vars进行select也OK）。式子最后加上everything()：把前面选择的变量移到列的最前面，相当于不仅选出了特定变量，还补上了其他未选择的变量。如果想区分大小写，在match类函数里面添加：ignore.case=F</li>
<li>mutate()：根据已有变量产生新变量. 如果只想保留新变量，使用transmute(). 将一些异常(大于0的)观测值填写成NA：mutate(y=ifelse(y&gt;0,NA,y))</li>
<li>summarize()：将多个变量浓缩成一个统计量, 常与group_by连用. 里面的函数n()返回观测值的个数，n_distinct()返回不同的观测值的个数。计数还可以用count(,wt=…)代替summarize()</li>
<li>group_by()：将命令对每个分组作用, 想去掉分组用ungroup(). </li>
<li>nest：常与group_by连用，在tibble里面生成小tibble.使用unnest(data, varaible) 来变回常规tibble. 还有一个用法是nest(col1:col2): 将col1到col2中间的列都捆绑起来</li>
</ul>
<h1 id="stringr字符"><a href="#stringr字符" class="headerlink" title="stringr字符"></a>stringr字符</h1><p>很多stringr的函数都有第二个版本_all ：works with all matches</p>
<p>stringi包是stringr的扩充版，函数从42个增加到了234，遇到了棘手的问题可以试着从stringi中找一下，函数名称的开头也会变成stri_…</p>
<ul>
<li>有时候console里面打印出来的字符不是他本来的样子，要用writeLines()</li>
<li>r4ds作者建议用双引号来引用字符。</li>
<li>?”‘“ 或者 ?’”‘ 都可以来查看一系列关于各种字符的表达</li>
<li>str_length(): 求字符长度</li>
<li>str_c()：combine字符，相当于paste。如果想让NA变成字符型的NA打印或者操作，使用str_replace_na(x)。把一个字符向量变成一个字符：collapse = “,”</li>
<li>str_sub(str, start, end): subsetting，注意这个str_sub不是创建了一个新的变量而是提供指针，这样的话如果你对sub之后的字符进行了修改，那么原来的字符也会被修改</li>
<li>str_to_lower()/ str_to_upper()/str_to_title: 全部变成小写/大写/首字母大写。但是不同语言的大小写可能略有不同，需要通过locale = “en” 来获得robust的结果。str_order和str_sort比起原生的排序也是多了locale可以选择。</li>
<li>str_trim(): 去掉字符开始和结尾的空格。</li>
<li>str_wrap(): 把字符变成一个格式化段落</li>
<li>str_view(x,’match’): 用来可视化匹配结果</li>
<li>str_detect(): 判断是否匹配，返回逻辑值</li>
<li>str_count(): 返回一个数字，匹配了多少次。注意match不会重叠。str_count(“abababa”, “aba”) <em>#&gt; [1] 2</em>  而不是三个</li>
<li>str_subset(): 选出匹配的字符们</li>
<li>str_extract(): 将Match的部分提取出来（默认值是第一个match的）。如果想提取出来所有的match，用str_extract_all()会返回一个列表，可以加上simplify = T 就会变成一个矩阵，宽度用NA填补成最长宽度来对齐。</li>
<li>str_match()&amp;all: 分组匹配，返回一个矩阵。第一列是str_extract的所有组合在一起的完整内容，后面每一列是每一组分别的内容。如果数据集是一个tibble，可以用tidyr::extract(tibble, name-of-matches, matches, remove = F)来代替str_match.(remove的意思是是否删除原tibble)</li>
<li>str_replace()&amp;all: 用给定字符替换匹配字符。可以用c(‘match1’=’new1’,…)来建立一个多维替换。还可以用分组的方法调换位置。str_replace(“([ ^ ]+) ([ ^ ]+)”, “\\2 \\1”)</li>
<li>str_split(“分隔符”): 进行切割，返回一个list。可用simplify = T 来返回一个Matrix。参数n=几，可以固定最多切成几份。可用boundary(“word”)作为match来选中所有的单词而忽略标点以及空格。</li>
<li>str_locate()&amp;all: 返回每个match的开始和结束位置</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>. 匹配任何字符（except a newline）但是我们如果只想匹配”.”这个字符，需要变成「\\.」第一个斜杠告诉计算机我们现在是特殊字符，第二个斜杠保护了”.”不会单独出现。想要match一个「\」我们需要用四个「\」</li>
<li>锚定：”^”从字符的开始进行匹配，”$“从字符的结尾开始匹配：记忆口诀：<em>if you begin with power (<code>^</code>), you end up with money (<code>$</code>).</em> 如果想让正则表达式只匹配全字符，可以同时加上^和$。</li>
<li>match the boundary between words with \b</li>
<li>\d: 匹配一个数字。\s: match white space（space/tab/newline）\S:匹配所有非空白 [abc]: match a,b, or c. [ ^abc]: match anything except a,b, or c. 注意前两个带斜杠的在match的时候都需要再加一个斜杠</li>
<li>abc|xyz 可以match到”abc”或者”xyz” 复杂的式子中可以加上圆括号，例如 “gr(e|a)y” 都可以match到灰色</li>
<li>repetition：一个match可以用几次。?可以用0或1. +可以用1或更多。*可以用0或更多。还可以特意指定匹配多少个。{n}：正好n个。{n,}：n或更多。{,m}：最多m个。{n,m}：在n和m之间。（在有三个匹配项时，{2,3}最后还是会匹配三个，说明匹配的时候默认是越多越好。可以再、在最后添加一个问号”{2,3}?”来变成匹配的越少越好）</li>
<li>可以使用斜杠来分组\1\2… 注意在匹配时还是要多加一个斜杠。</li>
<li>再用str函数的时候，匹配的”match”其实都是regex(“match”)的缩写版。regex函数还有很多参数：ignore_case = T. multiline = T（让^和$ match每一行的开始和结束而不是整个字符的开始和结束）dotall = T (允许”.” match everything including \n)</li>
<li>regex()的替代品们。fixed()：能让我们告别复杂的斜杠并且算的比正则式快，只能match一模一样的，但对于一些含有音调的字母的多种表达方式可能会不识别。coll()太复杂了感觉暂时不用学。</li>
<li>apropos(‘replace’): 常用来选出带有特定字符的函数（带有replace的）</li>
<li>dir(pattern = ‘正则式’)：在目录中搜索文件，返回match的文件名</li>
<li>AB*表示的是一个A加n个B，n为自然数</li>
<li>(Y|F)(.)\2：匹配Y或者F，后面跟上两个一样的字符</li>
<li>[A-T]匹配A到T，但(A-T) 匹配「A-T」</li>
<li>grep函数如果匹配不到的话，会返回长度为0的东西，可以用length()来catch</li>
</ul>
<h1 id="forcats因子变量"><a href="#forcats因子变量" class="headerlink" title="forcats因子变量"></a>forcats因子变量</h1><ul>
<li>创建因子变量：factor(char, levels = …) 对于不在levels里的字符会自动转成NA（对于这种情况如果需要error提示的话，可用readr::parse_factor代替factor）</li>
<li>对于levels的顺序，默认是字母表顺序，如果想按照char本身出现的顺序来排序的话，方法1：factor(char, levels = unique(char)) 方法2： fct_inorder(factor(char))</li>
<li>对于tibble中的因子变量，可以用count来轻松看到有哪些levels，数量各是多少。或者可用geom_bar(). 默认ggplot会将数据量为0的类别在图中删去，可以+scale_x_discrete(drop = F)来强制显示</li>
<li>modifying factor order: fct_reorder(f,x, fun) f是要修改的变量。x是一个向量，按照从小至大的顺序对f重新编排。fun：如果对于一个f有多个x跟他对应，那么默认value=median</li>
<li>fct_relevel(f, level1)：将level1移到所有level最前面。</li>
<li>fct_reorder2(f, x, y): 根据x取到最大值时y的取值进行排序。（画图完interpret的时候常用）</li>
<li>fct_rev(): reverse</li>
<li>fct_infreq(): 按照频率，从大到小排序。（一般还是从小到大舒服，所以配合fct_rev使用）</li>
<li>modifying factor levels: fct_recode(f, “new”=”old”) 可以将多个old指向同一个new</li>
<li>fct_collapse(f, “new”=c(“old1”, “old2”, …)): 快速的进行多个old指向一个new的操作</li>
<li>fct_lump(): 默认会将多个迷你组合，合并成一个小组，并且保持他仍然是最小的组合。我们可以加上参数n=几，来告诉他合并之后保留几个组</li>
<li>增加一个factor的level可以用c连接，删除的话只需要再z1$INCNONW1&lt;-factor(z1$INCNONW1) 留下用到的level</li>
</ul>
<h1 id="lubridate时间"><a href="#lubridate时间" class="headerlink" title="lubridate时间"></a>lubridate时间</h1><ul>
<li>today(): 获取当前日期。now(): 获取当前日期+时间</li>
<li>从字符或数字变成日期+时间：m/d/y + _ + h/m/s的任何一个排列组合都是一个函数。参数tz = “Timezone”</li>
<li>make_date/make_datetime(year=, month=…): 如果时间的每个部分被存在了不同地方，用这个函数。</li>
<li>as_date/as_datetime(): 在两种格式的时间中相互转换。也可以把从1970-1-1开始的天数/秒数转换成时间。</li>
<li>year/month/mday/yday/wday(time): 从一个时间变量里面抽取信息也可以进行赋值。对于month/wday 可以选择label=T返回英文，abbr=F返回全称。</li>
<li>floor/round/ceiling_date(time, “unit”): 四舍五入到最近的单位</li>
<li>如果是对多项指标同时修改/赋值的话可以使用update(time,year=…)，如果赋值超过上界，会被直接加到下一个时间单元</li>
<li>在r中如果时间减去时间会得到一个difftime变量，但是由于时间的单位可以是秒分时天..很难处理，所以用as.duration将他变成秒。</li>
<li>duration家族还有：dseconds/dminutes/dhours/ddays/dweeks/dyears都是将对应的后缀变成秒，duration可以进行加减乘除。</li>
<li>period家族：seconds/minutes/hours/days/months/weeks/years时间单位是多种多样的，也可以加减乘除</li>
<li>intervals：(start %–% end) : 是一个有开始结束点的时间段，多用于时间段相除</li>
<li>Sys.timezone(): 查看当前时区</li>
<li>除非特殊表明，否则lubricate采用UTC时间。想变换时区（时间会随之更改）：with_tz(time, tzone = “continent/city”)。想变换时区（时间不会变）：force_tz(time, tzone = “continent/city”)</li>
</ul>
<h1 id="modelr模型"><a href="#modelr模型" class="headerlink" title="modelr模型"></a>modelr模型</h1><ul>
<li>data_grid()：求出离散数据的自变量集合。.model可以添加模型信息</li>
<li>seq_range()：求出连续数据的模拟自变量集合. pretty = T 可以使output更加好看。 trim=0.1 会把两端10%的数据去掉（总共去掉20%的数据）expend = 0.1 与trim相反，将两端拉长5%（合在一起是0.1）</li>
<li>add_predictions(data, model) 根据自变量和模型算出预测值并进行连接</li>
<li>add_residuals(data, model) 跟上一个函数同理</li>
<li>可视化残差的方法：geom_freqpoly 或者 画散点图和 y=0进行比较</li>
<li>model_matrix 生成设计矩阵</li>
<li>对于多个model来说 有gather_prediction/spread_prediction. 前者是多出一列mod类型（分为1和2）一列是预测值。后者直接多出来两类预测值，所以前者窄长，后者扁宽。</li>
</ul>
<h1 id="回归分析："><a href="#回归分析：" class="headerlink" title="回归分析："></a>回归分析：</h1><ul>
<li>如果formula里面带有加减乘除等符号，要用I()括起来</li>
<li>再用poly的时候，有时候因为不可导会导致设计矩阵出现正负无穷。这时候用splines::ns(x, n)来代替poly(x, n)</li>
<li>有缺失值的时候一般R都会默默地不出声自动drop掉那一行，options(na.action = na.warn) 会在drop之后给出一行warning。options(na.action = na.exclude)还原。</li>
<li>nobs(formula)可以查看某个fit到底使用了多少个观测值（number of observations）</li>
<li>常用的模型：lm/glm/gam(generalized additive model)/penalized(glmnet)/rlm(robust)/tree</li>
<li>lm(v1<del>I(v2 * v3))真的是v2乘v3。但如果是lm(v1</del>v2 * v3)就会有v2,v3,以及v2:v3</li>
<li>rstudent 返回fit之后的残差</li>
<li>xtabs可以根据不同字符型变量组合生成01的设计矩阵</li>
<li>sigma(fit)可以返回fit的standardized residual</li>
<li>Logistic: glm(formula, family = binomial( link = ‘logit’ ))</li>
</ul>
<p>aov函数默认给出type1，anova函数默认给出type2，type2&amp;3可以用car::Anova(type = c(‘II’,’III’)) 来使用</p>
<p>conf.int获得置信区间</p>
<h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><ul>
<li>prcomp函数</li>
<li>biplot可以画出PCscores and loadings- 二维图只能选择前两个PC</li>
<li>pls::pcr </li>
<li>validationplot</li>
<li>princomp 可以直接给出loadings 需要用<code>fit2$loadings[]</code>取出matrix形式<ul>
<li>这个函数即使定义了cor = F, 也会自动中心化score矩阵</li>
</ul>
</li>
<li><a href="http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/112-pca-principal-component-analysis-essentials/" target="_blank" rel="noopener">PCA画图很好看</a></li>
</ul>
<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><p>主要用的包有TSA/latticeExtra</p>
<ul>
<li>lattice::xyplot 可以画出时间序列图。比plot好看一点点点</li>
<li>TSA::as.ts 将向量变成时间序列</li>
<li>xyplot(hours, panel = function(x, y, …) {panel.xyplot(x, y, …) panel.text(x = x, y = y, labels = months)}) 标出各个月份的信息</li>
<li>harmonic fit一个cosine-trend</li>
<li>densityplot&amp;qqmath判断是否正态</li>
</ul>
<p>Econometricians often talk about a time series being <em>integrated with order k, I(k)</em>. <em>k</em> being the minimum number of differences required to obtain a stationary time series. forecast::nsdiffs() 可以做ADF test</p>
<p>R output 的 ma 和 ar 都是 等式右面直接的值。</p>
<p>tsdiag 返回更详细的诊断</p>
<h1 id="Stat471"><a href="#Stat471" class="headerlink" title="Stat471"></a>Stat471</h1><p>ecoreg::gauss.hermite(k) 获取g(x)的多项式分解。同样还有integrate.gh</p>
<p>预分配数据框——有助于提高运算速度：<br>N&lt;-1000000<br>dfrm&lt;- data.frame(dosage=numeric(N),lab=factor(N,levels=c(“A”,”B”)))</p>
<p>根据位置选择数据框的列：<br>dfrm[[n]]=dfrm[,n] 返回第n列<br>特别的，dfrm[,n,drop=FALSE] = dfrm[n] 返回一个数据框，元素为第n列<br>dfrm[c(n1,n2)]=dfrm[,c(n1,n2)] 返回一个数据框，元素为第n1和n2列</p>
<p>根据条件更便捷的选定行和列： subset(dfrm,select=c(colname1,…,colnameN))<br>subset(dfrm,select=c(predictor,response),subset=(response&gt;0))</p>
<p>直接编辑数据框：①temp&lt;-edit(dfrm) dfrm&lt;-temp  ② fix(dfrm)</p>
<p>从数据中移除包含NA值的一整行： new&lt;-na.omit(dfrm)</p>
<p>根据名称排除列： subset(dfrm,select= c(-badboy,-patient.id))</p>
<p>根据共有列合并数据框： new&lt;-merge(born,died,by=”name”)</p>
<p>对于快速一次性使用数据框内的数据，可以不用attach&amp;detach ： with(dataframe,expr)<br>z&lt;-with(data,(pop-mean(pop))/sd(pop))<br>但注意attach之后就别对原数据进行操作了，因为无法改变原来的值。只能将值调出来赋给新的变量。</p>
<p>【重点】不同类型的数据转换，P156页： 首先要记住可以单独用cbind/rbind 来达到转换成行/列的效果</p>
<p>nls可以根据特定形式的函数进行最小二乘拟合，用coef来提取参数</p>
<p>mvnormalmixEM 可以计算多元正太的EM</p>
<p>5.5</p>
<p>基础篇（4）</p>
<p>split(列表的一行，列表的另一个用来分类的行)<br>unstack(data.frame(列表的一行，列表的另一个用来分类的行))  用来对列表中向量进行分组</p>
<p>对列表的每一个元素进行操作：用lapply/sapply s是简化的意思<br>对列表的每一行进行操作：apply(list,1,f) 其中1表示行，2表示列，c(1,2)表示行和列<br>tapply(data,factor,fx) 对列表的某一列按照另一分组的列进行分类并操作<br>by(data,factor,fx)  把整个数据框按照某一分类方式进行分类并操作<br>mapply 将函数应用于多维向量上 mapply(gcd,c(1,2,3),c(9,6,3))</p>
<p>第七章：字符串和日期：</p>
<p>获取字符串长度： nchar()</p>
<p>连接字符串 paste(“”,””,sep=””)<br>paste(c(“a”,”b”),”c”,sep=”e”,collapse=”f”)  输出结果：[1] “aecfbec”</p>
<p>提取字符串： substr(string,start,end)</p>
<p>根据字符中有的分隔符来分割字符串：  strsplit(“LOVE”,””)  可能的拓展参数 fixed=TRUE</p>
<p>将字符串中的某些字符替换成其他字符：<br>sub(old,new,string)  将string中第一个old找出来替换成new<br>gsub(old,new,string) 将string中所有old都替换成new</p>
<p>针对某些特殊字符，如”first\rsecond\n” 使用函数print和cat输出的结果是不一样的</p>
<p>生成两组字符串的笛卡尔积：  m&lt;-outer(strings1,strings2,paste,sep=””)<br>此法生成一个矩阵，可用as.vector变成一个向量<br>用m[!lower.tri(m)]可以去掉m矩阵的下三角中所有元素 （上三角为upper.tri）</p>
<p>得到当前日期： Sys.Date()  </p>
<p>将字符串转换为时间： as.Date(“12/31/2016”,format=”%m/%d/%Y”)</p>
<p>改变时间输出格式：  format(Sys.Date(),format=”%m/%d/%Y”)</p>
<p>%b 缩写的月份名称 %B完整的月份名称 %d两位数字的日期 %m两位数字的月份 %y没有世纪的年份 %Y有世纪的年份</p>
<p>生成给定数字的时间： ISOdate(年，月，日，小时，分钟，秒) 可在外面套上一层as.Date将具体时间变成为某一天</p>
<p>将时间变成从1970-1-1以来的天数： julian(date)/as.integer(date)</p>
<p>要具体知道某一天的其他信息（如它是一年中的第几天，是个星期几…）p&lt;-as.POSIXlt(date)<br>参数p$: sec,min,hour,mday(该月的天数),mon,year(from1900),wday(0~6—0为周日),yday(该年的天数),isdst(夏时令标记)</p>
<p>创建日期序列： seq(from=d1,to=d2,by=天数/“month”,length.out=多少天)</p>
<p>5.6<br>第八章：概率<br>dnorm正态密度 pnorm正态的分布函数（累计概率） qnorm正态分位数 rnorm正态分布随机数<br>binom二项分布 geom几何分布 hyper超几何分布 nbinom负二项分布 pois泊松分布<br>beta贝塔 cauchy柯西 chisq卡方 exp指数 f-F分布 gamma伽马 lnorm对数正态 logis逻辑分布 t—T分布 unif均匀分布 weibull威布尔分布 wilcox-Wilcoxon分布</p>
<p>combn(items,k) 从items里面抽k个出来，把所有组合排列出来</p>
<p>生成随机样本序列： sample(vec,n，prob=c(…))</p>
<p>d+分布为独立概率，q+概率能求分位数  p+分布为累计概率，在参数中添加 lower.tail=F表明求出互补概率1-P</p>
<p>diff(pbinom(c(3,7),size=10,prob=0.5)) 可以求出在3~7之间的概率  但diff并不是绝对值</p>
<p>polygon(region.x, region.y, density=) 可以为图形填充阴影</p>
<p>第九章：统计概论</p>
<p>统计惯例：选择显著水平α=0.05 则计算出p值小于0.05拒绝原假设，p&gt;0.05不拒绝</p>
<p>summary不提供关于数据波动方面的信息，所以要自己加上sd()等</p>
<p>计算相对频数：mean(逻辑判别式)  如：mean(x&gt;0)  此法也可用来求逆分位数</p>
<p>table(f1,f2) 将数据按照f1,f2的因子类进行计数，形成一个列联表</p>
<p>检验分类变量的独立性： summary(table()) 观察结果中的p值</p>
<p>为了保证一个有意义的置信区间或者是T检验，在数据&lt;30个的时候要保证数据是服从正态分布的</p>
<p>中位数的置信区间： wilcox.test(x,conf.int=T)</p>
<p>问题：有一组数据由失败与成功构成，你认为成功的比例是p，你需要用样本数据来检验<br>prop.test(x,n,p，alternative=”greater/less/two.sided”) 记得要将想证明的结论放在对立假设<br>prop.test(x,n)可以输出一个比例的置信区间</p>
<p>游程检验——一个序列是否是随机的：<br>library(tseries)<br>runs.test(as.factor())</p>
<p>比较两组样本的均值： t.test(x,y,paired=, var.equal= )</p>
<p>两个总体具有相同的图形形状，但他们的均值是否相同呢？：wilcox.test(x,y,paired=)</p>
<p>检验相关系数的显著性: cor.test(x,y)  对于非正态总体： cor.test(x,y,method=”Spearman”)</p>
<p>两组数据都由成功/失败组成，我想知道这两组是否具有相同的成功比例：prop.test(每一组的成功个数，每一组的总数)</p>
<p>把一些样本的均值与其他任何一个样本的均值进行比较：pairwise.t.test(data,factor)</p>
<p>两个样本是否取自同一个分布？： ks.test(x,y)</p>
<p>17.11.7<br>grep(pattern = “j”, x = a, ignore.case=F, value = TRUE)取出特定字符，ignorecase表明去不区分大小写，value意思是输出字符还是输出字符的位置<br>sub(pattern = “e”, replacement = “E”, x = a)只替换每个字符第一个出现的位置 gsub替换所有<br>coef(summary(lm))也是一种输出系数的方法<br>lm(xx<del>0+yy,data=?)/lm(xx</del>yy-1,data=?) 不要截距<br>lm(xx~(.-1),data=?) 彻底不要截距  (.-x)去掉x之外其他的进行拟合</p>
<p>ggplot:<br>    ggplot之后是什么也没有的，需要通过+geom_bar()等一系列来输出<br>    例子①ggplot(mpg, aes(cty, hwy)) +geom_point(aes(color = drv, size=cyl), shape=19, alpha=0.5)<br>    例子②ggplot(a,aes(carb,optden))+geom_point()+geom_smooth(method=lm)</p>
<p>多项式线性拟合 <del>poly(x,n)<br>confint(lm,level=0.95)给出置信区间<br>model.tables(av1, type=”means”) 可以给出aov()各个分类的均值（默认的是给出系数）<br>xtabs(</del> wool + tension, warpbreaks) 给出wool和tension每个类别都有多少个观测值<br>model.matrix输出设计矩阵<br>invisible(capture.output(y &lt;- ff(2))) 可以隐藏赋值语句中自带的print<br><strong>reformulate</strong>(paste(“X”, 1:p, sep=””), “Y”) 可以自动输出线性回归的格式：Y~X1+…+Xp<br>faraway包里面有Cpplot<br>leaps包里有leap，可以算Mallow’s Cp</p>
<p>fit1&lt;-rpart(lowbwt~.,data=test0,parms=list(split=”information”,<br>loss=matrix(c(0,1,5,0),byrow=TRUE,nrow=2)))  可以用来在rpart里面添加misclassification cost</p>
<h1 id="R-Markdown"><a href="#R-Markdown" class="headerlink" title="R-Markdown:"></a>R-Markdown:</h1><ul>
<li>一个星号包围是斜体，两个星号包围是粗体，code是用斜点包围</li>
<li>上标用^包围，下标用~包围</li>
<li>无序列表使用一个星号加两个tab，子列表分别在星号前面加上tab</li>
<li>有序列表1.加tab 并且后面的数字也都是1. Rmarkdown会自动修正</li>
<li>新建代码chunk可以用insert和cmd+alt+I. chunk的名字在r加一个空格之后输入。如果一个chunk起名叫setup，那么不管运行哪一个chunk，这个chunk都会被先运行一遍</li>
<li>options们：eval = FALSE:这框框的代码不会被计算(evaluate)但是会显示。include = FALSE：跑代码但是不显示代码或者结果。echo = FALSE：跑代码，不显示代码，显示结果。message = FALSE/warning = FALSE：让最后的结果不显示message和warning。results = ‘hide’：隐藏printed output。fig.show = ‘hide’：隐藏plot。error = TRUE：如果这个chunk坏了那么还会继续运行其他chunk的内容。</li>
<li>knitr::kable(): 使得表格打印效果更好，同类函数包还有xtable, stargazer, pander, tables, ascii</li>
<li>如果某个工程运行一次耗时很大，可以加上cached=TRUE来让运行的结果存起来，只要代码没变，之后运行的时候就不会重复计算。但有时这个chunk要接受其他chunk的结果，其他chunk如果变了的话是发现不了的，所以可以加上 dependson =’chunk name’ 另外如果有读文件的操作的话，文件的修改也是不能被发现的，可以加上cache.extra=file.info(). 最后记得清理：knitr::clean_cache()</li>
<li>可以通过knitr::opts_chunk$set()来修改默认的option</li>
<li>在R-markdown中添加数字可以用format(x, digits=2, big.mark=’,’)等来规范格式</li>
<li>如果我们在文字中想添加一些简短的数据信息(比如一个dataframe的行数)，这时候重开一个chunk显然不是最好的做法，可以用r+空格+语句并用斜点来包围</li>
<li>要注意有时候markdown的working directory和主环境的wd不是一个，可能会导致一些错误</li>
<li>可以设置全局参数，在三个断线分隔的开头，加上 params: my_class:”suv” 这主要是想批量产生一些markdown文件，具体详见P437.书上的后一页有一些关于在markdown结尾加上注释和参考文献等信息，暂时也用不到</li>
<li>图像的大小参数：老哥推荐的default: fig.width=6 fig.asp=0.618 out.width = “70%” fig.align = “center”。如果是多个图的话out.width = “50%”/“33%”/“25%” + fig.align = “default”</li>
<li>fig.show = “hold” 可以将图片强制放在代码的最后，而不是插在中间</li>
<li>fig.cap 可以添加caption</li>
<li>dev = “png” 损失了一点图片质量，但是可以换来效率。否则图片是pdf格式</li>
<li>不同格式的帮助文件 ?rmarkdown::html_document()</li>
<li>对于html文件，可以隐藏代码并且可以通过点击来打开：output：+回车+html_document: +回车+ code_folding:hide</li>
<li>{r include=FALSE, cache=FALSE} 不显示任何输出：<em># 可用来载入library</em></li>
<li>用$和$$包围Latex可以得到行间或者单独的公式。后面那个$符号前面不能带空格</li>
<li>换行用大于等于两个空格+回车或者两个回车</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;&#123;r, out.width &#x3D; &quot;400px&quot;&#125;</span><br><span class="line">knitr::include_graphics(&quot;path&#x2F;to&#x2F;image.png&quot;) #调整插入本地图片大小</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.datadreaming.org/post/r-markdown-theme-gallery/" target="_blank" rel="noopener">打印出来不同主题</a></p>
<p><a href="https://stackoverflow.com/questions/33965560/r-markdown-table-with-a-caption" target="_blank" rel="noopener">表格的title</a></p>
<h1 id="杂七杂八的问题"><a href="#杂七杂八的问题" class="headerlink" title="杂七杂八的问题"></a>杂七杂八的问题</h1><ul>
<li><p>当错误信息是中文的时候：</p>
<p>Sys.setenv(LANGUAGE = ‘en’) 再跑一遍程序，然后谷歌</p>
</li>
<li><p>手动更新某个包：tidyverse_update()</p>
</li>
<li><p>?也可以应用在内置数据集上，帮助文档会显示出每列的含义</p>
</li>
<li><p>Over-plotting: 很多函数在画图的时候用了取整，导致很多数据点重叠。</p>
</li>
<li><p>NA stands for ‘Not Available’</p>
</li>
<li><p>seriation包对两个因子变量同时排序，d3heatmap和heatmaply也是关于探求双因子变量关系的包</p>
</li>
<li><p>一般来说，注释#是用来解释why而不是what和how。</p>
</li>
<li><p>想看if的帮助文件需要加上``</p>
</li>
<li><p>对于R里面的函数如果没有调用的话，它甚至都不会生成（lazy evaluation）。</p>
</li>
<li><p>好像对于函数可以用testthat包来进行模拟测试，不太会用以后可以看看</p>
</li>
<li><p>traceback(): prints the functions called that generate the error.</p>
</li>
<li><p>经常在自己的函数里面加一个check输入格式的部分，使之变得robust</p>
</li>
<li><p>options(warn=-1/0) 可以将warning藏起来/显示</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">assign(paste(<span class="string">'X'</span>, i, sep=<span class="string">''</span>), <span class="literal">NULL</span>) <span class="comment">#这段代码可以配合for循环快速产生变量Xi</span></span><br></pre></td></tr></table></figure>

<p>加载包的时候有时候会显示: <code>Reason: image not found</code> </p>
<ul>
<li>解决方法<a href="https://github.com/rstudio/rstudio/issues/2254" target="_blank" rel="noopener">关于rjava</a> ：<code>sudo R CMD javareconf</code></li>
</ul>
<p><a href="https://stackoverflow.com/questions/23050928/error-in-plot-new-figure-margins-too-large-scatter-plot" target="_blank" rel="noopener">Error in plot.new() : figure margins too large</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lapply(paste(<span class="string">'package:'</span>,names(sessionInfo()$otherPkgs),sep=<span class="string">""</span>),<span class="keyword">detach</span>,character.only=<span class="literal">TRUE</span>,unload=<span class="literal">TRUE</span>) <span class="comment"># detach_all_packages</span></span><br></pre></td></tr></table></figure>

<p>我们对一个factor变量，即使把某一类全部删去了，当我们打印的时候，那个空白的level还在里面。这会让plsDA函数失效</p>
<p><a href="https://d.cosx.org/d/419420-r-markdown-pdf/2" target="_blank" rel="noopener">rmarkdown: Unicode char \u8:骞?not set up for use with LaTeX.</a></p>
<p><a href="https://stats.stackexchange.com/questions/11109/how-to-deal-with-perfect-separation-in-logistic-regression" target="_blank" rel="noopener">logistic出现perfect separation</a></p>
<p>有的github包装不上，需要先加载remote包：<a href="https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa" target="_blank" rel="noopener">https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa</a></p>
<h1 id="包包"><a href="#包包" class="headerlink" title="包包"></a>包包</h1><ul>
<li>mc2d::rtrunc:  truncate distribution generator</li>
<li>if(!require(“astro”)) install.packages(“astro”) 来检测包</li>
</ul>
<p>reshape里面辅助ggplot可以画出来相关系数热度图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cm = cor(dat1[,-<span class="number">1</span>])</span><br><span class="line">melted_cormat &lt;- melt(cm)</span><br><span class="line">ggplot(data = melted_cormat, aes(x=X1, y=X2, fill=value)) + </span><br><span class="line">  geom_tile()</span><br></pre></td></tr></table></figure>

<p><strong>DiagrammeR:</strong> 用来画各类流程图</p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul>
<li>ctl+alt+上：将光标变长，可以好几行一起编辑</li>
<li>在console里面使用cmd+上：可以查看最近敲过的代码</li>
<li>在出现备选函数名的时候，敲击回车或tab都可以选中。</li>
<li>cmd+shift+P: 重新发送刚刚的代码到console</li>
<li>cmd+shift+R: 添加代码之间分隔线</li>
</ul>
<p>#======xxx======== 可以创建可折叠代码段</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Coding</category>
        <category>R</category>
      </categories>
  </entry>
  <entry>
    <title>The Reason for God</title>
    <url>/2020/07/02/The-Reason-for-God/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>《The Reason for God》，中文版《为何是他》是提摩太·凯勒（Timothy Keller）写的一本<strong>信仰答疑解惑书</strong>。其中涉及到了很多“敏感问题”，比如：“为什么上帝会允许苦难”、“为什么充满爱的上帝会送人去地狱” 等等。初读时惊讶的合不拢嘴，连连拍手。中期时开始觉得理性的思考与感性的信心相违背，开始抵制这本书。最后决定把它读完，作为知识来收获，而不是信仰来全盘接受。</p>
<a id="more"></a>

<h1 id="前五章"><a href="#前五章" class="headerlink" title="前五章"></a>前五章</h1><ul>
<li>If morality is relative, why isn’t social justice as well?</li>
<li>A faith without some doubts is like a human body without any antibodies. 我们需要对抗来自外界的病毒，比如说他人的质疑，否则我们的信仰可能会在一夜之间崩塌</li>
<li>Believers should learn to look for reasons behind their faith.</li>
<li>All doubts, however skeptical or cynical they may seen, are really a set of alternate belief.</li>
<li>Leap of faith. 尽管对事情的后果无把握，但还是以最大的信念去进行</li>
<li>People should have doubts about their doubts.</li>
</ul>
<p>2020/5/10 周二<br>基督徒被接受不是因为做的比其他人好，而是耶稣担当了我们的罪过。其他宗教提倡道德提升，就会天然的对那些不信/不做的人，产生自己更高级的感觉。所以成为基督徒之后，我们正常来说不会觉得自己越来越好，而是越来越知道自己的不足，产生优越感也就无从谈起了。</p>
<p>2020/5/12 周二<br>未来的新天新地不仅是一个什么都有的美好世界，而是把我们所有过去的上海，痛苦全部翻转，并且变成更大的喜悦。更像是把水变成酒而不是直接给你一杯好喝的酒。</p>
<p>2020年5月14日</p>
<ul>
<li>“You cannot go on ‘seeing through’ things for ever. The whole point of seeing through something is to see something through it. It is good that the window should be transparent, because the street or garden beyond it is opaque. How if you saw through the garden too? It is no use trying to ‘see through’ first principles. If you see through everything, then everything is transparent. But a wholly transparent world is an invisible world. To ‘see through’ all things is the same as not to see.”</li>
<li>不存在一种文化能够包容所有文化，多元文化支持所有其他的文化，但他本身也是一种文化。如果我的文化有所支持而有所不支持，那我的文化就不同于多元文化，从而不存在一种文化能够包容所有文化。</li>
<li>想象一下LGBT的主席突然说：我认为LGBT是有罪的。同时，一个反对同性恋组织的主席突然觉得LGBT也不错。两个人的结局应该会很类似。所以没有不是什么inclusive/exclusive的问题。</li>
<li>我们既然不能用exclusive/inclusive来判断组织的好坏，怎么判断？我们应该看他们是如何对待不信的群体的。是以慈爱，谦卑来爱他们，还是攻击对抗他们？（难以想象LGBT的人会真的爱双性恋的人，并抱有一个谦卑的心）</li>
</ul>
<p>2020年5月15日</p>
<ul>
<li>Christianity helped Africans to become renewed Africans, not re-made Europeans. 相反的，现在的世俗生活，个人主义与不相信超自然的文化对非洲人来说是deconstructive的。</li>
<li>这里不存在一个什么基督文化，像伊斯兰文化那样。基督文化可以融入到我们自己的文化中，补全和理解我们自己的文化。</li>
</ul>
<p>2020年5月16日</p>
<ul>
<li>The church is a hospital for sinners, not a museum for saints. 所以如果你看到一个基督徒做的不好，比非信徒差劲，很可能他一开始更差。毕竟医院里的病人身体状况还是比正常人差。</li>
<li>他把法利赛人等追求道德提升的人称为fanatics</li>
<li>It was the Bible-believing religious establishment who put Jesus to death. It was the church, not the world, who crucified Christ.</li>
<li>法利赛人的问题在于，渴望通过很高的道德要求，来获得权利//能力，从而比别人优秀，甚至可以和基督比肩。这会导致他们越来越在乎外表。</li>
<li>不抢钱包，可能是因为如果抢钱包的事被别人知道了之后名誉损失很大（honor-shame society），也可能是因为想到了被抢钱包带来的伤害。</li>
<li>Christianity changed those honor-based cultures in which pride was valued rather than humility, dominance rather than service, courage rather than peaceableness, glory rather than modesty, loyalty to one’s own tribe rather than equal respect for all.</li>
<li>Instead of trying to shape our desires to fit reality, we now seek to control and shape reality to fit our desires. 古人和现在人的区别。</li>
<li>It seems to our mind unfair, therefore, that we should determine that it is all right to have sex outside of marriage and later discovered that there is a God who is going to punish us for that.</li>
<li>In one of my after-service discussions a woman told me that the very idea of a judging God was offensive. I said, why aren’t you offended by the idea of a forgiving God ? She looked puzzled.</li>
<li>For the sake of argument, let’s imagine that Christianity is not a product of any one culture but is actually transcultural truth of God. if that were the case we would expect that it would contradict and offend every human culture at some point, because human cultures are ever-changing and imperfect. if Christianity were the truth it would have to be offending and correcting your thinking at some place.</li>
<li>If you love a person and you see someone ruining them—even they themselves—you get angry.</li>
<li>Anger is not the opposite of love, hate is. And the final form of hate is indifference</li>
<li>If I don’t believe that there is a God who will eventually put all things right, I will take up the word and will be sucked into the endless vortex of retaliation. only if I am sure that there is a God who will right all wrongs and settle all accounts perfectly do I have the power to refrain.</li>
<li>Hell begins with a gambling mood, always complaining, always blaming others… but you are still distinct from it. you may even criticize it in yourself and wish you could stop it. but there may come a day when you can no longer. then they will be no YOU left to criticize the mood or even to enjoy it, but just the grumble itself going on forever like a machine. it is not a question of God sending us to hell. In each of us, there is something growing, which will BE HELL unless it is nipped in the bud.</li>
</ul>
<h1 id="第六章-Science-Has-Disproved-Christianity"><a href="#第六章-Science-Has-Disproved-Christianity" class="headerlink" title="第六章 Science Has Disproved Christianity"></a>第六章 Science Has Disproved Christianity</h1><p>他提到了不同的章节我们读的时候要考虑体裁。比如路加福音（eyewitnesses）就可以100%当成历史来读，而诗篇就要当成诗歌来读。当我们面对创世纪1&amp;2章的时候，就像士师记4&amp;5、出埃及记14&amp;15那样，一章是历史而一章是赞歌。他认为创世纪1是赞歌而2是历史。</p>
<blockquote>
<p>他们见了耶稣就拜他。然而还有人疑惑。《马太福音28:17》</p>
</blockquote>
<p>那些门徒，亲眼看到了耶稣的复活，甚至还触摸到了身体，有的人还存留疑惑。这让我想起了拉撒路的故事，亚伯拉罕对那个富人说，如果你的弟兄们是不信的人，那么即使看到了神迹也不会相信</p>
<p>关于神迹miracle，他举了个例子。比如耶稣不会做这种magic tricks：</p>
<blockquote>
<p>See that tree over there? Watch me make it burst into flames!</p>
</blockquote>
<p>相反，他用他的能力去救病人，喂饱肚子饿的人，让死人复活。现如今的人们认为的神迹大多属于上面的magic tricks，是对抗Nature Order。但是耶稣行的神迹是恢复Nature Order。</p>
]]></content>
      <categories>
        <category>Holy</category>
        <category>References</category>
        <category>The Reason for God</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2020/07/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="关于这门MOOC"><a href="#关于这门MOOC" class="headerlink" title="关于这门MOOC"></a>关于这门MOOC</h1><p>Coursera上面吴恩达的机器学习。老老实实学完的，代码都是自己打的，很有成就感。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>要把每次编程作业放在桌面，再cd改到位置</li>
<li>可以直接在命令行type submit来提交</li>
<li>吴恩达不太喜欢gut feelings，更偏好systematic way</li>
</ul>
<a id="more"></a>



<h1 id="GUIDE"><a href="#GUIDE" class="headerlink" title="GUIDE"></a>GUIDE</h1><p>GUIDE default 只有十层 然后开始prune</p>
<p>一棵树的复杂度取决于两点：Tree的复杂度，Node的复杂度。</p>
<p>Node复杂度排序：Piecewise: constant&lt; simple linear&lt; simple polynomial&lt; stepwise&lt; multiple linear</p>
<p>有一个内置的可以建立交互作用的列的方法，在dsc-file里面序列写成0</p>
<p>Importance-Score 是用来提示我们不要漏掉某些在树上没有出现，但是实际也很重要的variable。</p>
<p>Loh说Box-plot应用场景是当我们只有20~50数据的时候，所以现在数据量很大的时候，不能用box-plot做outlier-detection</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>机器学习的定义：在标准P不变的情况下，从经验E中提升自己T操作的能力。<br>机器学习分为：</p>
<ul>
<li>监督学习：对于数据集中的每个数据，都有相应的真实值，以供机器来训练自己。例如：Regression &amp; Classification</li>
<li>无监督学习：对于数据集中的数据，是否能找出一种结构？例如：聚类（cluster）算法、鸡尾酒宴会（分离两种声音）</li>
</ul>
<p>Notations:</p>
<ul>
<li>m:训练集的数据量</li>
<li>h:拟合出来的函数是一个从x到y的映射，例如：Guide输出的R-function</li>
<li>J(θ):平方误差代价函数。J=RSS/2m</li>
<li>:= colon-equal 赋值assignment</li>
<li>n:自变量的个数:x1~xn</li>
</ul>
<p>要注意：h(x)是x的函数而J(θ)是θ的函数<br>J(θ)在只有一个参数的时候是抛物线，有两个参数的时候变成了一个『抛物面』。但是二维图中画不出来，所以便有一招，二维图两个轴分别代表θ0和θ1，然后画出contour plot。</p>
<p>Gradient Descent Algorithm梯度下降法：</p>
<ul>
<li>可以最小化函数。想象自己在一座山上，每次迈出一步，这一步的方向是当前位置下山最快的方向。</li>
<li>算法：repeat until convergence{θj := θj - α * (J对θj求偏导) 对J里面的每个θ同时操作} </li>
<li>α被称为learning rate，也就是下山的时候该迈多大的步子。</li>
<li>随着越来越接近最低点，导数项会变小，步子自然地也会越迈越小。</li>
<li>Batch GD：每一步求导都要用到整个（Batch）训练集。</li>
</ul>
<p>还有种方法叫Normal equation method? 答：就是正常的回归分析</p>
<p>3 * 3矩阵有时候也被写成R，3 * 3被放在了上标里面。n * 1的矩阵是R(4 * 1)，*1可以省略，于是就变成了常见的那个样子。<br>矩阵的(i,j)元素被称为：i,j entry<br>1-indexed &amp; 0-indexed：y1<del>yn &amp; y0</del>yn</p>
<p>Feature Scaling: </p>
<ul>
<li>Idea: Make sure features are on a similar scale.</li>
<li>做法：通过除法，将他们的Range搞到（-1，1）吴恩达自己的建议是（-3，3）</li>
</ul>
<p>经常通过画一个 min(J(θ))—No.of iterations 的图来判断收敛情况。<br>如果一次迭代导致的变化小于10^-3 jiu认为是收敛了<br>如果迭代之后MIN不降反升，那么可能是步子迈得太大，应该缩小α。<br>数学家证明了如果步子足够小，J（θ）应该每次迭代都会下降<br>α太小或者太小都有可能导致收敛的速度过慢。<br>所以如何寻找α？吴恩达先找一个足够大的上界和一个足够小的下界。然后三倍关系去试：0.001-0.003-0.01-0.03-0.1-…<br>存在一些算法来自动帮我们选择多项式回归次数<br>Normal Equation：就是用（x’x）-1x’y来计算β。缺点是在自变量很多的时候，矩阵不好算，而梯度更快（n大于10000）<br>计算n阶矩阵的逆大概需要O(n^3)<br>xTx不可逆一般有两种可能性：</p>
<ol>
<li>有两列高度线性相关</li>
<li>数据量过少或者自变量过多（极端情况就是行数小于列数）对于这种情况，要么删一些列，要么用regularization</li>
</ol>
<p>loss function 也叫 objective function</p>
<h1 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h1><p>除了Gradient Descend 其他方法都不需要自己输入步长$\alpha$并且也比梯度下降更快，缺点只是更复杂一点</p>
<p>主要方法：</p>
<ul>
<li>Gradient Descend</li>
<li>Conjugate Gradient</li>
<li>BFGS</li>
<li>L-BFGS</li>
<li>…</li>
</ul>
<h1 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h1><p>如果我们用线性拟合的话，一些超远处的离群值可能会对整个拟合直线产生巨大影响。</p>
<p>##Logistic</p>
<ul>
<li>用的是logistic/sigmoid function $y = \frac{1}{1+e^{-z}}$ 会产生一个0~1的函数。 Threshold一般设为0.5 也就是在z&gt;0的时候。一般来说z = $\theta^TX$ 所以，$\theta^TX=0$又被称为 Decision Boundry。所以Decision-boundary是一个关于hypothesis的性质而不是关于data set的性质</li>
<li>sigmoid在4.6的时候函数值为0.99. 在-4.6的时候函数值为0.01</li>
<li>Cost function. 如果用常规的square-error的话，最后的损失函数是non-convex的，会有多个局部最小值。Cost function: $cost(h_\theta(x),y) = -log(h_\theta(x))I_{y=1}-log(1-h_\theta(x))I_{y=0} =\ -ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$</li>
<li>哇！我们神奇的发现，使用梯度下降法时，logistic和linear的导数部分具有同样的形式$\theta_j:=\theta_j-\alpha\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x^{(i)}$</li>
<li></li>
</ul>
<h2 id="Multiclass-Classification"><a href="#Multiclass-Classification" class="headerlink" title="Multiclass Classification"></a>Multiclass Classification</h2><p>One v.s. All</p>
<ul>
<li>本质上还是logistic。对于每一个class，做一个属于该class和不属于该class的logistic。得到一个$h_\theta^1(x)$. 以此类推得到其他的。则对于一个新的test sample，我们看哪一个h最大，就将他划为哪一组。这时的y就不是一个单一的0/1随机变量，而是一个1一堆0的随机向量</li>
</ul>
<h1 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h1><ul>
<li>underfitting一般会带来High bias。overfitting会带来high variance</li>
<li>解决overfitting的办法：1、减少features（手动/采用一些变量选择方法）2.Regularization.</li>
</ul>
<h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><p>keep all features, but reduce magnitude/values of parameter.(变量前面的系数变小了) Works well when there are lots of features and each contributes a bit to the response.</p>
<p>Small values for parameter: 1. ‘Simpler Hypothesis’ 2.Less prone to overfitting</p>
<ul>
<li>具体操作：在损失函数后面加上$\lambda/2m$倍的所有系数平方和（除了intercept），shrink all parameters。$\lambda$被称为regularization parameter</li>
<li>在梯度递降法里面多了一项$-\frac{\alpha}{m}\lambda\theta_j$. 在最小二乘法中变成了$\widehat{\beta}=(X’X+\lambda*A)^{-1}X’Y$ 其中A是一个在1,1位置上是0的单位阵</li>
<li>这一招还顺带解决了$X’X$矩阵不可逆的情况，使之可逆</li>
</ul>
<h1 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h1><p>传统方法会有一些问题，比如在Nonlinear-classification的情况下：如果单单用线性拟合的话，在100个feature的时候，我们要动用polynomial轻易就可以达到O(n^3)，实在是太多变量了</p>
<p>大脑有个一个主管学习的区域，无论给他输入什么数据，他慢慢自己都能学会。例子：一个主管听力的皮层在改为接受视觉信号之后学会了主管视觉</p>
<p>六部走：</p>
<ol>
<li>Randomly initialize weights</li>
<li>implement forward propagation to get $h_{\Theta}(x^{(i)})$ for any $x^{(i)}$</li>
<li>compute cost function $J(\Theta)$</li>
<li>implement back-prop to compute partial derivatives</li>
<li>Use gradient-checking the derivatives.</li>
<li>Using advanced optimization method with back-prop to minimize cost function</li>
</ol>
<ul>
<li>parameters 有时也被称作weights</li>
<li>input layer - hidden layer - output layer</li>
<li>$a^{(j)}<em>{i}$表示第j层layer中第i个neuron. $\Theta^{(j)}$表示从第j层到第j+1层的变换（左乘）矩阵，矩阵维数为$S</em>{j+1}*(S_j+1)$最后加的这个1是因为有$a_0$截距项：Forward propagation</li>
<li>跟logistic的一个明显区别：不用原来的自变量x而是用经过hidden-layer变换后的新自变量</li>
<li>logical and/or 可以用sigmoid-function写。给intercept-a-b分别加权(-30,20,20)/(-10,20,20)</li>
<li>一般来说的话，先假设有一个hidden-layer，如果实在想多几个，那么也尽量保证每个hidden-layer的units个数相同。通常来说hidden-layer的units尽量也比feature（input-layer）多一点.</li>
</ul>
<h2 id="back-propagation-反向传播算法"><a href="#back-propagation-反向传播算法" class="headerlink" title="back-propagation 反向传播算法"></a>back-propagation 反向传播算法</h2><ul>
<li>先从左到右算出来函数值，再从右到左算出来导数/误差值。不计算常数项的误差</li>
<li>有时虽然cost-function在递降，但是可能会存在一些小bug，这是我们需要引入gradient-check：2-sided-difference 用切线斜率来估计导数：$[f(x+\epsilon)-f(x-\epsilon)]/2\epsilon$, where $\epsilon \approx 10^{-4}$.</li>
<li>random-initializing: 在$[-\epsilon,\epsilon]$里面取值。rand(dim)*2$\epsilon$-$\epsilon$.</li>
</ul>
<h1 id="Debugging-a-learning-algorithm"><a href="#Debugging-a-learning-algorithm" class="headerlink" title="Debugging a learning algorithm"></a>Debugging a learning algorithm</h1><ul>
<li>Get more training samples：解决过拟合</li>
<li>Try small sets of features(avoid overfitting)：解决过拟合</li>
<li>Try getting addtional features：解决欠拟合</li>
<li>Try adding polynomial features：解决欠拟合</li>
<li>increasing/decresing $\lambda$ in the regularization term</li>
</ul>
<h1 id="Diagnose-the-ML-algorithm"><a href="#Diagnose-the-ML-algorithm" class="headerlink" title="Diagnose the ML algorithm"></a>Diagnose the ML algorithm</h1><ul>
<li><p>error for classificationo problem: </p>
<ol>
<li>Misclassification cost(0,1) </li>
<li>logistic loss: $\frac{1}{m}\sum-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$</li>
</ol>
</li>
<li><p>如果只把data分成70%train-30%test（只分一次），会导致选出来一个针对30%test最优化的算法，也不够generalize。所以我们可以60%train-20%CV-20%test. 先用train来拟合参数，再用CV来选算法，最后用test来估计误差</p>
</li>
<li><p>High-bias = under-fitting. High-variance = over-fitting</p>
</li>
<li><p><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/I4dRkz_pEeeHpAqQsW8qwg_bed7efdd48c13e8f75624c817fb39684_fixed.png?expiry=1522454400000&hmac=1E-Lq6rt765ATz0C9v6hVDu6kI-vvqxkgRDRJjPzv6g" alt=""><br>这个图表示如果Train&amp;CV的误差都很大，那么是under-fitting，如果Train小CV大很可能是over-fitting</p>
</li>
<li><p>在包含regularization的例子中，如果我们选择的$\lambda$很大的话可能会导致under-fitting，相反则会导致over-fitting</p>
</li>
<li><p>所以我们该如何选择$\lambda$?：将$\lambda$从小到大排即是不同的模型，再用cost来拟合，CV来选择（这个CV的cost是不含regular那一项的，同理我们只用含regular的来拟合参数，报告train-error的时候也是不含regular那一项的）<br><img src="http://spark-public.s3.amazonaws.com/ml/images/10.5-quiz-1-option4.png" alt=""></p>
</li>
<li><p>一般来说，用一个复杂的神经网络+regularization，要比用一个简单的神经网络效果要好<br>##Learning curves: </p>
</li>
<li><p>横坐标是sample-size，纵坐标是error。其中error的计算只对用到的数据取平均（从100个样本中用了三个来拟合模型，那最后算cost的时候就只算这三个的平均cost）</p>
</li>
<li><p>在出现high-bias(under-fitting)的时候，增加数据量是没什么用的，但是overfitting的时候，增加数据量有用（模型不变的情况下）</p>
</li>
<li><p><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/bpAOvt9uEeaQlg5FcsXQDA_ecad653e01ee824b231ff8b5df7208d9_2-am.png?expiry=1522454400000&hmac=B5ywTJzWN1IdcfxIx5LZi95HO4qj3LSKt58YMNlcFk8" alt="High Bias"></p>
</li>
<li><p><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/vqlG7t9uEeaizBK307J26A_3e3e9f42b5e3ce9e3466a0416c4368ee_ITu3antfEeam4BLcQYZr8Q_37fe6be97e7b0740d1871ba99d4c2ed9_300px-Learning1.png?expiry=1522454400000&hmac=r2oACMou0U4Qm-LtPW7WwfdD-rd7dRiokQU8jYo61Co" alt="High Variance"></p>
</li>
</ul>
<h1 id="Recommended-Approach"><a href="#Recommended-Approach" class="headerlink" title="Recommended Approach"></a>Recommended Approach</h1><ol>
<li>先采用一个快速容易实现的方法，并且用CV来验证</li>
<li>画出learning-curves来判断我们是否需要更多数据/更多特征</li>
<li>Error-analysis 观看那些残差很大的点（或者是分错类的点），看他们为什么出了错</li>
<li>对各种不同的算法用一种方式来量化比较</li>
</ol>
<p>有时还涉及到要不要stemming/大小写（把discount,discounts看做一个，但也会把universe和university看成一个）这时候很难说效果怎么样，所以只能在CV集合上面测试一下，然后看看出错率</p>
<h2 id="Skewed-class"><a href="#Skewed-class" class="headerlink" title="Skewed class"></a>Skewed class</h2><ul>
<li><p>Precision/Recall: 可以写成一个二乘二矩阵<br>Precison = True prositive/Predicted Positive(第一行)<br>Recall = True prositive/Actual Positive(第一列)</p>
<p><img src="http://spark-public.s3.amazonaws.com/ml/images/11.3-quiz-1-q1.png" alt=""></p>
</li>
<li><p>一般来说都用y=1 来表示那个稀少的类（比如患了癌症）</p>
</li>
</ul>
<h3 id="Trade-off-between-Precision-amp-Recall"><a href="#Trade-off-between-Precision-amp-Recall" class="headerlink" title="Trade off between Precision&amp;Recall"></a>Trade off between Precision&amp;Recall</h3><ul>
<li>我们可以调整logistic的threshold。如果调高的话，会增加precision，降低recall</li>
<li>一种简单的方法是计算$\frac{P+R}{2}$，但明显不好，全部预测为0会得到差不多最好的结果</li>
<li>一种更通用的方法是计算F1-score:$2\frac{PR}{P+R}$。调和平均，（如果有一个0的话基本上F1-score就是0了）</li>
<li></li>
</ul>
<h2 id="Large-Data-Set"><a href="#Large-Data-Set" class="headerlink" title="Large Data Set"></a>Large Data Set</h2><ul>
<li>比的不是谁的算法吊，而是谁的数据量大（希望自己有朝一日能取到一家海量数据的公司）</li>
<li>遇到一个问题，问问自己，如果把这个信息告诉一个这方面的专家，他能不能做出准确的预测，如果能的话，说明这信息是充分的，那我们可以用海量数据来减小误差，如果不能，单纯增加数据量是没用的，我们必须获取其他的特征。</li>
</ul>
<h1 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h1><ul>
<li>cost function: $C\sum_{i=1}^m[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})] + \frac{1}{2}\sum_{i=1}^n\theta_j^2$</li>
<li>hypothesis: $h_\theta(x)=I(\theta^Tx\ge0)$</li>
<li>Large Marigin Intuition: margin指的是分界线距离两类各自边缘的距离，svm会选出来一条线使得这个距离最大，所以更robust。</li>
<li>C如果越大的话（相当于regularization里面的$\lambda$越小），整个SVM就会对离群值越敏感，容易出现过拟合</li>
<li>decision boundary那条线与$\vec{\theta}$ 是垂直的。</li>
<li>疑问：SVM desicion boundary是不是只由最边缘的点决定？</li>
<li>VS logistic：当数据量m远小于参数个数n的时候，用logistic/不带kernal的SVM，如果n比较小（1-1000）而m适中（10-10000），可以用Gaussian-kernal。如果n小m大（50000+）这时跑SVM就慢的一批，只能多加几个feature然后用logistic/不带kernal的SVM</li>
</ul>
<h2 id="Kernal"><a href="#Kernal" class="headerlink" title="Kernal"></a>Kernal</h2><ul>
<li>kernals有好多种（Gaussian…）目的是为了刻画x和landmark之间的similarity。不用kernal又被称为linear-kernal，在数据量不足的时候一般我们不能用太复杂的kernal</li>
<li>一个Kernal一定要满足Mercer’s Theorem</li>
<li>Ng举了一个中间护舒宝形状的X外面是O的分类例子，可以在中间设置两个landmark，然后用kernal来解决</li>
<li>Gauss的参数$\sigma^2$：$\sigma^2$越大，$f_i$的变化就越缓慢，容易导致欠拟合，higher-bias</li>
<li>做Gaussian之前，要对feature做scaling</li>
<li>其他kernal：polynomial-kernal（like $(X^Tl+a)^b$…），string-kernal(针对text类型的数据), chi-square-kernal, histogram-intersection-kernal</li>
</ul>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol>
<li>把每一个数据点都先标记成为landmark</li>
<li>计算feature vector：$f_i=similarity(x,l^{(i)})$ 可以增加常数项：$f_0=1$</li>
<li>预测y=1，当且仅当$\theta^Tf \ge 0$</li>
</ol>
<h1 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h1><h2 id="Clustering-Algorithm"><a href="#Clustering-Algorithm" class="headerlink" title="Clustering Algorithm"></a>Clustering Algorithm</h2><p><img src="https://i.stack.imgur.com/Yl4tV.png" alt="各个聚类方法的scale时间"></p>
<h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><ul>
<li>先随机找到两个点（只分两组的时候）</li>
<li>把其他的点根据距离初始点的距离划分成两大类</li>
<li>用分好的两大类的重心来代替原来的两个点。</li>
<li>循环1-3，直至converge</li>
</ul>
<p>distortion-cost-function：$\frac{1}{m}\sum_{i=1}^m||x^{(i)}-\mu_{c^{(i)}}||^2$</p>
<p>Initialization: 选取k&lt;m, 然后从数据点中随机选取k个作为$\mu_1 \sim \mu_k$. 有时候数据点选择的不好的话，会导致算法优化到局部最优而不是全局最优，这时我们可以做的是：随机选取100次，对于每次选择的k个随机点，我们计算他的cost，最后，在这100个随机cost中，选择cost最小的那个作为我们的initial k个点。</p>
<p>Elbow Method for choosing K：选择那个斜率变化最大点</p>
<h2 id="Dimensionality-Reduction"><a href="#Dimensionality-Reduction" class="headerlink" title="Dimensionality Reduction"></a>Dimensionality Reduction</h2><p>主要用途：</p>
<ul>
<li>为了visualize数据，我们可以把维数强行降到2，然后打印在平面图上</li>
<li>加快分析速度，减少内存使用</li>
</ul>
<p>PCA与linear的一个明显的区别：lm最小化竖着的线段平方，PCA最小化垂直线段的平方。因为lm里面y是我们更关心的点（主要目的就是为了预测y），而PCA中各个x地位是平等的。</p>
<p>步骤：</p>
<ul>
<li>先计算cov矩阵$\Sigma=\frac{1}{m}X^TX$（包含了标准化）</li>
<li>计算$\Sigma$矩阵的eigen：[U, S, V] = svd(Sigma) [其实eig函数也可以做，但是不如svd稳定] 其中U会返回按列排放的特征向量，S是个对角矩阵，存放了每个PC分别解释了多少的方差</li>
<li>最后: $z^{(i)}=U^Tx^{(i)}$</li>
<li>$x_{approx} = Uz^{(i)}$</li>
</ul>
<p>一个选择PCA个数的准则是解释99%/95%的方差</p>
<p>在做PCA的时候，只对train做，而不做CV和test</p>
<p>一个不好的例子：用PCA来防止过拟合（因为少了需要拟合的参数个数）。因为有时候我们在PCA中扔掉了一部分信息，但这部分信息很可能和y很有关，所以为了防止过拟合，不如直接使用regularization。</p>
<p>PCA使用建议：先对raw-data直接做分析，只有当原始数据做不了的时候（比如说太慢了或者内存不够大），再开始尝试PCA</p>
<h1 id="Anomaly-Detection"><a href="#Anomaly-Detection" class="headerlink" title="Anomaly Detection"></a>Anomaly Detection</h1><p>对于那些离群的异常点检测，定义一个p值（一个关于自变量的函数），如果p值过小就被视为离群值。</p>
<p>Machine-learning里面习惯用MLE来估计方差（分母是m）</p>
<h2 id="Gaussian-Distribution"><a href="#Gaussian-Distribution" class="headerlink" title="Gaussian Distribution"></a>Gaussian Distribution</h2><p>具体步骤：</p>
<ul>
<li>假设n个$x^{(i)}$是独立且是正态分布的，用已有的样本来估算均值和方差。</li>
<li>给定一个新样本，他的p值定义为$\prod_{i=1}^n\Phi_i(x_i)$</li>
<li>跟临界值进行大小比较</li>
</ul>
<p>一个实例：</p>
<ul>
<li>假设我们现在的数据多了一个label：正常/不正常，我们现在有10000个正常和20个不正常</li>
<li>先将数据分为三组：train（6000，0）CV（2000，10）Test（2000，10）</li>
<li>用Train那一组来拟合参数（每个变量的均值&amp;方差）</li>
<li>拿出CV，对于一个选定的临界值$\epsilon$，我们将$p(x_i)&lt;\epsilon$的那些样本点赋予y=1(不正常)，其他点赋值y=0. </li>
<li>将y对x进行NN/logistic，计算F1-score。通过不同$\epsilon$的选取，选出其中能使得F1-score最大的$\epsilon$作为最后的临界值。</li>
</ul>
<p>Anomaly-Detection v.s. Supervised-learning</p>
<ul>
<li>一般来说，Supervised-learning一般解决的问题是当两类数量差不多的时候，而当y=1特别少（skewed-class）的时候，我们惯用Anomaly-Detection</li>
<li>S-L一般解决未知数据长的很像test数据的问题，所以准确性更高。但一般skwed-class的异常都是「各有各的异常」，很可能未知的数据在以前就没有出现过，这时候一般都交给A-D来做。</li>
<li>像Spam-Email那个例子中，因为我们有很多Spam可以供训练模型，并且可能一般来说未来出现的垃圾邮件很可能和之前的垃圾邮件长得很像，所以我们采用Supervised-learning</li>
</ul>
<p>How to choose features?</p>
<ul>
<li>首先我们可以画出feature的分布图，如果看起来不是很正态，我们可以做一下box-cox（或者取log）来使得它看起来正态。（但是他说好像如果正态不满足的话好像算法也没啥大问题）</li>
<li>经常还会遇到的一个问题是：我们经常假设如果数据越异常，p(x)就会越小，但是有时候不论是不是异常，p(x)始终都差不多，这时候我们就需要加入新的变量（这里的新不仅可以加入之前没用的变量，还可以是一些变量的函数）。</li>
</ul>
<h2 id="Multivariate-Gaussian-Distribution"><a href="#Multivariate-Gaussian-Distribution" class="headerlink" title="Multivariate Gaussian Distribution"></a>Multivariate Gaussian Distribution</h2><p>如果两个变量之间存在cor，那么原来的圆形置信域就会变成椭圆形，导致一些异常点检测不出来(例子：一三象限方向的椭圆，对于二四象限的异常点有可能检测不出来，因为关于x-y轴的两个投影都不是很小)</p>
<ul>
<li><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fpwrxdd0l3j30qu0miwu5.jpg" alt=""></li>
</ul>
<p>我们只需要将原来的p(x)连乘变成多元正态里面的p(x)就可以了$p(x)=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))$<br>同样使用样本均值和样本协方差矩阵来估计那两个参数</p>
<h2 id="两种分布的对比："><a href="#两种分布的对比：" class="headerlink" title="两种分布的对比："></a>两种分布的对比：</h2><ul>
<li>多元正态自动捕捉了feature之间的协相关，单变量正态需要自己手动添加</li>
<li>单变量要比多元快很多</li>
<li>当数据量m小于变量个数n的时候（或者当feature之间线性相关的时候），多元正态协方差阵不可逆。当m比n大很多的时候（10倍），考虑用多元。</li>
</ul>
<h1 id="Recommander-System"><a href="#Recommander-System" class="headerlink" title="Recommander System"></a>Recommander System</h1><p>就拿电影评分来举例子：</p>
<ul>
<li>Feature-vector: 每个电影可以被量化成一个向量$x^{(i)}$, 第一位是截距项，后面的是每一种类别涉及到的比例（爱情0.5，动作0.8…）</li>
<li>r(i, j) = if user j has rated movie i 示性变量</li>
<li>$y^{(i,j)}$ = rating by user j on movie i</li>
<li>$\theta^{(j)}$ = parameter vector for user j : 观众的喜好向量(爱情5，动作8…)</li>
<li>$m^{(j)}$ = #of movies rated by user j</li>
<li>For user j , movie i, predicted rating: $(\theta^{(j)})^Tx^{(i)}$</li>
<li>Cost-function for each $\theta^{(j)}$: $\frac{1}{2m^{(j)}}\sum_{r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2m^{(j)}}$</li>
<li>Cost-function for all users: 只需要把上面这个cost-function 对所有用户求和即可</li>
</ul>
<h2 id="Collabrative-Filtering"><a href="#Collabrative-Filtering" class="headerlink" title="Collabrative Filtering"></a>Collabrative Filtering</h2><ul>
<li>Optimization algorithm: 还可以给定$\theta$ 反向来求出feature-vector $x^{(i)}$</li>
<li>Try to minimize: $\frac{1}{2}\sum_{r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{k=1}^n (x_k^{(i)})^2$</li>
<li>最后我们对每一个电影都算一下上面的cost然后求和。</li>
</ul>
<p>所以实际上我们可以估计用户的初始$\theta$，然后来拟合feature，再用拟合的feature重新拟合用户的$\theta$，如此循环往复，最后收敛到一个合理的结果。</p>
<p>但是我们可以更进一步，把两种cost-function写在一起，同时对他们整体做minimization，一步到位。这时候也不用填写截距项，因为算法应该会自动添加需要的截距项。开始需要randomly initialize number，为了symmetry-breaking</p>
<p>Low rank matrix factorization: 将预测用户的评分写成一个矩阵：$X\Theta^T$</p>
<p>判断两个电影很像，small $||x^{(i)}-x^{(j)}||$</p>
<h2 id="Mean-Normalization"><a href="#Mean-Normalization" class="headerlink" title="Mean Normalization"></a>Mean Normalization</h2><p>如果一个新用户曾经没有给任何电影评分，那么根据我们上面的cost-function来看，最佳的预测就是该用户的$\theta$是一个零向量。这样我们也不能给他推荐什么电影，没有什么意义。</p>
<p>步骤：</p>
<ul>
<li>对于每个电影，计算当前用户评分的均值。</li>
<li>然后将每个用户对于当前电影的评分减去均值</li>
<li>这时新用户的一排零，就变成了各个电影都是‘‘适中’’评分，我们就可以给他推荐电影啦</li>
</ul>
<h1 id="Dealing-With-Large-Data-Set"><a href="#Dealing-With-Large-Data-Set" class="headerlink" title="Dealing With Large Data Set"></a>Dealing With Large Data Set</h1><p>为什么我们要用更多的数据？</p>
<ul>
<li>我们可以画出learning-curve，然后发现当m很小的时候，$J_{CV}$很大，我们面临了high variance的情况，这时候提高m的数量有助于更好的拟合。但是如果我们发现learning-curve呈现的是high-bias的情况，那么我们就没啥必要提高m的数量了。</li>
</ul>
<h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p>正常的一次性计算所有的梯度下降又被称为Batch-Gradient-Descent：$\theta_j:=\theta_j-\alpha\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x^{(i)}$</p>
<p>步骤：</p>
<ol>
<li>Randomly Shuffle the dataset 随机排序</li>
<li>从第一个数据开始，对每个数据做一个小的单变量梯度递降。$\theta_j:=\theta_j-\alpha (h_\theta(x^{(i)})-y^{(i)})x^{(i)}$ for every j</li>
<li>重复做第二步1-10遍(每一次都重新shuffle)</li>
<li>最后应该会落到全局最优的附近</li>
</ol>
<p>Check for convergence:</p>
<ul>
<li>在每一次更新$\theta$之前，记录当前数据点的$cost(\theta,(x^{(i)},y^{(i)}))$</li>
<li>每更新比如说1000次，计算一下1000个cost的平均</li>
<li>最后将这些平均数进行比较，画个图</li>
<li>一般来说数据取得越大（比如说用5000代替1000），$J_\theta$关于迭代次数的曲线就会越平滑</li>
<li>如果发现$J_\theta$不降反升，那么我们可以试着减少步长$\alpha$（learning-rate）</li>
<li>如果我们想试着最后落入到全局最优点，我们可以逐渐减小步长，let $\alpha = const1/(#iteration+const2)$</li>
<li></li>
</ul>
<h2 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h2><p>正常的Batch每次迭代用到all m examples. Stochastic只用1个。Mini-batch取了个中间地带，每次用b个，其中b也被称为mini-batch size.</p>
<p>步骤：</p>
<ol>
<li>Randomly Shuffle the dataset 随机排序</li>
<li>从第一个数据开始，b个b个的应用梯度下降来迭代$\theta_j$</li>
<li>重复做第二步1-10遍(每一次都重新shuffle)</li>
<li>最后应该会落到全局最优的附近</li>
</ol>
<p>Mini-Batch 如果想要比Stochastic跑得更快，就必须要应用Vectorization</p>
<h2 id="Online-Learning"><a href="#Online-Learning" class="headerlink" title="Online Learning"></a>Online Learning</h2><p>一个数据网站，获取用户的数据，不停的更新原来的$\theta$, learning continuously<br>CTR: 用户搜索一个信息，我们来预测他会不会点击我们给他提供的链接，learning the predicted Click Through Rate</p>
<p>步骤：</p>
<ul>
<li>永久性的循环以下步骤</li>
<li>获得数据（x, y）, 更新$\theta_j:=\theta_j-\alpha (h_\theta(x)-y)x_j$</li>
<li>把数据(x, y)扔掉，只保留更新后的$\theta$</li>
</ul>
<h2 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map Reduce"></a>Map Reduce</h2><p>如果有四百个数据，在计算梯度下降的时候可以把数据分成四份，分给四个电脑去同时并行做。</p>
<p>为什么可以用Map-Reduce：Many learning algorithm can be expressed as computing sums of functions over the training set. 算法可以写成关于数据量的求和</p>
<p>有时候就算没有多台电脑，一个电脑有很多个核，也可以做Multi-core Machines</p>
<p>Open Source：Hadoop</p>
<h1 id="Photo-OCR"><a href="#Photo-OCR" class="headerlink" title="Photo OCR"></a>Photo OCR</h1><p>Photo Optical Character Recognition</p>
<p>主要步骤（pipeline）: </p>
<ol>
<li>Get a Image</li>
<li>Text Detection</li>
<li>Charcter Segmentation</li>
<li>Character Classification</li>
</ol>
<h2 id="Sliding-Windows"><a href="#Sliding-Windows" class="headerlink" title="Sliding Windows"></a>Sliding Windows</h2><h3 id="Pedestrian-Detection"><a href="#Pedestrian-Detection" class="headerlink" title="Pedestrian Detection"></a>Pedestrian Detection</h3><p>Supervised-learning-version: </p>
<ul>
<li>我们给定一些<u>固定大小</u>的人像的正确例子（y=1），和一些不是人像的例子（y=0）</li>
<li>紧接着，我们在原图上从左上角开始一点点向右移（step/sliding-size）如果一个像素一个像素移动的话太慢了，所以我们会让他每次跨的大一点。过完一行，再来一行….直到整个图都被过了一遍</li>
<li>然后，我们将选取框放大一点，再跑一边步骤二（不管选取框是多大，在做检验的时候都要先变成和给定例子training-set中的大小一致）</li>
</ul>
<p>现在让我们回到Text-Detection：</p>
<ul>
<li>text-detection比行人识别的一大难点在于大小不是固定的</li>
<li>所以开始的时候先一个一个像素点过，形成一个黑底图，上面的白色表示可能存在text</li>
<li>下一步是Text-expansion 将临近的白色区域连接起来，看成一大块文字域</li>
</ul>
<p>Character-segmentation 也可以用sliding window来做</p>
<h1 id="Artificial-Data-Synthesis"><a href="#Artificial-Data-Synthesis" class="headerlink" title="Artificial Data Synthesis"></a>Artificial Data Synthesis</h1><ol>
<li>creating data from stretch 无中生有</li>
<li>amplify the small data set 将小数据集变大</li>
</ol>
<p>吴恩达用的是字母识别的例子，无中生有：自己在网上找点字体，自己加点背景上去。以小见大：从已有的字体图片，经过旋转变形生出新的字体图片</p>
<p>Make sure you have a low bias classfier before expending the effort. 如果当前是过拟合的话是需要更多数据，但如果是欠拟合的话，我们首先应该考虑的是在模型里面多放几个变量，而不是通过这种方式使得数据变多。</p>
<p>其次应该问自己的问题是，如果要把当前数据量变成十倍，需要多少工作量？</p>
<h1 id="Ceiling-Analysis"><a href="#Ceiling-Analysis" class="headerlink" title="Ceiling Analysis"></a>Ceiling Analysis</h1><p>在一个pipeline中，先看overall accuracy。然后再去第一个环节，手动把第一个环节准确率调成100%，看看对overall有什么影响。</p>
<p>有助于我们发现pipeline中哪一环节是最需要花时间来提高的</p>
<p>吴恩达嘲讽了一手：说有个小组，花了一年时间专门研究怎么去掉背景，甚至还发了论文，但最后发现准确率从85%提高到了85.1%，并没什么卵用</p>
<h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><h2 id="Sentiment-Analysis"><a href="#Sentiment-Analysis" class="headerlink" title="Sentiment Analysis"></a>Sentiment Analysis</h2><p>There are many types and flavors of sentiment analysis:</p>
<ol>
<li>Fine-grained Sentiment Analysis</li>
<li>Emotion detection</li>
<li>Aspect-based Sentiment Analysis</li>
<li>Intent analysis</li>
<li>Multilingual sentiment analysis</li>
</ol>
<p>Some of the advantages of sentiment analysis:</p>
<ol>
<li>Scalability</li>
<li>Real-time analysis</li>
<li>Consistent criteria</li>
</ol>
<p>Methods and algorithms to implement sentiment analysis systems:</p>
<ol>
<li><p><strong>Rule-based</strong> systems that perform sentiment analysis based on a set of manually crafted rules.</p>
<ul>
<li><p>Classic NLP techniques like <em>stemming</em>, <em>tokenization</em>, <em>part of speech tagging</em> and <em>parsing</em>.</p>
</li>
<li><p>常用方式是建立两个集合，一个好一个坏。对一段文字，我们数其中好的词出现的频率和坏的词出现的频率，哪个多选哪个。一样多就是中性。这个方法坏处在于：</p>
<ol>
<li>只算了单个的词而没有组合起来</li>
<li>添加更多规则之后很容易就变得超级复杂，并且不同的rule之间可能冲突，需要很多的人工进行tune</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Learning-based/Automatic</strong> systems that rely on machine learning techniques to learn from data.</p>
<ul>
<li>不用人工的rule，从文字中抽取feature和label，都一起扔给机器学习算法。</li>
<li><strong>Feature</strong>: 一般是numeric结果。Usually, each component of the vector represents the <u>frequency</u> of a word or expression in a <u>predefined dictionary</u> . The classical approach has been <a href="https://machinelearningmastery.com/gentle-introduction-bag-words-model/" target="_blank" rel="noopener">bag-of-words</a> or <a href="https://www.quora.com/What-is-the-difference-between-bag-of-words-and-bag-of-n-grams" target="_blank" rel="noopener">bag-of-ngrams</a> with their frequency. </li>
<li>More recently, new feature extraction techniques have been applied based on word embeddings (also known as <em>word vectors</em>). This kind of representations makes it possible for words with similar meaning to have a similar representation, which can improve the performance of classifiers. （这一段是为了提高准确率的，但是我没搞懂他是怎么操作的）</li>
<li><strong>Classification Algorithms:</strong> Naïve Bayes, Logistic Regression, Support Vector Machines, or Neural Networks</li>
<li>Metric 判断：Precision, Recall, and Accuracy（是不是也考虑F1）但是老师要求的是RMSE。<a href="https://en.wikipedia.org/wiki/Krippendorff%27s_alpha" target="_blank" rel="noopener">Krippendorff’s Alpha</a> 也是一个好的评分方法，0.67/0.8为界</li>
</ul>
</li>
<li><p><strong>Hybrid</strong> systems that combine both rule based and automatic approaches.</p>
<ul>
<li>Usually, by combining both approaches, the methods can improve accuracy and precision. 周子涵说过什么stacking</li>
</ul>
</li>
</ol>
<p><strong>Irony and Sarcasm</strong> 讽刺语气感觉是个难点。Yeah, sure.有时候表达的是无所谓了就这样吧的意思</p>
<p><strong>Comparisons</strong>: 一些例子：</p>
<ol>
<li><em>This product is second to none.</em></li>
<li><em>This is better than old tools.</em></li>
<li><em>This is better than nothing.</em></li>
</ol>
<p><strong>Emojis</strong>: 疯了。丧心病狂</p>
<p><em>Western emojis</em> (e.g. :D) are encoded in only one character or in a combination of a couple of them whereas <em>Eastern emojis</em> (e.g. ¯ \ _ (ツ) _ / ¯) are a longer combination of characters of a vertical nature. </p>
<p><strong>转折Ordering Effect</strong>：</p>
<p>听说不错，演员也好，票房也高，然而我觉得它糟糕透了。</p>
<h3 id="Subjectivity-classification"><a href="#Subjectivity-classification" class="headerlink" title="Subjectivity classification"></a>Subjectivity classification</h3><p>Goal: Classifying a sentence as <em>subjective</em> or <em>objective</em></p>
<p>Text information can be broadly categorized into two main types: <em>facts</em> and <em>opinions</em>.</p>
<h4 id="Opinion"><a href="#Opinion" class="headerlink" title="Opinion"></a>Opinion</h4><p>There are two kinds of opinions: <em>direct</em> and <em>comparative</em>.</p>
<p>There are also two kinds of opinions: <em>Explicit</em> and <em>Implicit</em>.</p>
<h3 id="Polarity-classification"><a href="#Polarity-classification" class="headerlink" title="Polarity classification"></a>Polarity classification</h3><p>Goal: Classifying a sentence as expressing a <em>positive</em>, <em>negative</em> or <em>neutral</em> opinion</p>
<p><strong>Baseline Algorithms</strong>:</p>
<ol>
<li>Tokenize<ul>
<li>Christopher potts sentiment tokenizer</li>
<li>How to handle negation?<ul>
<li>Das and Chen: add NOT_ 然后把很多NOT_like 这种词也变成一个feature</li>
</ul>
</li>
<li>All words/Only adj ? [It seems all words is better]</li>
</ul>
</li>
<li>Feature Extraction</li>
<li>Classification:<ul>
<li>Naive Bayes<ul>
<li>$\frac{count(w,c)+1}{count(c) + V}$</li>
<li>Binarized / (boolean feature) multinomial naive bayes.<ul>
<li>Word occurance matter more than word frenquency</li>
<li>Prior: $p(c) = \frac{doc\ with\ words}{all\ docs}$ . Prob: <strong>Remove duplicate</strong> in each doc and then same as above.</li>
</ul>
</li>
</ul>
</li>
<li>MaxEnt</li>
<li>SVM</li>
</ul>
</li>
</ol>
<p><strong>正负词汇包：</strong></p>
<ol>
<li><p>The Genearal Inquiry 包含了正面以及负面的词汇</p>
</li>
<li><p>LIWC 单次分类 <a href="http://liwc.wpengine.com/" target="_blank" rel="noopener">http://liwc.wpengine.com/</a></p>
</li>
<li><p>MPQA 单次分类 还包含了程度<a href="http://people.cs.pitt.edu/mpqa/subj_lexicon.html" target="_blank" rel="noopener">http://people.cs.pitt.edu/mpqa/subj_lexicon.html</a></p>
</li>
<li><p>Bing Liu Opinion Lexicon</p>
</li>
<li><p>SentiWordnet</p>
</li>
</ol>
<p>我们不能单纯的用raw count。eg. bad这个词出现的10星评论比2星评论多，是因为2星评论本来就很少。我们应该:<br>​    1. 用likelihood(ratio) $\frac{Target\ words}{Total\ words}$</p>
<ol start="2">
<li>scaled likelihood, make them camparable between words</li>
</ol>
<p>logical negation 也是一个好的feature，更多出现在负面评价里面</p>
<p>除了用别人的词汇包，我们可以自创词汇包：semi-supervised learning of lexicon</p>
<p>Finding <strong>aspects or attributes</strong>: Target of sentiment：</p>
<pre><code>1. Find all highly frequent phrases
2. Filter rule like: *Occur right after a sentiment word*
3. Supervised learning. 先找到商家对应的类别（比如餐厅），然后在餐厅的常见aspect中做一个classifier判断是哪一类</code></pre><p>所以整个流程是:</p>
<ol>
<li>Extract sentences and phrases</li>
<li>Sentiment classifier: 判断是积极/消极/中性</li>
<li>对于不是中性的评论，我们找出他们的类别</li>
<li>汇总在一起</li>
</ol>
<p>还有个问题是：Baseline methods assume classes have equal frequencies. 解决办法：</p>
<ol>
<li>不用accuracy， 最好用F-score</li>
<li>Re-sampling. 变为同样样本数</li>
<li>penalize for misclassification of the rare class</li>
</ol>
<p>对于五分类问题：</p>
<ol>
<li>Linear / Ordinal regression</li>
<li>Specialized model like metric labeling</li>
</ol>
<h2 id="Information-Exaction"><a href="#Information-Exaction" class="headerlink" title="Information Exaction"></a>Information Exaction</h2><p>目的：</p>
<ol>
<li>Find and understand limited relevant parts of texts</li>
<li>Gather INformation from many pieces of texts</li>
<li>NER: Name Entity Recognition</li>
</ol>
]]></content>
      <categories>
        <category>Study</category>
        <category>Courses</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>算法心得</title>
    <url>/2020/07/02/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>以下知识来自于：</p>
<ul>
<li>普林斯顿在Coursera上面的algorithm网课</li>
<li>python算法书</li>
<li>算法导论</li>
<li>算法图解【一本书】</li>
</ul>
<p>希望有朝一日能够继续学习。在上CS577的时候应该会更新这个文档</p>
<a id="more"></a>



<h1 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>作为一个好的算法工程师，在对具体问题进行优化的时候，甚至要考虑使用插入排序还是堆排序…</p>
<p>二分查找居然是O(logn)时间…天哪，在我使用bisect的时候我一直以为是O(n)，以为要走一遍。</p>
<p><strong>大O表示法：</strong></p>
<ul>
<li>表示的是「<strong>操作数</strong>」</li>
<li>用来描述的是「<strong>增速</strong>」<ul>
<li>增速：算法的操作数，随着数据量增加的<strong>时间上升斜率</strong>。</li>
</ul>
</li>
<li>防备的是「<strong>最差情况</strong>」<ul>
<li>很多时候我们也要评估一下<strong>平均时间</strong></li>
</ul>
</li>
</ul>
<p>一个O(n!)的例子：旅行商问题。</p>
<ul>
<li>给定五个城市，以什么样的顺序走一遍，所用的路程最短？ </li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数组因为元素都是挨在一起的，所以如果知道大小的话，最好事先安排好空间。</p>
<p><strong>比较数组和链表：</strong></p>
<ol>
<li>数组的存储位置是连续的，链表没有要求</li>
<li>读取数据：数组支持「<strong>随机访问</strong>」，链表必须跑一遍。O(1) v.s. O(n)</li>
<li>插入数据：数组必须要移动插入位置之后的所有数据（如果地方不够还要把所有数据都挪一遍）链表只需要改地址。 O(n) v.s. O(1)</li>
<li>删除数据：数组必须要移动插入位置之后的所有数据，链表只需要改地址。 O(n) v.s. O(1)</li>
<li>所以如果是频繁插入，很少读取，那么应该用链表。</li>
<li>数组内部的元素类型必须都相同。</li>
</ol>
<p>大O表示法一般会忽略前面的常数。</p>
<p><strong>新的数据结构，关于Facebook如何存储用户名：</strong></p>
<ul>
<li>有一个功能是判断当前用户名是否被注册。可以用二分法来寻找，这就需要支持随机访问。可以使用数组</li>
<li>但是使用数组会带来一个问题，那就是当新用户注册完之后，需要把当前用户名插入进去，这一步就要挪动O(n)个数据，听起来太恐怖了。</li>
<li>作者提出了个新想法：将A-Z分成24个不同的链表。而每个链表的头放在一个数组里</li>
<li>这个方法告诉我们，<strong>其实数据结构并不是那几个定式，很多时候可以自由组合</strong>，特殊情况特殊对待。</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的一种替代法是将要执行的东西放入一个list中，一个挨一个的去执行，就像维持一个栈。</p>
<blockquote>
<p>如果使用循环，<strong>程序的性能可能更高</strong>。如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。</p>
</blockquote>
<p>递归函数包含两部分：base case基线条件和recursive case递归条件。前者是针对的是什么时候函数不在调用自己。</p>
<p>栈的一个使用场景：讲一个栈顶的任务弹出，把其分为好多个小人物，重新压入栈顶。</p>
<p><strong>调用栈</strong>：函数的调用使用的是调用栈</p>
<ul>
<li>调用另一个函数的时候，当前函数暂停并处于未完成状态。</li>
<li>书中提到的盒子堆（栈）代替法其实是把递归函数的调用栈具象化了。</li>
<li>当递<strong>归层数过多的时候</strong>，可以考虑尾递归优化。Python不支持尾递归优化，不过可以用知乎老哥的next和Trampline模拟出类似结果。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>分而治之的思路：</strong> Divide and Conquor</p>
<ol>
<li>找到基线情况</li>
<li>如何将问题规模缩小，直到基线情况</li>
</ol>
<p>快速排序（找pivot） v.s. 合并排序（两两分组 -&gt; 四四分组 -&gt; …）：</p>
<ul>
<li>快速排序的最糟情况是O(n^2)，但合并排序最糟情况也是O(nlogn)，为何我们还用快排？<ul>
<li>因为其实运行时间是O(c * nlogn) 在n的函数不同的时候，常量一般影响不大。但是n的函数相近的时候，c这个常量就显得很重要了。而快排的c比合并的c小。所以平均情况下快排更好。</li>
</ul>
</li>
<li>快排每层操作都是n个元素，如果分的得当，一共会有logn层。</li>
</ul>
<h2 id="散列表-Hash-Table"><a href="#散列表-Hash-Table" class="headerlink" title="散列表 Hash Table"></a>散列表 Hash Table</h2><p>散列表将数据映射成索引——存储数据的列表索引</p>
<p><strong>散列函数的要求：</strong></p>
<ul>
<li>一致性：每次输入一个数据，返回的数字都相同</li>
<li>最大可能防止冲突</li>
</ul>
<p>散列表适用于「大海捞针似」的查找</p>
<p><strong>散列表的应用：</strong></p>
<ul>
<li>DNS解析：将输入的网址转换成对应的IP地址，散列表是提供这种功能的方式之一。</li>
<li>网页的缓存：大型互联网公司将一些主页什么的早早存在自己的服务器，而不是重复的生成同样的主页。</li>
</ul>
<p>常量时间：<strong>并不意味着马上</strong>，而是说不管数据n多大，需要的时间都相同。【导数的含义】</p>
<p><strong>关于冲突：</strong></p>
<ul>
<li>冲突的一个简单的解决办法就是在对应的索引上面开一个新的链表。</li>
<li>填装因子：总数据/位置总数。当填装因子 &gt; 0.7的时候就要考虑整体迁移到一个更大的空间上了。虽然迁移很慢，但是平均下来速度还是O(1)。</li>
</ul>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>在我所知道的算法中，<strong>图算法应该是最有用的。</strong></p>
<p>一个节点可能与众多节点直接相连，这些节点被称为<strong>邻居</strong>。</p>
<p><strong>BFS解决两类问题：</strong></p>
<ol>
<li>路径存在与否？</li>
<li>路径是否最短？【如果单纯的以层数来划分的话…】</li>
</ol>
<p>BFS包含了queue的结构，把第一层放进queue，一个一个取出。满足条件则停止，不满足条件则把新的candidate放在queue的最后。通常·，为了防止重复查找，我们会建立一个set来记录查找过的人。防止有两个点互相指着对方，则陷入无限循环。</p>
<p>BFS的运行时间：O(V+E) 每一条边E都要走, 每一个顶点V都会被放入queue一次。</p>
<p><strong>拓扑排序：</strong> 比如说先刷牙才能吃饭，先打开电视才能看电视。打开电视和刷牙的顺序随意，但是看电视必不能在打开电视之前。【对这种问题，用BFS可以找到一个possible solution？不懂为何把这两个放在一起讲     】</p>
<p>树是一种特殊的图，没有指向前面的边。</p>
<h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><p>加权图中找最短距离。</p>
<p><strong>基本思路：</strong></p>
<ol>
<li>找到目前可达的最短距离的点。</li>
<li>更新这个点的邻居们的距离。（如果多走一步其实更短的话）<ul>
<li>如果更新了的话，记得也更新表中的父节点。</li>
</ul>
</li>
<li>将当前点从遍历中去掉，如果还有剩余点没有检查过，则返回1步。</li>
<li>从表中的终点开始，一步一步找父节点，输出最终路径。</li>
</ol>
<p>如果有负权边的话，狄克斯特拉算法无法使用，可以用<strong>贝尔曼福特算法。</strong></p>
<p><strong>贝尔曼福特算法：</strong> 复杂度很大O(V*E)。思路是对边不停地进行松弛操作，</p>
<ul>
<li>第一步是出发点到所有点的一步最短距离，第二步是出发点到所有点的两步最短距离。</li>
<li>因为出发点到终点，最多只要走n-1条边。所以第n-1步就可以结束了。</li>
<li>如果途中包含了负环，些许尴尬。更新就无法停止了。</li>
</ul>
<h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><p>对于NP完全问题，只能用近似算法来做。评估近似算法：</p>
<ol>
<li>速度快不快</li>
<li>得到的近似解和最优解的近似程度</li>
</ol>
<p>一些简易的判断是否为NP问题的方法：</p>
<ul>
<li>发现速度大概是O(n!)</li>
<li>涉及「所有组合」</li>
<li>不能将问题分成小问题</li>
<li>涉及序列（旅行商）</li>
<li>涉及集合（集合覆盖）</li>
<li>如果问题可以转化成已知的NP问题（旅行商、集合覆盖）</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>每次求解都可以画出一个表格：</p>
<ul>
<li>列从左到右分别是限制条件的越来越大</li>
<li>行从上到下分别是增添进不同的元素</li>
<li>方格里的元素就是要优化的对象</li>
<li>有时答案出现在最后一列，有时候也可能是表中的极值</li>
<li>当前方格的值常常取决于上一行的值（子问题可能是上面的行）</li>
<li>各行的排列顺序与结果无关</li>
</ul>
<p>动态规划不能处理的问题：</p>
<ul>
<li>比如说偷盗例子中，不能偷一个商品的一部分。背包剩40g地方，有100g的大米，动态规划只能处理0g/100g，无法处理只偷40g大米。可以考虑使用贪婪算法。</li>
<li>处理的子问题无法相互依赖，也被称为离散子问题。</li>
</ul>
<p>著名的费曼算法：</p>
<ol>
<li>把问题写下来</li>
<li>仔细思考</li>
<li>把答案写下来</li>
</ol>
<p>常见动态规划问题：</p>
<ul>
<li>最长公共子串</li>
<li>最长公共子序列</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>二叉搜索树的优点：插入删除元素需要的时间都是<code>O(log(N))</code><br>其他的数据结构：B树、红黑树、堆、伸展树</p>
<p>并行算法的开销：</p>
<ol>
<li>并行管理开销</li>
<li>负载均衡：不能一个机器忙得要命，一个机器闲着</li>
</ol>
<p>布隆过滤器 &amp; HyperLoglog：</p>
<ul>
<li>一种概率型数据结构。给出的答案有可能不对，但是很有可能是对的。很适合用于不要求答案绝对准确的情况。</li>
</ul>
<p>SHA散列算法：</p>
<ul>
<li>默认局部不敏感（原文动一点，密文动好多），也可以用Simhash这种局部敏感的散列算法。</li>
<li>Diffie-Hellman密钥交换，优雅、不难理解并被广泛使用</li>
</ul>
<p>线性规划：</p>
<ul>
<li>一个很宽泛的框架，图问题只是其中的一个子集</li>
<li>使用复杂的Simplex算法</li>
</ul>
<h1 id="Backtracking-放弃法"><a href="#Backtracking-放弃法" class="headerlink" title="Backtracking 放弃法"></a>Backtracking 放弃法</h1><p>backtracking（回溯算法）也叫试探法，它是一种系统地<strong>搜索问题的解</strong>的方法。回溯算法的基本思想是：<u>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</u></p>
<p>“回溯”的具体意思就是<strong>将不可能解或者部分解的候选尽早的舍弃掉</strong></p>
<p>深度优先算法DFS就是一种Backtracking的实例。</p>
<p>回溯算法说白了就是穷举法。不过回溯算法使用<strong>剪枝函数</strong>，剪去一些不可能到达最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</p>
<p>遍历过当前节点后，为了回溯到上一步，要去掉已经加入到结果list中的当前节点。</p>
<ul>
<li>这一步有时候可以用list的append和pop实现</li>
</ul>
<p>回溯法是一个既带有<strong>系统性</strong>又带有<strong>跳跃性</strong>的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，<u>总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索</u>，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<ul>
<li>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。</li>
<li>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<p>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
<p><a href="https://blog.csdn.net/crystal6918/article/details/51924665">https://blog.csdn.net/crystal6918/article/details/51924665</a></p>
<p>待做的题：</p>
<ol start="51">
<li>N-Queens</li>
<li>N-Queens II</li>
<li>Combination Sum</li>
<li>Combination Sum II</li>
<li>Combination Sum III</li>
<li>Permutations</li>
<li>Permutations II</li>
<li>Subsets</li>
<li>Subsets II</li>
<li>Palindrome Partitioning</li>
</ol>
<h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><p>Union Find 是用来解决动态连通性（Dynamic Connectivity）问题的算法，是并查集的一种数据结构。</p>
<p>现在学的知识只能告诉我们是否联通，算法第二部分则会给出具体的联通路径。</p>
<p>API：Application Programming Interface 应用程序编程接口</p>
<p>等价性（Equivalence Relation）:</p>
<ol>
<li>Reflexive: 自反性</li>
<li>Symmetric：对称性</li>
<li>Transitive：传递性</li>
</ol>
<p>Dynamic Connectivity包含两部分：</p>
<ol>
<li>Find Query: 给定两个点，判断他们是否联通</li>
<li>Union Command: 给定两个点，将他们联通（属于生成过程）</li>
</ol>
<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>建立一个长度为n的列表，连通的点在列表中有着相同的元素。</p>
<p>Find: 当我们想知道p和q是否相通的时候我们只需要判断列表的第q和p位是否具有相同的数字即可。</p>
<p>Union: 将其中一个数字全部变为另一个。具体变的时候Union(a,b)我们将a位置的数字变为b位置的数字</p>
<p>Quick-Find 太慢啦！初始化需要跑完n, union操作需要跑完n, find操作需要1。</p>
<p>复杂度是$n^2$，我们不能接受这样的算法</p>
<p>Quadratic algorithm does not scale with technology.</p>
<h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>建立一个树结构。还是一个长度为n的列表。每个位置对应的数值表示他的父亲节点是谁。</p>
<p>Find：只要p和q有相同的根节点就可以了</p>
<p>Union：将其中一个数字的根节点变成另一个数字的根节点的孩子节点。</p>
<p>Quick-Union 也不快！初始化需要跑完n, union操作需要跑完n, find操作需要n。</p>
<h3 id="Weighted-Quick-Union"><a href="#Weighted-Quick-Union" class="headerlink" title="Weighted Quick Union"></a>Weighted Quick Union</h3><p>我们记录树的size，确保每次都将小树连接到大树的上面</p>
<p>每个根节点的深度不超过logn.初始化需要跑完n, union操作需要跑完logn, find操作需要logn。</p>
<h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>在我们从一个节点回溯找根节点的时候，只要当前停留的节点不是根节点，我们就将这个节点指向根节点。压缩整个树的深度，因为就是深度才带来了时间的长度。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>给定N个点，M个Union。在最极端的情况下：</p>
<table>
<thead>
<tr>
<th>Quick-Find</th>
<th>Quick-Union</th>
<th>Weighted QU</th>
<th>QU+Path CP</th>
<th>WQU+Path CP</th>
</tr>
</thead>
<tbody><tr>
<td>MN</td>
<td>MN</td>
<td>N + M*logN</td>
<td>N + M*logN</td>
<td>N + M*log*N</td>
</tr>
<tr>
<td>Log* 是迭代对数函数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Applications——Percolation"><a href="#Applications——Percolation" class="headerlink" title="Applications——Percolation"></a>Applications——Percolation</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1frk8va07k3j31860yc0ti.jpg" alt=""></p>
<p>很明显，概率越小越不容易渗透。</p>
<p>Phase Transition: 在能不能渗透的某个临界值p，图像会变得十分陡峭。</p>
<p>用蒙特卡洛模拟来找出临界值p：先给一个黑色方块。将其中的黑块一个一个的变成白块，直至渗透。</p>
<p>将每一个方块用一个点来表示。每次一个点亮的白块会call function 0~4次。<br>在第一行上面建立一个虚拟点，连接了第一行的每一个点。在最后一行下面建立一个虚拟点，连接最后一行的每一个点。反复判断这两个创建的虚拟点之间是否存在通路即可。</p>
<p>最后答案是0.592746</p>
<h1 id="Analysis-of-Algorithms"><a href="#Analysis-of-Algorithms" class="headerlink" title="Analysis of Algorithms"></a>Analysis of Algorithms</h1><h2 id="观察法"><a href="#观察法" class="headerlink" title="观察法"></a>观察法</h2><p>Example: 3-Sum: Given N integers, how many triples sum to exactly zero?<br>Brute Force：三层for循环</p>
<p>很常见的一种画时间T和数据量N的图是log-log图。$T = aN^b$</p>
<p>满足指数时间增长的算法可以通过一种方法检验：Doubling Hypothesis<br>用2N的时间除于N的时间来获得一个Ratio。如果这个Ratio趋近于一个常数，就说明差不多是指数增长（log(Ratio) = b），也可以画出log-log图然后进行拟合。</p>
<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>我们首先要记住一些基本操作的耗时。比如说分配一个长度为n的向量时间是O(n)，连接两个字符串的时间也是O(n)</p>
<p>我们一般只算最耗时的那些步骤都被重复了多少次</p>
<p>所以在k-sum的例子中，最耗时的一步是$C_N^k$这一步，O($n^k$)</p>
<p>但是这种获得explcit的方式有点太难了，所以一般也不采用这种方法</p>
<h2 id="Order-Of-Growth"><a href="#Order-Of-Growth" class="headerlink" title="Order Of Growth"></a>Order Of Growth</h2><p>1, log(N), N, Nlog(N), N^2, N^3, 2^N…</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frng0jikt8j30ua0oqjuz.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frng24qffuj311c0rsn26.jpg" alt=""></p>
<h3 id="四种记号"><a href="#四种记号" class="headerlink" title="四种记号"></a>四种记号</h3><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frngs9k2d7j30wo0lqgq6.jpg" alt=""></p>
<p><strong>Common mistake：</strong> Interpreting big-Oh as an approximate model. </p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frnh4vnyhhj319a0zon2v.jpg" alt=""></p>
<h1 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h1><p>Stack: LIFO 后进先出<br>Queue: FIFO 先进先出<br>这两个都可以用linked-list / array来实现</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Resizing-Array"><a href="#Resizing-Array" class="headerlink" title="Resizing Array"></a>Resizing Array</h3><p>在Java实现中，我们需要用户给出array的默认长度。所以更灵活的，我们可以用resizing array。但是可变长度的array会有一个问题，那就是我们每向array末尾添加一个元素的时候，我们需要把之前所有元素都复制一遍，连同最新的元素放到一起。这样的话需要的操作为：$1+2+3+…+N = N(N+1)/2$. 所以我们需要一个更简单的方法来做这个事情。</p>
<h4 id="Repeated-Doubling"><a href="#Repeated-Doubling" class="headerlink" title="Repeated Doubling"></a>Repeated Doubling</h4><p>Q. How to grow array?</p>
<p>A. If array is full, create a new array of <u>twice the size</u>, and copy items.</p>
<p>Cost of inserting first N items: $N + (2^1 + 2^2 + 2^3 + … + N) \sim 3N$.</p>
<p>Q. How to shrink array?</p>
<p>A. halve size of array s[] when array is one-quarter full.</p>
<h3 id="Stack-considerations"><a href="#Stack-considerations" class="headerlink" title="Stack considerations"></a>Stack considerations</h3><p>Overflow and underflow: </p>
<ul>
<li>Underflow: <u>throw exception</u> if pop from an empty stack.</li>
<li>Overflow: use <u>resizing array</u> for array implementation.</li>
</ul>
<p>Null items:</p>
<ul>
<li>We allow null items to be inserted.</li>
</ul>
<p>Loitering:</p>
<ul>
<li>Holding a reference to an object when it is no longer needed.</li>
<li>解决方法是每次在pop之后，将不用的元素设为NULL</li>
</ul>
<h3 id="Linked-List-or-Resizing-Array"><a href="#Linked-List-or-Resizing-Array" class="headerlink" title="Linked-List or Resizing Array"></a>Linked-List or Resizing Array</h3><p>如果我们希望总时间变少而不在乎单个插入/删除的操作时间的话，选择Resizing-Array。如果我们想避免某一个添加/删除很慢很慢的情况，选择Linked-List，因为每一步操作耗时基本是相同的。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Stack里面的push和pop在Queue里面被称为enqueue和dequeue</p>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>有时候元素不是数字或字符这么好操作的东西（Generic Type），就有点麻烦。在各个语言里面实现的时候，Liknked-List比Array更容易实现</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>在Python里面是用dict来实现</p>
<p>The <u>MutableMapping</u> abstract base class, from Python’s <strong>collections</strong> module and discussed in the preceding pages, is a valuable tool when implementing a map.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpywugxnuj30y80kg41s.jpg" alt=""></p>
<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><p>Python的dict功能是用Hash Table实现的，因此查找才辣么快。</p>
<p>The novel concept for a hash table is the use of a <u>hash function to map general keys to corresponding indices</u> in a table.</p>
<p>The <strong>goal</strong> of a hash function, h, is to <u>map each key k to an integer in the range [0,N − 1]</u>, where N is the capacity of the bucket array for a hash table.</p>
<p>If there are two or more keys with the same hash value, then two different items will be mapped to the same bucket in A. In this case, we say that a collision has occurred.</p>
<p>We say that a hash function is “good” if it maps the keys in our map so as to sufﬁciently minimize collisions. For practical reasons, we also would like a hash function to be fast and easy to compute.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpzbnkc5ej30xa0h8jtt.jpg" alt=""></p>
<p>The advantage of separating the hash function into two such components is that the hash code portion of that computation is independent of a speciﬁc hash table size. This allows the development of a general hash code for each object that can be used for a hash table of any size; only the compression function depends upon the table size. This is particularly convenient, <u>because the underlying bucket array for a hash table may be dynamically resized</u>, depending on the number of items currently stored in the map.</p>
<h3 id="几种常见Hash编码方法"><a href="#几种常见Hash编码方法" class="headerlink" title="几种常见Hash编码方法"></a>几种常见Hash编码方法</h3><h4 id="Treating-the-Bit-Representation-as-an-Integer"><a href="#Treating-the-Bit-Representation-as-an-Integer" class="headerlink" title="Treating the Bit Representation as an Integer"></a>Treating the Bit Representation as an Integer</h4><p>Python relies on 32-bit hash codes. If a ﬂoating-point number uses a 64-bit representation, its bits cannot be viewed directly as a hash code.（如果当前信息不超过32-bit，那么他本身就是编码后的hash-code）如果是64-bit可以用32+32/去掉其中一个32/两个32做异或</p>
<h4 id="Polynomial-Hash-Codes"><a href="#Polynomial-Hash-Codes" class="headerlink" title="Polynomial Hash Codes"></a>Polynomial Hash Codes</h4><p>用Bit-representaion会出现的问题：The summation and exclusive-or hash codes, described above, are not good choices for character strings or other variable-length objects that can be viewed as tuples of the form $(x_0,x_1,…,x_{n-1})$, where <strong>the order of the x i ’s is signiﬁcant</strong>.</p>
<p>An alternative hash code, which does exactly this, is to choose a nonzero constant, a = 1, and use as a hash code the value:<br>$$<br>x_0a^{n-1}+x_1a^{n-2}+…+x_{n-2}a+x_{n-1}<br>$$<br>By Horner’s rule (see Exercise C-3.50), this polynomial can be computed as:<br>$$<br>x_{n-1}+a(x_{n-2}+a(x_{n-3}+…+a(x_2+a(x_1+ax_0))))<br>$$<br>We have done some experimental studies that suggest that <u>33, 37, 39, and 41</u> are particularly good choices for a when working with character strings that are English words.</p>
<h4 id="Cyclic-Shift-Hash-Codes"><a href="#Cyclic-Shift-Hash-Codes" class="headerlink" title="Cyclic-Shift Hash Codes"></a>Cyclic-Shift Hash Codes</h4><p>A variant of the polynomial hash code replaces multiplication by a with a cyclic shift of a partial sum by a certain number of bits.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpzy363p5j30xg09440q.jpg" alt=""></p>
<p>python里面的hash(x)可以计算一个x的hash值，However, only <u>immutable data types</u> are deemed hashable in Python. This restriction is meant to ensure that a particular object’s hash code remains constant during that object’s lifespan. Among Python’s built-in data types, <u>the immutable int, ﬂoat, str, tuple, and frozenset</u> classes produce robust hash codes via the hash function. Instances of <u>user-deﬁned classes</u> are treated as unhashable by default, with a TypeError raised by the hash function.</p>
<p>An important rule to obey is that if x == y, then hash(x) == hash(y).</p>
<h3 id="Compression-Functions"><a href="#Compression-Functions" class="headerlink" title="Compression Functions"></a>Compression Functions</h3><p>mapping the hash code integer into the range [0,N −1]. A good compression function is one that <u>minimizes the number of collisions for a given set of distinct hash codes.</u></p>
<h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><p>分治方法将问题划为互不相交的子问题，递归的求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题有公共的子子问题。在这种情况下，DP对每个子子问题只会求解一次，将其<u>保存在一个表格</u>中。动态规划常用来解决<strong>最优化问题</strong></p>
<p>动态规划的四个步骤：</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归的定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造最优解</li>
</ol>
<p>计算一个p*q矩阵和一个q*r矩阵的成绩，需要计算p*q*r个标量乘法</p>
<p>钢条切割中每一个分段都是相同的，所有长度为k的钢条都属于一个子问题。但是矩阵链乘法每一个长度为k的子链都不相同，不属于一个子问题。</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frteyli23mj31260s07qh.jpg" alt=""></p>
<h1 id="Numeric-Optimization"><a href="#Numeric-Optimization" class="headerlink" title="Numeric Optimization"></a>Numeric Optimization</h1><h3 id="Newton’s-Method"><a href="#Newton’s-Method" class="headerlink" title="Newton’s Method"></a>Newton’s Method</h3><p>算法</p>
<p>优点</p>
<ul>
<li>fast convergence (under some condition)</li>
</ul>
<p>缺点</p>
<ul>
<li>Need second order derivative （二阶连续可导，为了防止出现切线斜率为0从而与x轴没有交点，如果此时找到了二阶导数为0的点，就是一个极值点）</li>
<li>Only 1-D</li>
</ul>
<h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>算法</p>
<p>优点</p>
<ul>
<li>n-D</li>
<li>only need first order derivative</li>
</ul>
<p>缺点</p>
<ul>
<li>Speed depends</li>
<li>Rosenbrock函数效果不太好，出现锯齿状（jag）</li>
</ul>
<h3 id="Golden-Section"><a href="#Golden-Section" class="headerlink" title="Golden Section"></a>Golden Section</h3><p>算法</p>
<p>用secant line (割线) 代替 tangent line（切线）</p>
<p>优点</p>
<ul>
<li>No derivative required</li>
<li>Fast</li>
</ul>
<p>缺点</p>
<ul>
<li>Only works on U-shape function. (可以考虑将一个大的函数切成几个小的U-shape部分)</li>
<li>1-D</li>
</ul>
<h3 id="Nelder-Mead"><a href="#Nelder-Mead" class="headerlink" title="Nelder-Mead"></a>Nelder-Mead</h3><p>算法</p>
<p>用一个三角形来估计切线</p>
<p>优点</p>
<ul>
<li>n-D</li>
</ul>
<p>缺点</p>
<ul>
<li>converge slowly</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1fs87tgwbsrj30ge0fiq7x.jpg" alt=""></p>
<h1 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h1><p>对称性+传递性无法推出自反性的例子：平行关系</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Others</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>统计学习笔记</title>
    <url>/2020/07/02/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>记录一下学统计的时候遇到的一些问题</p>
<a id="more"></a>



<h1 id="旧版"><a href="#旧版" class="headerlink" title="旧版"></a>旧版</h1><p>17.11.13<br>###为什么我们要用R里面的anova函数比较多个模型？<br><a href="https://stats.stackexchange.com/questions/115304/interpreting-output-from-anova-when-using-lm-as-input" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/115304/interpreting-output-from-anova-when-using-lm-as-input</a></p>
<p>①First of all, you may be perfectly satisfied with the summary output, and that’s fine. However, the ANOVA table may offer some advantages. First, if you have a categorical / factor variable with more than two levels, the summary output is hard to interpret. It will give you tests of individual levels against the reference level, but won’t give you a test of the factor as a whole</p>
<p>②Another reason you might prefer to look at an ANOVA table is that it allows you to use information about the possible associations between your independent variables and your dependent variable that gets thrown away by the t-tests in the summary output. Consider your own example, you may notice that the p-values from the two don’t match (e.g., for v1, the $p$-value in the summary output is 0.93732, but in the ANOVA table it’s 0.982400). The reason is that your variables are not perfectly uncorrelated</p>
<p>The result of this is that there are sums of squares that could be attributed to more than one of the variables. The t-tests are equivalent to ‘type III’ tests of the sums of squares, but other tests are possible. The default ANOVA table uses ‘type I’ sums of squares, which can allow you to make more precise–and more powerful–tests of your hypotheses</p>
<p>Anova的目的：partition the sums of squares</p>
<p>###Further understanding of Type 123 test of RSS:<br><a href="https://stats.stackexchange.com/questions/20452/how-to-interpret-type-i-type-ii-and-type-iii-anova-and-manova/20455#20455" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/20452/how-to-interpret-type-i-type-ii-and-type-iii-anova-and-manova/20455#20455</a></p>
<p>Lets imagine that there are just two factors A and B (and we’ll throw in the A*B interaction later to distinguish type II SS). Further, lets imagine that nij不完全一样。<br>Now your two factors are correlated with each other.The problem with your factors being correlated is that there are sums of squares that are associated with both A and B. </p>
<p>When computing an ANOVA (or any other linear regression), we want to partition the sums of squares. A partition puts all sums of squares into one and only one of several subsets. (For example, we might want to divide the SS up into A, B and error.) However, since your factors (still only A and B here) are not orthogonal there is no unique partition of these SS. In fact, there can be very many partitions, and if you are willing to slice your SS up into fractions (e.g., “I’ll put .5 into this bin and .5 into that one”), there are infinite partitions. A way to visualize this is to imagine the MasterCard symbol: The rectangle represents the total SS, and each of the circles represents the SS that are attributable to that factor, but notice the overlap between the circles in the center, those SS could be given to either circle.</p>
<p><img src="https://i.stack.imgur.com/Dy8mt.jpg" alt=""></p>
<p>The question is: How are we to choose the ‘right’ partition out of all of these possibilities? Let’s bring the interaction back in and discuss some possibilities:<br>Type I SS:<br>    •    SS(A)<br>    •    SS(B|A)<br>    •    SS(A<em>B|A,B)<br>Type II SS:<br>    •    SS(A|B)<br>    •    SS(B|A)<br>    •    SS(A</em>B|A,B)<br>Type III SS:<br>    •    SS(A|B,A<em>B)<br>    •    SS(B|A,A</em>B)<br>    •    SS(A*B|A,B)</p>
<p>Notice how these different possibilities work. Only type I SS actually uses those SS in the overlapping portion between the circles in the MasterCard symbol. That is, the SS that could be attributed to either A or B, are actually attributed to one of them when you use type I SS (specifically, the one you entered into the model first). In both of the other approaches, the overlapping SS are not used at all. Thus, type I SS gives to A all the SS attributable to A (including those that could also have been attributed elsewhere), then gives to B all of the remaining SS that are attributable to B, then gives to the A<em>B interaction all of the remaining SS that are attributable to A</em>B, and leaves the left-overs that couldn’t be attributed to anything to the error term.</p>
<p>Type III SS only gives A those SS that are uniquely attributable to A, likewise it only gives to B and the interaction those SS that are uniquely attributable to them. The error term only gets those SS that couldn’t be attributed to any of the factors. Thus, those ‘ambiguous’ SS that could be attributed to 2 or more possibilities are not used. If you sum the type III SS in an ANOVA table, you will notice that they do not equal the total SS. In other words, this analysis must be wrong, but errs in a kind of epistemically conservative way. Many statisticians find this approach egregious, however government funding agencies (I believe the FDA) requires their use.</p>
<p>The type II approach is intended to capture what might be worthwhile about the idea behind type III, but mitigate against its excesses. Specifically, it only adjusts the SS for A and B for each other, not the interaction. However, in practice type II SS is essentially never used. You would need to know about all of this and be savvy enough with your software to get these estimates, and the analysts who are typically think this is bunk.<br>There are more types of SS (I believe IV and V). They were suggested in the late 60’s to deal with certain situations, but it was later shown that they do not do what was thought. Thus, at this point they are just a historical footnote.</p>
<p>As for what questions these are answering, you basically have that right already in your question:<br>    •    Estimates using type I SS tell you how much of the variability in Y can be explained by A, how much of the residual variability can be explained by B, how much of the remaining residual variability can be explained by the interaction, and so on, in order.<br>    •    Estimates based on type III SS tell you how much of the residual variability in Y can be accounted for by A after having accounted for everything else, and how much of the residual variability in Y can be accounted for by B after having accounted for everything else as well, and so on. (Note that both go both first and last simultaneously; if this makes sense to you, and accurately reflects your research question, then use type III SS.)</p>
<p>2017.11.14<br>###What does Standardized Residuals mean?</p>
<p>Intuition:every residual has different variance, so we need to consider standardized residuals.</p>
<p>When you compare the cells, the standardized residual makes it easy to see which cells are contributing the most to the chi-square value, and which are contributing the least.If your sample is large enough, the standardized residual can be roughly compared to a z-score. Standardization can work even if your variables are not normally distributed.<br>    •    If the residual is less than -2, the cell’s observed frequency is less than the expected frequency.<br>    •    Greater than 2 and the observed frequency is greater than the expected frequency. 之所以用2是因为95%双边正态</p>
<p>2017.11.15</p>
<p>###One Sample T-test:</p>
<p>为了检验所给数据是否来自同一个均值总体。需要给出一个原假设Ho：μ=μ0</p>
<p>The test statistic is calculated as:<br>R code： t.test(a, mu=120)</p>
<p>2017.11.19<br>###为什么我们要对数据进行变换（比如log）：<br>有时候我们希望残差能满足高斯马尔科夫假设。</p>
<p>2017.11.20<br>###Forward and Backward selection 的主要差别：</p>
<p>Forward selection has drawbacks, including the fact that each addition of a new feature may render one or more of the already included feature non-significant (p-value&gt;0.05). An alternate approach which avoids this is backward selection.The backward method is generally the preferred method, because the forward method produces so-called suppressor effects. These suppressor effects occur when predictors are only significant when another predictor is held constant.</p>
<p>2017.11.25</p>
<h3 id="Added-Variable-Plot-Partial-Regression-Plot"><a href="#Added-Variable-Plot-Partial-Regression-Plot" class="headerlink" title="Added Variable Plot (Partial Regression Plot)"></a>Added Variable Plot (Partial Regression Plot)</h3><p><a href="https://stats.stackexchange.com/questions/125561/what-does-an-added-variable-plot-partial-regression-plot-explain-in-a-multiple" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/125561/what-does-an-added-variable-plot-partial-regression-plot-explain-in-a-multiple</a></p>
<p>可以告诉我们如果变量之间存在线性相关的话，不能在回归模型中单独对Y和某一个X画图。可能会有Omitted-Variable Bias.</p>
<p>主要原理：纵坐标画Y对除了我们关心的Xi之外其他的X拟合出来的残差，横坐标画我们所关心的Xi对其他所有X拟合出来的残差。R中car包里的avPlots可以实现这个功能。</p>
<p>For illustration I will take a less complex regression model Y=β1+β2X2+β3X3+ϵ where the predictor variables X1 and X2 may be correlated. Let’s say the slopes β2 and β3 are both positive so we can say that (i) Y increases as X2 increases, if X3 is held constant, since β2 is positive; (ii) Y increases as X3 increases, if X2 is held constant, since β3 is positive.</p>
<p>Note that it’s important to interpret multiple regression coefficients by considering what happens when the other variables are held constant (“ceteris paribus”). Suppose I just regressed Y against X2 with a model Y=β′1+β′2X2+ϵ′. My estimate for the slope coefficient β′2, which measures the effect on Y of a one unit increase in X2 without holding X3 constant, may be different from my estimate of β2 from the multiple regression - that also measures the effect on Y of a one unit increase in X2, but it does hold X3 constant. The problem with my estimate β′2^ is that it suffers from omitted-variable bias if X2 and X3 are correlated.</p>
<p>To understand why, imagine X2 and X3 are negatively correlated. Now when I increase X2 by one unit, I know the mean value of Y should increase since β2&gt;0. But as X2 increases, if we don’t hold X3 constant then X3 tends to decrease, and since β3&gt;0 this will tend to reduce the mean value of Y. So the overall effect of a one unit increase in X2 will appear lower if I allow X3 to vary also, hence β2′&lt;β2. Things get worse the more strongly X2 and X3 are correlated, and the larger the effect of X3 through β3 - in a really severe case we may even find β2′&lt;0 even though we know that, ceteris paribus, X2 has a positive influence on Y!</p>
<p>A lot of the value of an added variable plot comes at the regression diagnostic stage, especially since the residuals in the added variable plot are precisely the residuals from the original multiple regression. This means outliers and heteroskedasticity can be identified in a similar way to when looking at the plot of a simple rather than multiple regression model. Influential points can also be seen - this is useful in multiple regression since some influential points are not obvious in the original data before you take the other variables into account. In my example, a moderately large X2 value may not look out of place in the table of data, but if the X3 value is large as well despite X2 and X3 being negatively correlated then the combination is rare. “Accounting for other predictors”, that X2 value is unusually large and will stick out more prominently on your added variable plot.</p>
<p>∗∗ More technically they would be the residuals from running two other multiple regressions: the residuals from regressing Y against all predictors other than X2 go on the vertical axis, while the residuals from regression X2 against all other predictors go on the horizontal axis. This is really what the legends of “Y given others” and “X2 given others” are telling you. Since the mean residual from both of these regressions is zero, the mean point of (X2 given others, Y given others) will just be (0, 0) which explains why the regression line in the added variable plot always goes through the origin. But I often find that mentioning the axes are just residuals from other regressions confuses people (unsurprising perhaps since we now are talking about four different regressions!) so I have tried not to dwell on the matter. Comprehend them as “X2 given others” and “Y given others” and you should be fine.</p>
<p>2017.12.3</p>
<h3 id="Imbalanced-Classification-Problems"><a href="#Imbalanced-Classification-Problems" class="headerlink" title="Imbalanced Classification Problems"></a>Imbalanced Classification Problems</h3><p><a href="https://www.analyticsvidhya.com/blog/2016/03/practical-guide-deal-imbalanced-classification-problems/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2016/03/practical-guide-deal-imbalanced-classification-problems/</a></p>
<p>Definition: An imbalanced classification problem is one in which the dependent variable has imbalanced proportion of classes. In other words, a data set that exhibits an unequal distribution between its classes is considered to be imbalanced.</p>
<p>Reason: Below are the reasons which leads to reduction in accuracy of ML algorithms on imbalanced data sets:<br>    1.    ML algorithms struggle with accuracy because of the unequal distribution in dependent variable.<br>    2.    This causes the performance of existing classifiers to get biased towards majority class.<br>    3.    The algorithms are accuracy driven i.e. they aim to minimize the overall error to which the minority class contributes very little.<br>    4.    ML algorithms assume that the data set has balanced class distributions.<br>    5.    They also assume that errors obtained from different classes have same cost (explained below in detail).</p>
<p>Solution：Below are the methods used to treat imbalanced datasets:<br>    1.    Undersampling<br>    2.    Oversampling<br>    3.    Synthetic Data Generation<br>    4.    Cost Sensitive Learning</p>
<p>2017.12.5</p>
<h3 id="Advantages-about-Mid-P-Value"><a href="#Advantages-about-Mid-P-Value" class="headerlink" title="Advantages about Mid P-Value"></a>Advantages about Mid P-Value</h3><p>①The mid P is less conservative (that is more powerful)<br>②For larger samples the P value obtained from a χ² test with Yates’ correction will correspond to the conventional approach, and the P value from the uncorrected test will correspond to the mid P value.——应该是说小样本因为离散程度更高，所以需要mid p-value.大样本一般不用mid p-value</p>
<h3 id="Fisher-Exact-Test"><a href="#Fisher-Exact-Test" class="headerlink" title="Fisher Exact Test"></a>Fisher Exact Test</h3><p><a href="http://www2.fiu.edu/~howellip/Fisher.pdf" target="_blank" rel="noopener">http://www2.fiu.edu/~howellip/Fisher.pdf</a><br>让我重新了解了p值的概念。<br>一下讨论的p-值都建立在原假设H0：π=π0<br>我们往往定义p值的时候，曲线都是随着x的变化，中间高两边低。所以很自然的，就会误以为，p值是对当x等于或者大于（小于）某一特定值的y进行求和。殊不知，其实p值关心的更多是y！如果给出一个中间低两边高的分布。那么<br>①单边p值：算出一个若H0成立时候的均值。若观测值大于均值，那么P值就是大于等于观测值的概率。如果观测值小于均值，那么P值就是小于等于观测值的概率。<br>②双边p值：对于所有小于观测值的情况，进行积分。</p>
<p>2017.12.7</p>
<h3 id="各种Independence之间的关系"><a href="#各种Independence之间的关系" class="headerlink" title="各种Independence之间的关系"></a>各种Independence之间的关系</h3><p><a href="https://onlinecourses.science.psu.edu/stat504/node/108" target="_blank" rel="noopener">https://onlinecourses.science.psu.edu/stat504/node/108</a><br>    1.    Mutual independence – all variables are independent from each other, denoted (A,B,C)  or A⊥⊥B⊥⊥C .<br>    2.    Joint independence – two variables are jointly independent of the third,  denoted (AB,C)  or AB⊥⊥C .<br>    3.    Marginal independence – two variables are independent while ignoring the third, e.g., θAB=1, denoted (A,B) .<br>    4.    Conditional independence – two variables are independent given the third, e.g., θAB(C=k)=1 for all k=1,2,…,K, denoted (AC,BC)  or A⊥⊥B|C .<br>    5.    Homogeneous associations – conditional (partial) odds-ratios don’t depend on the value of the third variable, denoted (AB,AC,BC) .<br>Before we look at the details, here is a summary of the relationships among these models:<br>    ▪    Mutual independence implies joint independence, i.e., all variables are independent of each other.<br>    ▪    Joint independence implies marginal independence, i.e., one variable is independent of the other two.<br>    ▪    Marginal independence does NOT imply joint independence.<br>    ▪    Marginal independence does NOT imply conditional independence.<br>    ▪    Conditional independence does NOT imply marginal independence.</p>
<p>2017.12.11<br>在回归分析图中，经常有一道红线。红线是x-y 坐标关系的非参数拟合，并不是均值。 </p>
<p>2018.1.23</p>
<h3 id="logistic回归的两种报错原因："><a href="#logistic回归的两种报错原因：" class="headerlink" title="logistic回归的两种报错原因："></a>logistic回归的两种报错原因：</h3><p><a href="http://blog.csdn.net/csqazwsxedc/article/details/52033506" target="_blank" rel="noopener">http://blog.csdn.net/csqazwsxedc/article/details/52033506</a></p>
<p>2018.1.27</p>
<h3 id="如何确定Experimental-Unit："><a href="#如何确定Experimental-Unit：" class="headerlink" title="如何确定Experimental Unit："></a>如何确定Experimental Unit：</h3><p><a href="http://www.isogenic.info/html/6__experimental_unit.html#more" target="_blank" rel="noopener">http://www.isogenic.info/html/6__experimental_unit.html#more</a></p>
<p>帮助区别了一个动物/一群动物，甚至有时候还可以在一个实验中存在多种EU</p>
<p>2018.1.29<br>今天和Bean聊天：<br>①iid个体中每一个数据点都提供了和前一个一样多的信息。而如果有相关性，比如说ρ=0.99. 那么基本上第一个数据点就代表了全部信息。后面的数据点与第一个相比都没有提供足够多的信息。<br>②当我们说到充分统计量的时候，老师说每一个x向量的Sample-Size都是n。如果我们有多个数据比如说一个做了10次，一个做了20次。如果是iid的话，我们应该把他们放到一起变成30个。这样减少方差，没必要分成两个来考虑。</p>
<p>2018.1.30<br>Fangfang：在2-sample-t-test中，两个分布可以不用都是Normal。只要他们都是对称的，或者skewed的程度差不多就可。</p>
<h1 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h1><ul>
<li>Gamma 函数不是单调递增的<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Gamma_plot.svg/650px-Gamma_plot.svg.png" alt=""></li>
<li></li>
<li>检验同方差：Bartlett’s test（采用均值和MSE。不是很robust, 最好没有outlier，很需要正态假设）, the Levene’s test（采用中位数和MAE，更robust）</li>
<li>One-way-anova中计算test-power的方式还可以用OC Curves（operating characteristic）$\Phi^2=\frac{n\delta^2}{2a\sigma^2}$其中$\delta$指的是组间最大差值:$max(t_i)-min(t_i)$</li>
<li>在计算线性回归的方差时，RSS=残差平方和/n而不是除n-1，因为原假设下残差均值为0</li>
</ul>
<p>为什么在公式 $y=\beta_0+\beta_1x$ 中，$\hat{\beta_0} \ne \bar{y}$ ?<br>答：因为首先我们知道拟合的直线肯定会经过$(\bar{x},\bar{y})$ . 所以不一定有$\bar{x} = 0$ .除非列正交，导致$\mathbb{1}_nx = 0$.</p>
<p>在所有缺失x但是不缺y的数据中，将x填成$\bar{x}$ ，只会改变拟合直线的截距而不改变斜率。 </p>
<p><img src="https://pic4.zhimg.com/80/v2-85090cf884b42c46ed50148ede175def_hd.jpg" alt=""></p>
<ul>
<li><p>one sample t-test 分母为什么是$\sqrt{n}$ ? 因为$\bar{X}$ 的方差是$\sigma^2 / n$ </p>
</li>
<li><p>Boxplot上下的线应该是1.5IQR，但是会停在1.5IQR以内最大值/最小值（所以有时候那条线可能会比1.5IQR短）</p>
</li>
<li><p>E(X1 + X2) = E(X1) + E(X2) 即使X1, X2不是独立的。因为在double integral的时候$\int X_1f(X_1, X_2) dX_1dX_2$ 会把X2积掉，从而只剩下X1的边缘分布。</p>
</li>
</ul>
<p>对于二维数据，什么时候PCA跟Linear-Regression重合？<br>因为两条线都过X_mean, Y_mean，所以只需要斜率</p>
<ul>
<li>PCA1的斜率：loading_y / loading_x</li>
<li>lm的斜率：cov(X,Y) / var(X)</li>
</ul>
<p>PCA只是Maximize Variance，如果我们想知道什么方向是最Skewness的，我们可以分解更高阶矩</p>
<p>MDS(Multidimensional Scaling)就像是把一个橘子皮撕开，张开在2维平面，而PCA不动橘子，只是改变我们观察的角度。</p>
<p><strong>实对称阵</strong>【需要对称】不同特征值的特征向量正交。</p>
<p><strong>Loh’s Bootstrap Project</strong></p>
<p>一个错误：对一个样本我想获得很多SD版本的CI，比如说我做了500次Bootstrap，我得到了一个SD，我用这个SD去套用了这500次的数据。暗含的意思是我觉得这500次数据的SD都是这个SD。但其实不是，因为SD取决于样本，而样本已经变了。正确的方法应该是，对于每一个bootstrap样本，都进行<strong>nested bootstrap来获取SD</strong></p>
<p>一个错误：计算Coverage的时候，比如我有4000个样本，获得了4000个不同的calibrated-alpha。我算了一下这4000个alpha的均值，然后再取新的4000个样本，用这个均值alpha来计算coverage。老师说不应当，应该直接用这4000个样本配合上对应的4000个不同的alpha直接计算。</p>
<p>我们不能通过R-output有几个变量带星就说明他们significant，要用bonferonni correction…</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Statistics</category>
        <category>统计学习</category>
      </categories>
  </entry>
  <entry>
    <title>耶稣说</title>
    <url>/2020/07/03/%E8%80%B6%E7%A8%A3%E8%AF%B4/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用来记录日常的感想，以及周五周日的聚会。</p>
<a id="more"></a>





<h1 id="2020-08-09-Why-is-sex-such-a-big-deal"><a href="#2020-08-09-Why-is-sex-such-a-big-deal" class="headerlink" title="2020/08/09 Why is sex such a big deal?"></a>2020/08/09 Why is sex such a big deal?</h1><p><a href="http://www.blackhawkchurch.org/sundaymessages/?enmse=1&enmse_sid=9005&enmse_mid=9277">Why is sex such a big deal? — Blackhawk</a></p>
<p>几点：</p>
<ol>
<li><p>现在的社会在性方面很混乱（55%的美国女性和22%的美国男性曾有过被性骚扰的经历…）</p>
</li>
<li><p>现在的社会，已经距离原来的正统的性很远了。（限制在男女的婚姻中）</p>
</li>
<li><p>Sexual immorality确实不好，但也不是圣经中说的「最糟糕的罪」。这个牧师认为或许「拜偶像」是最糟糕的罪。</p>
<blockquote>
<p>《马可福音》7:20-23</p>
<p>20 又说，从人里面出来的，那才能污秽人。<br>21 因为从里面，就是从人心里，发出恶念，苟合，<br>22 偷盗，凶杀，奸淫，贪婪，邪恶，诡诈，淫荡，嫉妒，谤？？，骄傲，狂妄。<br>23 这一切的恶，都是从里面出来，且能污秽人。</p>
</blockquote>
</li>
</ol>
<p>Sex is <strong>far from a simple pleasure</strong>. The emotional pain that linger after poor sexual decision-making, at any age, suggests a complex morality inherent to human sexuality.</p>
<blockquote>
<p>《罗马书》13：13</p>
<p>行事为人要端正，好像行在白昼。不可荒宴醉酒。不可好色邪荡。不可争竞嫉妒。</p>
</blockquote>
<p>为什么我们要对性有这么多的限制？正是因为它很重要。</p>
<ul>
<li>就像著名的蒙娜丽莎，为什么被护栏围住，用防弹玻璃包装？很多的限制保护，正是因为它很宝贵。</li>
</ul>
<p>Naked = Vulnerable / Intimate</p>
<p>假设当你第一次做爱的时候，你还没结婚。在结束之后不仅有身体上的愉悦，还有一种精神上的向往，我想和这个人永远在一起。如果此时没有婚姻，<strong>这种感情就没有保护</strong>。因为那个和你上床的人很可能会离开你，然后和其他人上床。这时你的心就会很受伤，但是社会会告诉你，别这么严肃嘛，要把爱和身体分开。于是为了不让这种伤害的感觉重来一遍，你把自己的心封闭了。这时候，性就变成了一种满足身体的需要，而没有了与人联结的伟大意义。</p>
<p>关于同性恋：It must be two genders for life to take bless. 圣经中提到同性恋的时候，都是负面词汇。</p>
<p>单身的榜样：耶稣、保罗。</p>
<p>Cohabitation：同居生活</p>
<ul>
<li>It’s about risk-management. It’s inheritly unstable.</li>
<li>很多人说你看我朋友谁谁谁同居了之后结婚了。但是你是不是也有朋友同居了之后没结婚呢？</li>
</ul>
<p>Shame &amp; Guilt：</p>
<ul>
<li>Guilt：I did something bad. Shame: I am bad.</li>
</ul>
<h1 id="2020-08-07-正心诚意侍奉神"><a href="#2020-08-07-正心诚意侍奉神" class="headerlink" title="2020/08/07 正心诚意侍奉神"></a>2020/08/07 正心诚意侍奉神</h1><p>周五团契资料：<a href="https://www.youtube.com/watch?v=jBb1AaDl29c">正心诚意侍奉神——寇绍涵</a></p>
<blockquote>
<p>《罗马书》12:1 所以弟兄们，我以神的慈悲劝你们，将身体献上，当作活祭，是圣洁的，是神所喜悦的。你们如此事奉，乃是理所当然的。</p>
</blockquote>
<p>与神互动的方式，不是交换。恩典是白白得来的，为何服侍？</p>
<ul>
<li>服侍是自己成长的过程，反而是一个加倍的恩典。</li>
<li>没有服侍，领受恩典却活在老我，或许会失去恩典。（以色列人的例子）</li>
</ul>
<blockquote>
<p>《历代志》22：4</p>
<p>大卫说，我儿子所罗门还年幼娇嫩，要为耶和华建造的殿宇必须高大辉煌，使名誉荣耀传遍万国。所以我要为殿预备材料。于是，大卫在未死之先预备的材料甚多。</p>
</blockquote>
<ul>
<li>大卫提出建殿请求，<u>被上帝拒绝后</u>，大卫仍然欢喜的为所罗门准备材料。【正确感恩的心态】<ul>
<li>有时候会想，我做了半天，名字都挂在别人名下，我不做算了。其实，别人是否知道，后世如何纪念，都不重要。</li>
</ul>
</li>
</ul>
<blockquote>
<p>《路加福音》17: 14-18</p>
<p>14 耶稣看见，就对他们说，你们去把身体给祭司察看。他们去的时候就洁净了。<br>15 内中有一个见自己已经好了，就回来大声归荣耀与神。<br>16 又俯伏在耶稣脚前感谢他。这人是撒玛利亚人。<br>17 耶稣说，洁净了的不是十个人吗？那九个在哪里呢？<br>18 除了这外族人，再没有别人回来归荣耀与神吗？</p>
</blockquote>
<ul>
<li>不感恩的反例</li>
</ul>
<blockquote>
<p>《民数记》11：24 - 29</p>
<p>24 摩西出去，将耶和华的话告诉百姓，又招聚百姓的长老中七十个人来，使他们站在会幕的四围。<br>25 耶和华在云中降临，对摩西说话，把降与他身上的灵分赐那七十个长老。灵停在他们身上的时候，他们就受感说话，以后却没有再说。<br>26 但有两个人仍在营里，一个名叫伊利达，一个名叫米达。他们本是在那些被录的人中，却没有到会幕那里去。灵停在他们身上，他们就在营里说预言。<br>27 有个少年人跑来告诉摩西说，伊利达，米达在营里说预言。<br>28 摩西的帮手，嫩的儿子约书亚，就是摩西所拣选的一个人，说，请我主摩西禁止他们。<br>29 摩西对他说，你为我的缘故嫉妒人吗？惟愿耶和华的百姓都受感说话。愿耶和华把他的灵降在他们身上。</p>
</blockquote>
<ul>
<li>对神主权的尊重。摩西认识很清楚，神愿意把这个灵分给谁就分给谁。（想起了有基督徒嫉妒莫扎特的才华）</li>
</ul>
<blockquote>
<p>《马可福音》9：38-40</p>
<p>38 约翰对耶稣说，夫子，我们看见一个人，奉你的名赶鬼，我们就禁止他，因为他不跟从我们。<br>39 耶稣说，不要禁止他。因为没有人奉我名行异能，反倒轻易毁谤我。<br>40 不敌挡我们的，就是帮助我们的。</p>
</blockquote>
<ul>
<li>神可以用任何人成就他的美意。约翰这边眼光窄了。</li>
<li>教会里没有「我的人」，我们都是神的人。</li>
<li>关于「合一」，我们要在真道上站稳，在小事情上，可以有不同（前两个例子）。如果我们只是追求「表面的和平」，我们甚至可以和其他宗教合一。</li>
</ul>
<blockquote>
<p>《使徒行传》14：15-18</p>
<p>15 诸君，为什么作这事呢？我们也是人，性情和你们一样。我们传福音给你们，是叫你们离弃这些虚妄，归向那创造天，地，海，和其中万物的永生神。<br>16 他在从前的世代，任凭万国各行其道。<br>17 然而为自己未尝不显出证据来，就如常施恩惠，从天降雨，赏赐丰年，叫你们饮食饱足，满心喜乐。<br>18 二人说了这些话，仅仅地拦住众人不献祭与他们。</p>
</blockquote>
<ul>
<li>保罗和巴拿巴行了一件神迹，被众人当做神人来崇拜，他们二人疯狂拒绝、劝诫。</li>
<li>有的时候神的仆人把自己捧得太高，也有时候我们把神的仆人捧得太高。</li>
</ul>
<blockquote>
<p>《使徒行传》8：20-21</p>
<p>20 彼得说，你的银子，和你一同灭亡吧。因你想神的恩赐，是可以用钱买的。<br>21 你在这道上，无分无关。因为在神面前，你的心不正。</p>
</blockquote>
<ul>
<li>西门想要花钱来买到这种保罗行异能的能力。</li>
<li>我们想要「神的恩赐」，不想要「赐恩的神」</li>
<li>我们要把神带到神的面前，不要把人带到我们面前。（想到了统计学，老罗把大家带到统计面前，而不是把大家带到他的面前）</li>
</ul>
<blockquote>
<p>《耶利米书》40：4-6</p>
<p>4 现在我解开你手上的链子，你若看与我同往巴比伦去好，就可以去，我必厚待你。你若看与我同往巴比伦去不好，就不必去。看哪，全地在你面前，你以为哪里美好，哪里合宜，只管上哪里去吧。<br>5 耶利米还没有回去，护卫长说，你可以回到沙番的孙子亚希甘的儿子基大利那里去。现在巴比伦王立他作犹大城邑的省长。你可以在他那里住在民中，不然，你看哪里合宜就可以上哪里去。于是护卫长送他粮食和礼物，释放他去了。<br>6 耶利米就到米斯巴见亚希甘的儿子基大利，在他那里住在境内剩下的民中。</p>
</blockquote>
<ul>
<li>耶利米让大家投降，否则灭亡（命定的结果），结果大家不听，还把耶利米丢在牢里。</li>
<li>耶利米用动作证明他的心思意念——留下来，不求外邦的荣华富贵。</li>
</ul>
<blockquote>
<p>《路加福音》7：19</p>
<p>19 他便叫了两个门徒来，打发他们到主那里去，说，那将要来的是你吗？还是我们等候别人呢？</p>
</blockquote>
<ul>
<li>做了正确的事情，被投到了牢里。没看到神拯救他，施洗约翰也动摇了。</li>
</ul>
<blockquote>
<p>《约翰福音》4：28-29</p>
<p>28 那妇人就留下水罐子，往城里去，对众人说，<br>29 你们来看，有一个人将我素来所行的一切事，都给我说出来了，莫非这就是基督吗？</p>
</blockquote>
<ul>
<li>撒玛利亚妇人对待福音的回应，向众人传讲，不惜说出自己的黑历史，只要自己的这种软弱能见证弥赛亚。</li>
<li>我们不是一定要很成功，有学问，地位高的人才能为神作见证——替上帝乱开空头支票。</li>
</ul>
<blockquote>
<p>《马太福音》8：33-34</p>
<p>33 放猪的就逃跑进城，将这一切事，和被鬼附的人所遭遇的，都告诉人。<br>34 合城的人，都出来迎见耶稣。既见了，就央求他离开他们的境界。</p>
</blockquote>
<ul>
<li>看见了福音，请耶稣走。为了救一个人，死了两千头猪。只看到了猪的价格，没看到一个人得洁净的价值。</li>
</ul>
<h1 id="2020-07-26-帖撒罗尼迦前书"><a href="#2020-07-26-帖撒罗尼迦前书" class="headerlink" title="2020/07/26 帖撒罗尼迦前书"></a>2020/07/26 帖撒罗尼迦前书</h1><p>周日团契资料：<a href="https://www.youtube.com/watch?v=J4ayCy28uSI&list=PL9HSDtAszxDr1JMCmOB90irnIHVMaswLP&index=3">帖撒罗尼迦前书2</a></p>
<p>要在爱里教导。像母亲一样的爱，像父亲一样的教导。</p>
<p>服侍/侍奉的目标：若是我们侍奉的人都不知道方向，我们要将人带到哪里去呢？</p>
<h1 id="2020-07-24-基督的所是-4-：「最大的先知」-上"><a href="#2020-07-24-基督的所是-4-：「最大的先知」-上" class="headerlink" title="2020/07/24 基督的所是(4) ：「最大的先知」(上)"></a>2020/07/24 基督的所是(4) ：「最大的先知」(上)</h1><p>周五团契资料：<a href="https://www.youtube.com/watch?v=nN19QDuISK4">『基督的所是(4) ：「最大的先知」(上)』——于宏洁</a></p>
<p><strong>先知是祭司先知君王中最难的角色：</strong></p>
<ul>
<li>大多是神家很混乱的时候被兴起</li>
<li>先知本人的要求也很高（付代价）<ul>
<li>很多时候，先知本人的见证，就是所传的信息。</li>
</ul>
</li>
</ul>
<p><strong>先知的使命：</strong></p>
<ol>
<li>把人带回神的旨意中</li>
<li>恢复人与神的关系</li>
</ol>
<p><strong>先知的信息：</strong></p>
<ul>
<li>完全从神而来：责备/警告/预言/安慰/应许</li>
</ul>
<h1 id="2020-07-10-靠著主，做更大的事"><a href="#2020-07-10-靠著主，做更大的事" class="headerlink" title="2020/07/10 靠著主，做更大的事"></a>2020/07/10 靠著主，做更大的事</h1><p>周五团契资料：<a href="https://www.youtube.com/watch?v=e8gI-UqugSw">靠著主，做更大的事——于宏洁</a></p>
<ol>
<li>圣灵来帮助我们：</li>
</ol>
<blockquote>
<p>《约翰福音》14:16-17: 我要求父，父就另外赐给你们一位保惠师，（或作训慰师下同）叫他永远与你们同在。就是真理的圣灵，乃世人不能接受的。因为不见他，也不认识他。你们却认识他。因他常与你们同在，也要在你们里面。</p>
</blockquote>
<ol start="2">
<li>基督赢得了那超乎万名之上的名，并把这名赐给了教会:</li>
</ol>
<blockquote>
<p>《腓立比书》2:9-11: 所以神将他升为至高，又赐给他那超乎万名之上的名，叫一切在天上的，地上的，和地底下的，因耶稣的名，无不屈膝，无不口称耶稣基督为主，使荣耀归与父神。</p>
</blockquote>
<ol start="3">
<li>基督内住，成为我们的生命与能力：</li>
</ol>
<blockquote>
<p>《加拉太书》2:20: 我已经与基督同钉十字架。现在活着的，不再是我，乃是基督在我里面活着。并且我如今在肉身活着，是因信神的儿子而活，他是爱我，为我舍己。</p>
</blockquote>
<p>不能带这地来祝福，就像没有雨的云。要做，就不要白做。</p>
<h1 id="2020-07-03-逆境中的抉择"><a href="#2020-07-03-逆境中的抉择" class="headerlink" title="2020/07/03 逆境中的抉择"></a>2020/07/03 逆境中的抉择</h1><p>周五团契资料：<a href="https://www.youtube.com/watch?v=O_G5bN5rEEc">逆境中的抉择——寇紹涵牧師</a></p>
<h3 id="非尼哈的例子"><a href="#非尼哈的例子" class="headerlink" title="非尼哈的例子"></a>非尼哈的例子</h3><p>巴兰行诡计，让以色列人和米甸人行奸淫。非尼哈在别人都犯错的时候，勇敢的杀死了一个即将行奸淫的人，上帝悦纳这样的行为。</p>
<p>对一个家庭来说，父亲要如何带领这个家？拒绝婚外情。基督徒的家庭要活在神的圣洁里面。</p>
<h3 id="喇合的例子"><a href="#喇合的例子" class="headerlink" title="喇合的例子"></a>喇合的例子</h3><p>耶利哥城的喇合。拯救了以利亚的探子，决定救那两个人。庙妓是有地位的，因为有一些宗教的意义。为何她要放弃这种既得利益？</p>
<h3 id="路得的例子"><a href="#路得的例子" class="headerlink" title="路得的例子"></a>路得的例子</h3><p>跟随他的婆婆，走向神。</p>
<h3 id="俄巴底的例子"><a href="#俄巴底的例子" class="headerlink" title="俄巴底的例子"></a>俄巴底的例子</h3><p>亚哈的家宰。当耶洗别杀耶和华的先知时，他冒着生命危险，救了100先知。敬畏耶和华——能做出正确的事情。我们也不是跟随潮流走，要顺服圣经的原则。</p>
<h3 id="小使女的例子"><a href="#小使女的例子" class="headerlink" title="小使女的例子"></a>小使女的例子</h3><p>没有因为自己被掳，就失去了对神的信心。在逆境中持守了信心。他的主人乃缦得了大麻风，建议去找以利沙（撒玛利亚的先知）治疗。不要让处境动摇我们的信心。</p>
<blockquote>
<p>使你与人不同的是谁呢？你有什么不是领受的呢？若是领受的，为何自夸，仿佛不是领受的呢？《哥林多前書 4:7》</p>
</blockquote>
<p>有几分力，出几分力。</p>
<h3 id="玛利亚的例子"><a href="#玛利亚的例子" class="headerlink" title="玛利亚的例子"></a>玛利亚的例子</h3><p>莫大的福分，极大的挑战。我心尊主为大，我灵以神我的救主为乐。</p>
<h3 id="另一个玛利亚的例子"><a href="#另一个玛利亚的例子" class="headerlink" title="另一个玛利亚的例子"></a>另一个玛利亚的例子</h3><p>用极贵重的一整瓶香膏抹耶稣。价格 $\neq$ 价值，抹在耶稣身上之后的价值就体现出来了。在这个时代中，什么都以价格为标签。但很多有价值的事情是无法用价格来衡量。</p>
<h3 id="不畏工会强权的使徒"><a href="#不畏工会强权的使徒" class="headerlink" title="不畏工会强权的使徒"></a>不畏工会强权的使徒</h3><p>你们见证的人就是我们钉死的人。彼得约翰奉主之名治好了人，但是被人命令闭口不谈。他们能够胜过这个势力。他们被打之后喜乐，活在光中。</p>
<p>不要害怕付代价，这代价的背后有耶稣为你背书。</p>
<h3 id="对抗宗教领袖的该犹"><a href="#对抗宗教领袖的该犹" class="headerlink" title="对抗宗教领袖的该犹"></a>对抗宗教领袖的该犹</h3><p>丢特腓，只接待自己想接待的人。</p>
<blockquote>
<p>牧师跟着神走，我们跟着牧师走。</p>
</blockquote>
<ul>
<li>这是不对的，我们应该和牧师一起跟神走。</li>
</ul>
<blockquote>
<p>牧师成为弟兄罪恶的遮盖</p>
</blockquote>
<ul>
<li>这是不对的，你的血有啥能力？</li>
</ul>
<p>圣经有几卷书是写给个人的，说明这几卷书也有普世教导原则。</p>
<h3 id="安提帕的例子"><a href="#安提帕的例子" class="headerlink" title="安提帕的例子"></a>安提帕的例子</h3><p>在那个有撒旦座位的教会（皇帝庙）里面，坚守主的道。用自己的生命作见证。作为父亲，要有原则顶在那里，为孩子们做榜样。</p>
<hr>
<p>希望以上的这些例子，可以成为我们在世上的榜样。这个世界有什么比耶稣还大，让我们不舍得放下呢？</p>
]]></content>
      <categories>
        <category>Holy</category>
        <category>耶稣说</category>
      </categories>
  </entry>
  <entry>
    <title>聆听音乐答案(第五版)</title>
    <url>/2020/06/30/%E8%81%86%E5%90%AC%E9%9F%B3%E4%B9%90%E7%AD%94%E6%A1%88-%E7%AC%AC%E4%BA%94%E7%89%88/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>因为在网上找不到标准答案，网友的参考答案不是100%准确的，所以决定自己做一遍，并附上自己的心得体会。这里摘录了《聆听音乐》第五版的答案部分，答案主要参考了两个网站：</p>
<ol>
<li><a href="https://book.douban.com/review/6404967/" target="_blank" rel="noopener">豆瓣网友(自由民)贡献</a></li>
<li><a href="http://college.cengage.com/site_engine/#1439083533" target="_blank" rel="noopener">出版社的官方网站</a>（题目不全，但是准）</li>
<li><a href="https://book.douban.com/subject/10590165/discussion/48712018/" target="_blank" rel="noopener">豆瓣网友(BackToDecember)贡献</a></li>
</ol>
<p>音乐部分是来自于喜马拉雅的专辑，大家可以自行搜索。</p>
<p>下面<strong>含标题的是自己做过并检查一遍的</strong>，不含标题的是直接复制黏贴，属于【没有灵魂的答案】</p>
<ul>
<li>有点忧伤…做到练习18的时候才想起来要好好记笔记…</li>
<li>31题之后，出版社的网站上不去了…只好救助于网友的答案</li>
</ul>
<a id="more"></a>

<h1 id="答案部分"><a href="#答案部分" class="headerlink" title="答案部分"></a>答案部分</h1><p>1 bbacbaa bacabb bbcbbab</p>
<p>2 3/4, 2/4, 2/4, 3/4, 2/4, 3/4, 3/4, 2/4, 3/4, 2/4</p>
<p>3 ccabcacaab</p>
<p>4 大小小小大 大大小大小</p>
<p>5 1:14 1:30 1:48 1:56 2:04 2:21 2:37 2:45 2:53 3:10</p>
<p>6 16,8,8,16,16,8,8,16,16,16</p>
<p>7 ccaaa adbcb</p>
<p>8 0:09, 0:12, 0:20, 0:34, 0:39, 0:44, 0:58, 1:02, 1:09, b</p>
<h3 id="聆听练习9"><a href="#聆听练习9" class="headerlink" title="聆听练习9"></a>聆听练习9</h3><h5 id="关于音色的整理"><a href="#关于音色的整理" class="headerlink" title="关于音色的整理"></a>关于音色的整理</h5><blockquote>
<p>小号：听了想打人那种。</p>
<p>法国号：有一种金属共鸣，音域比长号高一点</p>
<p>长号：音域低一点的小号，音色脏脏的。</p>
<p>大号：最低音域的铜管。</p>
<p>大管：最低音域的木管。木管按起来会有咔咔的按键音。大管的共鸣比大号更好，有亮亮的音色。</p>
<p>长号和法国号的关系有点像单簧管和双簧管。后者音色亮一点/共鸣更好，而前者比较闷。</p>
<p>有人说单簧管声音更诡异/吓人，双簧管声音像鸭子/鹅。</p>
<p>长笛——音域宽</p>
<p>大提琴——音域不高不低，本来想选中提琴，发现没有</p>
</blockquote>
<p>【单簧管】—— 开始选了法国号，仔细一听确实沉闷，并且有按键声。</p>
<p>低音提琴——音域过低</p>
<p>双簧管——比较刺耳的木管</p>
<p>【大管】——开始选了单簧管，错在了音域/以及单簧管开始没选</p>
<p>长号 —— 铜管 &amp; 音域</p>
<p>【法国号】—— 开始选了大管/排除法选的</p>
<p>小提琴</p>
<p>大号—— 沉闷 &amp; 音色</p>
<h3 id="聆听练习10"><a href="#聆听练习10" class="headerlink" title="聆听练习10"></a>聆听练习10</h3><p>小号 小号 </p>
<p>低音提琴 单簧管 单簧管</p>
<p>大管 单簧管</p>
<p>长笛 长笛</p>
<p>法国号 长笛 长笛</p>
<p>双簧管 双簧管</p>
<p>大提琴 双簧管 双簧管</p>
<p>小提琴 中提琴 小提琴</p>
<blockquote>
<p>2 6 开始搞混了单双簧管… 感觉还是沉闷和清亮的区别</p>
<p>7 8 搞混了大中提琴 还是不知道咋区分</p>
</blockquote>
<h3 id="聆听练习11"><a href="#聆听练习11" class="headerlink" title="聆听练习11"></a>聆听练习11</h3><p>大管 长笛</p>
<p>大号 法国号 小号</p>
<p>长笛 单簧管</p>
<p>小号 长号</p>
<p>小提琴 中提琴 大提琴</p>
<blockquote>
<p>2 4 搞混了大号和长号，仔细一听还是音域的区别，2更低一点</p>
</blockquote>
<p>长笛 大管</p>
<p>长笛 大管 </p>
<p>小号 大号</p>
<p>小提琴 大提琴</p>
<p>12 单，复，单，主，单，复，复，单，复，主。</p>
<p>13 A,B,C,B,A 曲式结构为：ABCBA<br>     A,B 曲式结构为：AB<br>     A,B,A 曲式结构为：ABA<br>     A,B,A 曲式结构为：ABA<br>     A,B 曲式结构为：AB</p>
<p>14 复，圣，复，圣，复，圣，复，圣，复</p>
<p>15 0:46， 1:09， 1:33， 1:40， bbabcc</p>
<p>16 bcaca ccaab</p>
<p>17 bcaaa bcaab</p>
<h3 id="聆听练习18"><a href="#聆听练习18" class="headerlink" title="聆听练习18"></a>聆听练习18</h3><p>斯特罗齐《我想死》BBAAB BABBB</p>
<blockquote>
<p>1 应该是1765的走势</p>
<p>2 我觉得有三个，1-5-6-5 但是没这个选项，所以只好选了四个。</p>
<ul>
<li>喔！原来是中途出现了一个4</li>
</ul>
<p>5 出现了一个 17645的走势（为啥多了一拍）</p>
</blockquote>
<h3 id="聆听练习19"><a href="#聆听练习19" class="headerlink" title="聆听练习19"></a>聆听练习19</h3><p>珀塞尔《当我命丧黄泉》BAAAB DDBCB</p>
<blockquote>
<p>6 这题开始蒙了，怎么也没听出来是几遍，女声一出来确实听不见低音了。后来往上翻了翻才发现原来有固定低音的乐谱。走势应该是先从6逐个半音降到3然后一个123结束。因为前面那一通降感觉不是规律的速度，所以只听123就好了。每听到一个123，就相当于走了一遍</p>
<p>7 我认为唱了三次那一段旋律…可惜没有这个答案。固定低音部分，听到了四个123。</p>
<p>10 </p>
<ul>
<li>Bessie Smith <a href="https://www.youtube.com/watch?v=dYsGYWQT690" target="_blank" rel="noopener">《Lost Your Head Blues》</a> 没听出来有固定低音….</li>
<li>Eminem <a href="https://www.youtube.com/watch?v=eJO5HU_7_1w" target="_blank" rel="noopener">《The Real Slim Shady》</a> 走势应该是 (6)712 21 17 36</li>
</ul>
</blockquote>
<h3 id="聆听练习20"><a href="#聆听练习20" class="headerlink" title="聆听练习20"></a>聆听练习20</h3><p>维瓦尔第《春》CAABB ABCBC</p>
<h3 id="聆听练习21"><a href="#聆听练习21" class="headerlink" title="聆听练习21"></a>聆听练习21</h3><p>巴赫 《G小调管风琴赋格曲》 BAAAB CABDA</p>
<blockquote>
<p>中间主题陈述的时候有一段从小调变成大调，难以听出</p>
</blockquote>
<h3 id="聆听练习22"><a href="#聆听练习22" class="headerlink" title="聆听练习22"></a>聆听练习22</h3><p>巴赫 《醒来吧，一个声音在召唤》 BBDCA ABABD</p>
<blockquote>
<p>感觉有的部分确实加了木管？但是听不太清楚，感觉没有一个完整的声部</p>
<p>这个歌Spotify上没找到一模一样的。很多弦乐版的拖拖拉拉，根本不想醒来。</p>
<p>两个名字：Awake, a voice is calling / Sleepers, awake</p>
</blockquote>
<h3 id="聆听练习23"><a href="#聆听练习23" class="headerlink" title="聆听练习23"></a>聆听练习23</h3><p>亨德尔 《弥赛亚》“哈利路亚”合唱  BACCC CBBBD</p>
<h3 id="聆听练习24"><a href="#聆听练习24" class="headerlink" title="聆听练习24"></a>聆听练习24</h3><p>莫扎特 《费加罗的婚礼》“如果你想跳舞”  BCADA ABAAE</p>
<blockquote>
<p>9 上下乐句的对称结构（Antecedent - Consequent Phrase）指的是一句提问&amp;一句回答的对照形式。先制造不太和谐的张力，然后消解变为和谐。如果这么理解的话，最后收尾的和弦进行是4-5-1，应该算是。</p>
</blockquote>
<h3 id="聆听练习25"><a href="#聆听练习25" class="headerlink" title="聆听练习25"></a>聆听练习25</h3><p>莫扎特 《唐璜》序曲  BCAAB BBBBC</p>
<blockquote>
<p>这个练习的核心在于背住/写下来每个部分的主要旋律，方便辨认。</p>
<p>主部：24326 …4321 这个24326是主部的特点</p>
<p>副部：56655 51555 <strong>54321 32176</strong> 这里的阶梯五连降是副部的特点</p>
<p>结束部： 321 …. 321</p>
<p>连接部 21765432… 阶梯八连降是连接部的特点</p>
</blockquote>
<h3 id="聆听练习26"><a href="#聆听练习26" class="headerlink" title="聆听练习26"></a>聆听练习26</h3><p>莫扎特 《降E大调圆号协奏曲》CBABB ABCCD</p>
<blockquote>
<p>7 圆号的叠句出现在 0:00 / 1:04 / 1:55 / 2:54</p>
<ul>
<li>最后 3:15 也重复了两下，但是不完整…把它选上了</li>
</ul>
</blockquote>
<h3 id="聆听练习27"><a href="#聆听练习27" class="headerlink" title="聆听练习27"></a>聆听练习27</h3><p>莫扎特 《G小调第40交响曲》CBBAB ACCAA</p>
<blockquote>
<p>5 <a href="https://www.youtube.com/watch?v=wqkXqpQMk2k&t=103s" target="_blank" rel="noopener">youtube视频</a> 可以看到单簧管和大管是交替吹的，不懂为何选大管</p>
</blockquote>
<h3 id="聆听练习28"><a href="#聆听练习28" class="headerlink" title="聆听练习28"></a>聆听练习28</h3><p>海顿《皇帝》四重奏 DCBAC BACAB</p>
<blockquote>
<p>1 8 10 这三道题英文网站上没有/无法验证答案</p>
<p>4 强行理解的话，就是这个音域对于大提琴来说已经很高了。并不是说大提琴的音域和之前的旋律音域相比</p>
<p>7 或许指的是1’13’’进来的第一句跟之前的旋律相比。</p>
</blockquote>
<h3 id="聆听练习29"><a href="#聆听练习29" class="headerlink" title="聆听练习29"></a>聆听练习29</h3><p>贝多芬《悲怆》奏鸣曲 CACAB BBACB</p>
<blockquote>
<p>10 这题英文网站上没有/无法验证答案</p>
<p>9 好吧 这确实是结束部主题，但是最后一个和弦跟第一个和弦确实是一样的…</p>
</blockquote>
<h3 id="聆听练习30"><a href="#聆听练习30" class="headerlink" title="聆听练习30"></a>聆听练习30</h3><p>贝多芬《C小调第五交响曲》CBAAC BABBD</p>
<blockquote>
<p>2 这题英文网站上没有/无法验证答案</p>
<p>8 不属于呈示部的华彩因为是不同的旋律？</p>
</blockquote>
<h3 id="聆听练习31"><a href="#聆听练习31" class="headerlink" title="聆听练习31"></a>聆听练习31</h3><p>古典主义 v.s. 浪漫主义 MBBBB MMMBB</p>
<blockquote>
<p>5 这题英文网站上没有/无法验证答案</p>
</blockquote>
<h3 id="聆听练习32"><a href="#聆听练习32" class="headerlink" title="聆听练习32"></a>聆听练习32</h3><p>舒伯特《魔王》 BBAAA BABCA</p>
<h3 id="聆听练习33"><a href="#聆听练习33" class="headerlink" title="聆听练习33"></a>聆听练习33</h3><p>克拉拉·舒曼 《如果你为美丽而爱》 BCAAA BAAAC</p>
<h3 id="聆听练习34"><a href="#聆听练习34" class="headerlink" title="聆听练习34"></a>聆听练习34</h3><p>柏辽兹 《幻想交响曲》 BABBC ABBAA</p>
<blockquote>
<p>5 28 33 41 001 出现了四次，最后一次出现在下一个音频文件中…</p>
</blockquote>
<h3 id="聆听练习35"><a href="#聆听练习35" class="headerlink" title="聆听练习35"></a>聆听练习35</h3><p>威尔第《茶花女》BBCAA CACBB</p>
<blockquote>
<p>1 emmm 听不出来…</p>
</blockquote>
<h3 id="聆听练习36"><a href="#聆听练习36" class="headerlink" title="聆听练习36"></a>聆听练习36</h3><p>瓦格纳《爱之死》BDDBB CCABA</p>
<blockquote>
<p>狂喜：517</p>
<p>超越极乐：567217</p>
<p>欲望：3455</p>
</blockquote>
<h3 id="聆听练习37"><a href="#聆听练习37" class="headerlink" title="聆听练习37"></a>聆听练习37</h3><p>比才 「哈巴涅拉」，选自《卡门》 CBCAC AAADD </p>
<h3 id="聆听练习38"><a href="#聆听练习38" class="headerlink" title="聆听练习38"></a>聆听练习38</h3><p>穆索尔斯基 《画图展览会》 CBBAA BAAAA</p>
<blockquote>
<p>4 不懂…听不出来啊</p>
<p>10 额？不懂</p>
</blockquote>
<h3 id="聆听练习39"><a href="#聆听练习39" class="headerlink" title="聆听练习39"></a>聆听练习39</h3><p>勃拉姆斯 《D大调第二交响曲》 CCBBB CABAA</p>
<blockquote>
<p>2 …我选了A </p>
</blockquote>
<h3 id="聆听练习40"><a href="#聆听练习40" class="headerlink" title="聆听练习40"></a>聆听练习40</h3><p>德彪西《牧神午后前奏曲》BCAAB CBABC</p>
<h3 id="聆听练习41"><a href="#聆听练习41" class="headerlink" title="聆听练习41"></a>聆听练习41</h3><p>拉威尔《波莱罗》 BABAB ADACA</p>
<blockquote>
<p>9 不懂…</p>
</blockquote>
<h3 id="聆听练习42"><a href="#聆听练习42" class="headerlink" title="聆听练习42"></a>聆听练习42</h3><p>斯特拉文斯基 《春之祭》？？？</p>
<blockquote>
<p>这啥东西…</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　42. 否是是否是 是否是是 更多</span><br><span class="line">　　43. ehbga fcdbc</span><br><span class="line">　　44. dabab cbaca</span><br><span class="line">　　45. cbaac acaab</span><br><span class="line">　　46. aaccd abcab</span><br><span class="line">　　47. bbbba abaab</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>音乐</category>
        <category>聆听音乐</category>
      </categories>
  </entry>
  <entry>
    <title>郭振游门训笔记</title>
    <url>/2020/07/01/%E9%83%AD%E6%8C%AF%E6%B8%B8%E9%97%A8%E8%AE%AD%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>最近才了解到，门徒训练是灵命成长的关键一环。郭振游牧师编写了<a href="http://afcresources.org/contents/zh-cn/p3657.html">一套门徒小组研习课程</a>。这篇笔记主要是在听他<a href="https://www.youtube.com/playlist?list=PLr2lsVlkvbYvJMh3KwAXMHEGa203H_9Iq">CD内容</a>的时候整理出来的心得与大家分享。希望大家都能在灵命培养的路上走的更远。</p>
<blockquote>
<p>同时，如果大家觉得他的课程很有用的话，希望能够通过购买正版CD和图书支持他们的事工，谢谢。</p>
</blockquote>
<a id="more"></a>



<h1 id="第一课-做主门徒"><a href="#第一课-做主门徒" class="headerlink" title="第一课 做主门徒"></a>第一课 做主门徒</h1><h2 id="Why-为什么我们需要门徒训练"><a href="#Why-为什么我们需要门徒训练" class="headerlink" title="Why 为什么我们需要门徒训练"></a>Why 为什么我们需要门徒训练</h2><blockquote>
<p>那撒在路旁的，就是人听了道，撒旦立刻来，把撒在他心里的道夺了去。《馬可福音 4:15》</p>
</blockquote>
<ul>
<li>有时候我们自己听道之后容易忘记，是因为被撒旦夺去了。如果一个人生活中没能常常警醒，就会像抹大拉的玛丽亚一样身体上全是鬼。就这生活状态，即使讲道的人再有感动，也很难被记住。<ul>
<li>这也让我联想到，我每天的工作效率和我前一天的睡眠质量很相关。有时我也很生气自己的记忆力为何越来越差，学习效率为何越来越低？殊不知是因为没睡好。提高效率，就要从好的睡眠开始。同样的，如果想得道，那么就要从拒绝撒旦开始。</li>
</ul>
</li>
</ul>
<p>一个好的果实：能结出上百个果实。</p>
<p><strong>只是撒种的话，会带来问题：</strong></p>
<ol>
<li>属灵弃婴，只生不养。<ul>
<li>很多时候我们可能会注重在传播福音，得那些未得之地。得到之后便把他们安排进附近的教会，自己再进行新的一轮传福音。这样做带来的后果可能是【前门大，后门大】。来的人很多，得救的人很多，但是缺少了培养/成长的过程。就像刚埋下的种子不浇水很快就枯干了，所以离开的人也很多。</li>
</ul>
</li>
<li>教会侏儒：头很大，手脚很小。道听了很多，掌握了一套标准答案，但是没有活出来。</li>
</ol>
<blockquote>
<p>凡我所吩咐你们的，都教训他们遵守。我就常与你们同在，直到世界的末了。《馬太福音 28:20》</p>
</blockquote>
<ul>
<li>【世界的末了】让我想到了启示录。在那样悲惨的环境里面，如果没有主的同在，想必是很痛苦的。</li>
</ul>
<p><strong>属灵的蜜月期：</strong></p>
<ul>
<li>我相信很多人都经历过，常有神的话语，祷告很快应验。<ul>
<li>为了坚固信心</li>
</ul>
</li>
<li>久了之后为何夺去？<ul>
<li>也要碰碰钉子。不能光听道，要有一个全盘的了解。需要知道自己的不足以及如何补充。</li>
</ul>
</li>
</ul>
<h2 id="Who-选择谁来参与门徒训练"><a href="#Who-选择谁来参与门徒训练" class="headerlink" title="Who 选择谁来参与门徒训练"></a>Who 选择谁来参与门徒训练</h2><blockquote>
<p>你在许多见证人面前听见我所教训的，也要交托那忠心能教导别人的人。《提摩太後書 2:2》</p>
</blockquote>
<ul>
<li>有一个关键点是”忠心能教导别人的人“，让我想起了”爱人者，人恒爱之“。对于那些看起来有爱心/经常帮助他人的人，我们要毫不犹豫的对他们提供帮助。</li>
<li>能教导别人的人，符合了指数增长的奥秘。<ul>
<li>如果一个人<strong>每天</strong>能带领一个人信主，那么十年的话会有3650人信主</li>
<li>如果一个人<strong>每半年</strong>能带领出来一个门徒/忠心教导别人的人，十年的话会有1048576​人信主。</li>
<li>这也是精兵计划，通过半年的训练，出来的不会再是信仰的侏儒。</li>
<li>耶稣就是个好的例子。虽然也有登山宝训这种【布道会】，但是他花了大量气力在12门徒的身上。这12门徒后来喂养了很多人。</li>
</ul>
</li>
</ul>
<p>一个好的牧者不能只讲自己想讲的，也要看你的听众需要什么，进行合适的喂养。所以这对听众也有要求：<u>你得知道自己需要什么，并且传达给你的牧者。</u></p>
<p><strong>FAT原则：</strong></p>
<ul>
<li>F: Faithful. 他愿意将这段时间献给神，表忠心</li>
<li>A: Available. 有时间参与</li>
<li>T: Teachable. 肯受教</li>
</ul>
<h2 id="How-如何进行门徒训练"><a href="#How-如何进行门徒训练" class="headerlink" title="How 如何进行门徒训练"></a>How 如何进行门徒训练</h2><p><strong>主日学的一个问题：</strong></p>
<ul>
<li>讲得过多，并且不一定是听众所需要的。所以门徒训练的两大核心是：<ol>
<li>充分的互动，鼓励每个人都讲讲<ul>
<li>以生命影响生命。记得是你在带他，而不是材料在带她。</li>
</ul>
</li>
<li>讲自己的见证（失败的见证也可以）。<ul>
<li>会比单纯的知识更令人印象深刻，带来感动。而感动，很多时候是生命转变的开始。</li>
<li>在郭振游教授讲这里的时候，我印象深刻。随后我意识到，他其实引用了自己的见证（一对学生夫妇），他的见证就令我我印象深刻。</li>
<li>我在想，如果我无法举出自己生活中的见证，不放引用圣经中的例子。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>旧材料 -&gt; 新理解/新思路 -&gt; 新结论</p>
<ul>
<li>本科生和老总的例子：<ul>
<li>本科生经验少/材料少，所以讲的时候更填鸭，材料理解结论一起讲</li>
<li>老总经验多/材料多，所以讲的时候注重只讲理解/思路，让他们自己推导出新结论</li>
</ul>
</li>
<li>在我们鼓励大家互动的时候，对于他人的分享，我们的负担是：如何通过圣经/神的话，来给他提供一个新的视角呢？</li>
<li>这也有助于让他意识到神与他生活的关系，信仰是活泼的。</li>
</ul>
<p><strong>找教会 = 找老婆：</strong></p>
<ul>
<li>W: Worship. 教会需要有很好的崇拜，敬神。</li>
<li>I: Instruction. 注重指导，灵里的培养。</li>
<li>F: Fellowship. 团契互相有爱，互相守望（一方有难，轮流支援）</li>
<li>E: Evangelism. 传播福音，像耶稣一样【给出去】</li>
</ul>
<p><strong>门徒训练的五个目标：</strong></p>
<ol>
<li>提供一个框架，让学生自己填充。<ul>
<li>注重一个整体的感觉，一个秘诀/蓝图。打通任督二脉</li>
<li>有助于提起兴趣，自己探索的过程。<ul>
<li>引导很重要，但是如果引导的对方很气馁，也要注意引导的方向要是对方的兴趣。</li>
</ul>
</li>
</ul>
</li>
<li>以生命影响生命</li>
<li>带去聚会，不能对你过于依赖。<ul>
<li>哥多林教会的问题：”属保罗的“。这样会看不到是神在背后。他不是你的门徒，而是神的门徒。你只是在他的属灵路上陪她走一段。陪伴是手段，路才是目的。</li>
<li>如果过于依赖你，这样你一走，他的信仰就垮了。</li>
<li>不依赖某一个特定的人，有助于弟兄姊妹之间互相勉励。</li>
</ul>
</li>
<li>帮助一起灵修（防止自己灵修的时候出现【灵来灵去都是零】）</li>
<li>代代相传：劝勉他一定要好好学习，以后可以带别人进行门徒训练</li>
</ol>
<p><strong>背诵经文的目的：</strong>会在你需要他们的时候，突然在脑海中弹出来。</p>
<p><strong>如何劝说他人参与：</strong>就算是骗你，也只骗三个月啦，进行风险控制。</p>
<h2 id="实践体会"><a href="#实践体会" class="headerlink" title="实践体会"></a>实践体会</h2><p>07/01/2020</p>
<p>有小伙伴对这句经文感受很深：</p>
<blockquote>
<p>人若不常在我里面，就像枝子丢在外面枯干，人拾起来，扔在火里烧了。</p>
</blockquote>
<p>这无论是不是基督徒，只要不常在主里面，就会失去了功效，从有生命的树枝变成了无生命的柴火。</p>
<hr>
<h1 id="第二课-祷告"><a href="#第二课-祷告" class="headerlink" title="第二课 祷告"></a>第二课 祷告</h1><h2 id="如何祷告"><a href="#如何祷告" class="headerlink" title="如何祷告"></a>如何祷告</h2><p>耶稣教导我们如何祷告，几个关键字：</p>
<ul>
<li>不在十字路口祷告/应在暗中祷告：祷告不可故意叫别人看见。假冒为善</li>
<li>不说重复的话语：杜绝盲目的念咒语（像南无阿弥陀佛，有人明白这句话的具体含义吗？）要从心里发出祷告</li>
<li>求<strong>日用</strong>的饮食：<ol>
<li>不为明天忧虑</li>
<li>要每日祷告——吗哪为何也是每日拿当日的？</li>
</ol>
</li>
<li>祷告的方法：不能太过于关注自己的需求，<strong>要从主的视角看问题</strong>。</li>
<li>祷告的结果：不是改变神的心意，而是改变我们自己的心意。<ul>
<li>如果是改变神的心意，祷告多了人的欲望会越来越多</li>
<li>而若是改变自己的心意，祷告多了，人也因此得到了更新变化。</li>
</ul>
</li>
<li>未祈求以先神已知道我们的需求，何必祷告：<ol>
<li>建立一个交流的关系</li>
<li>在祷告中能发现自己真正的需求</li>
</ol>
</li>
</ul>
<h2 id="祷告计划"><a href="#祷告计划" class="headerlink" title="祷告计划"></a>祷告计划</h2><p>每日专为一类事情祈祷。这样避免了重复的话，也可以祷告的更深入。下表是一个例子</p>
<table>
<thead>
<tr>
<th align="center">星期</th>
<th align="center">祈祷事项分类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">星期一</td>
<td align="center">宣教工作 / 传福音</td>
</tr>
<tr>
<td align="center">星期二</td>
<td align="center">国家政府</td>
</tr>
<tr>
<td align="center">星期三</td>
<td align="center">教会侍奉</td>
</tr>
<tr>
<td align="center">星期四</td>
<td align="center">同学朋友</td>
</tr>
<tr>
<td align="center">星期五</td>
<td align="center">家人亲戚</td>
</tr>
<tr>
<td align="center">星期六</td>
<td align="center">个人需要</td>
</tr>
<tr>
<td align="center">星期日</td>
<td align="center">崇拜聚会</td>
</tr>
</tbody></table>
<h2 id="祷告记录"><a href="#祷告记录" class="headerlink" title="祷告记录"></a>祷告记录</h2><p>可以建立一个Excel表格，记录你祷告的事情，开始日期，结束日期，以及结果。</p>
<ul>
<li>帮助我们细数神的恩典，学会感恩。</li>
</ul>
<h2 id="祷告的要领"><a href="#祷告的要领" class="headerlink" title="祷告的要领"></a>祷告的要领</h2><ol>
<li><p>细：具体</p>
<ul>
<li>比如要神祝福中国。该如何祝福呢？如果真的祝福了，你通过什么样的方式知道呢？</li>
</ul>
</li>
<li><p>密：频繁</p>
<ul>
<li><p>寡妇与官的例子：路加福音18章1-9节</p>
<blockquote>
<p>耶稣设一个比喻，是要人常常祷告，不可灰心。说，某城里有一个官，不惧怕神，也不尊重世人。那城里有个寡妇，常到他那里，说，我有一个对头，求你给我伸冤。他多日不准。后来心里说，我虽不惧怕神，也不尊重世人。只因这寡妇烦扰我，我就给她伸冤吧。免得她常来缠磨我。主说，你们听这不义之官所说的话。神的选民，昼夜呼吁他，他纵然为他们忍了多时，岂不终久给他们伸冤吗？我告诉你们，要快快地给他们伸冤了，然而人子来的时候，遇得见世上有信德吗？</p>
</blockquote>
</li>
</ul>
</li>
<li><p>切：迫切</p>
<ul>
<li>有姊妹分享：哭着祷告的时候，感觉神的回应来得很快，自己很快得到平安</li>
<li>郭教授举了一个小孩子敲钟的例子</li>
</ul>
</li>
</ol>
<h2 id="关于禁食祷告"><a href="#关于禁食祷告" class="headerlink" title="关于禁食祷告"></a>关于禁食祷告</h2><p>禁食祷告是一个很大的反省，但也要防止走火入魔（禁欲主义）</p>
<p><strong>为什么很少听到别人禁食祷告：</strong></p>
<ul>
<li><p>因为要暗地里祷告，他们不张扬。马太福音6章16-18节</p>
<blockquote>
<p>你们禁食的时候，不可像那假冒为善的人，脸上带着愁容。因为他们把脸弄得难看，故意叫人看出他们是禁食。我实在告诉你们，他们已经得了他们的赏赐。你禁食的时候，要梳头洗脸，不叫人看出你禁食来，只叫你暗中的父看见。你父在暗中察看，必然报答你。</p>
</blockquote>
</li>
</ul>
<p><strong>禁食祷告注意事项：</strong></p>
<ul>
<li>不是和神换东西，而是表达了一种，将身体的需要暂时放下，表达迫切的心理</li>
<li>禁食祷告的时候保持喜乐，提防撒旦攻击（心里生气/肚子饥饿）</li>
<li>如果想更深入的禁食，要看是否有圣灵的带领，不可贸然前行。</li>
</ul>
<h2 id="查经练习"><a href="#查经练习" class="headerlink" title="查经练习"></a>查经练习</h2><p>问：<strong>在神应允我们祷告之前，他对我们有什么要求？</strong></p>
<p>答：</p>
<ol>
<li><p>约 15：7</p>
<blockquote>
<p>你们若常在我里面，我的话也常在你们里面，凡你们所愿意的，祈求就给你们成就。</p>
</blockquote>
</li>
<li><p>约一 5:14 - 15</p>
<blockquote>
<p>我们若照他的旨意求什么，他就听我们。这是我们向他所存坦然无惧的心。既然知道他听我们一切所求的，就知道我们所求于他的无不得着。</p>
</blockquote>
</li>
</ol>
<p><strong>问：怎样加强祷告的力量？</strong></p>
<p>答：</p>
<ol>
<li><p>雅各书1：5-8</p>
<blockquote>
<p>你们中间若有缺少智慧的，应当求那厚赐与众人，也不斥责人的神，主就必赐给他。只要凭着信心求，一点不疑惑。因为那疑惑的人，就像海中的波浪，被风吹动翻腾。这样的人，不要想从主那里得什么。心怀二意的人，在他一切所行的路上，都没有定见。</p>
</blockquote>
</li>
<li><p>马太福音17：20</p>
<blockquote>
<p>耶稣说，是因你们的信心小。我实在告诉你们，你们若有信心像一粒芥菜种，就是对这座山说，你从这边挪到那边，它也必挪去。并且你们没有一件不能作的事了。</p>
</blockquote>
</li>
</ol>
<p>问：<strong>怎样加强祷告的信心？</strong></p>
<p>答：</p>
<ol>
<li><p>可 9：24</p>
<blockquote>
<p>孩子的父亲立时喊着说，我信。但我信不足，求主帮助。</p>
</blockquote>
</li>
<li><p>约 15：7</p>
<blockquote>
<p>你们若常在我里面，我的话也常在你们里面，凡你们所愿意的，祈求就给你们成就。</p>
</blockquote>
</li>
</ol>
<h1 id="第三课-灵修"><a href="#第三课-灵修" class="headerlink" title="第三课 灵修"></a>第三课 灵修</h1><p><strong>问：为什么读圣经很重要？</strong></p>
<p>答：</p>
<ol>
<li><p>马太福音4：4</p>
<blockquote>
<p>耶稣却回答说，经上记着说，人活着，不是<strong>单靠</strong>食物，乃是靠神口里所出的一切话。</p>
</blockquote>
</li>
</ol>
<h2 id="三种读经的方法"><a href="#三种读经的方法" class="headerlink" title="三种读经的方法"></a>三种读经的方法</h2><ul>
<li><p>速读</p>
<ul>
<li>我们去自助餐厅的时候，第一步会干吗？会迅速浏览一圈。</li>
<li>建立一个框架，目的是在和别人讨论的时候，能更快的定位到对应的经文。</li>
</ul>
</li>
<li><p>研读</p>
<ul>
<li>经过营养学家的建议，我们选择了营养均衡的好食物来吃。</li>
<li>适用于周五/周日的学习</li>
</ul>
</li>
<li><p>灵修</p>
<ul>
<li><p>把东西都装过来了，真的开始吃了。</p>
</li>
<li><p>脱去旧人，穿上新人。就像衣服弄脏之后不去洗，而是直接扔掉换新的。</p>
</li>
<li><p>例子：</p>
<blockquote>
<p>对李三讲述了甲的故事，让李三在接下来的时间不要思考甲的事，结果李三就在思考甲的事。对张四讲述了甲和乙的故事，让张四在接下来的时间里不要思考甲的事，结果张四就在想乙的事。<strong>代替的效果。</strong> </p>
<p>让神把我们旧的东西排出去，就像乙对甲的效果那样。</p>
</blockquote>
</li>
<li><p>例子：</p>
<blockquote>
<p>习惯的力量：一个在美国生活很久的华人，要数点家里的椅子，会用中文。因为她在学数数的时候，是用中文学的。一个在美国教书的华人教授回台湾教书，发现无法用国语讲课，因为他在学习如何教书的时候，用的是英文。</p>
<p>我们通过意识层思考，将东西输送到潜意识层，从而将自己之前的旧潜意识排掉。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="灵修中可能存在的问题"><a href="#灵修中可能存在的问题" class="headerlink" title="灵修中可能存在的问题"></a>灵修中可能存在的问题</h2><ul>
<li>三天打鱼，两天晒网</li>
<li>敷衍了事（读经五分钟，打卡每一天）</li>
<li>方法用错了（用了周五周日的理性思路）</li>
</ul>
<h2 id="灵修的秘诀"><a href="#灵修的秘诀" class="headerlink" title="灵修的秘诀"></a>灵修的秘诀</h2><ul>
<li><p>MVP</p>
<ul>
<li>Visualize：像武侠小说一样，想象一下，这故事在我的面前发生。（作为观众）</li>
<li>Personalize：我们每个人都有英雄主义，主角带入感。（作为当事人）</li>
<li>Memorize</li>
</ul>
</li>
<li><p>昼夜思想</p>
<blockquote>
<p>《约书亚记》1:8 这律法书不可离开你的口，总要昼夜思想，好使你谨守遵行这书上所写的一切话。如此，你的道路就可以亨通，凡事顺利。</p>
</blockquote>
<ul>
<li>用神来开始与结束每一天。睡前与早起。</li>
<li>我们常以为事情是目的，神是手段和媒介。其实与神的关系是目的，做事情是手段和媒介。如果能推使自己在每件事上都看到神的美意，那么我们就完成了和神建立联系的目的。</li>
<li>罗伦斯弟兄的秘诀，凡事信靠神。书信集：<a href="http://31team.org/book/export/html/975">罗伦斯《与神同在》</a></li>
</ul>
</li>
<li><p>金字塔法</p>
<ul>
<li>由一个点，一个词语，慢慢扩展开来，变成一句完整的话。</li>
</ul>
</li>
</ul>
<h1 id="第五课-浸礼"><a href="#第五课-浸礼" class="headerlink" title="第五课 浸礼"></a>第五课 浸礼</h1><p><strong>一个常见的错误：</strong></p>
<ul>
<li>甲乙的关系：人们以为信耶稣（甲）就有了永生（乙）</li>
<li>其实是甲甲的关系：信耶稣（甲） = 永生（甲）</li>
</ul>
<p><strong>灵修的思考：</strong></p>
<ul>
<li>这段经文跟你有什么关系？</li>
<li>你想的这段跟经文有什么关系？</li>
</ul>
<p>男女恩爱，提到结婚的时候男孩说，我们不要搞那么多仪式，有爱就足够了，搬过来住吧。</p>
<ul>
<li>如果有人认为受浸是形式主义，就跟她讲这个故事</li>
</ul>
<p><strong>受浸的例子：</strong></p>
<ul>
<li>练习气功的老哥，受邪灵的干扰。在受洗的那天频频出事，灵里的征战。</li>
<li>有老哥能看到在受浸时的一些异象：一进入水之后，一股黑影就从身体里冲出来了。</li>
</ul>
<p><strong>什么时候受浸比较好：</strong></p>
<blockquote>
<p>使徒行传8章</p>
<p>37腓利说，你若是一心相信就可以，他回答说，我信耶稣基督是神的儿子）<br>38于是吩咐车站住，腓利和太监二人同下水里去，腓利就给他施洗。<br>39从水里上来，主的灵把腓利提了去，太监也不再见他了，就欢欢喜喜地走路。</p>
</blockquote>
<ul>
<li>要肯定这个人明白了浸礼的意思</li>
</ul>
<p><strong>浸礼使人得救？：</strong></p>
<ul>
<li>不是的。下面的例子中，没有受浸，但是满足了得救确据四定律，所以也得救了。</li>
</ul>
<blockquote>
<p>路加福音23章</p>
<p>39那同钉的两个犯人，有一个讥诮他说，你不是基督吗？可以救自己和我们吧。<br>40那一个就应声责备他说，你既是一样受刑的，还不怕神吗？<br>41我们是应该的。因我们所受的，与我们所作的相称。但这个人没有作过一件不好的事。<br>42就说，耶稣阿，你得国降临的时候，求你记念我。<br>43耶稣对他说，我实在告诉你，今日你要同我在乐园里了。</p>
</blockquote>
<ul>
<li>受浸是将「心里的革命」表现出来。</li>
</ul>
<p><strong>我现在做的不好，受洗之后丢神的人：</strong></p>
<ul>
<li>蒙恩的罪人，神会带领我们。</li>
</ul>
<h2 id="约拿的家——关于受浸"><a href="#约拿的家——关于受浸" class="headerlink" title="约拿的家——关于受浸"></a><a href="http://www.jonahome.net/files/nee/04/chapter02.html">约拿的家——关于受浸</a></h2><blockquote>
<p>另外，圣经不只说受浸不是一种的礼，并且告诉我们说，受浸是作见证。人跑到水里面去作什么呢？人到水里去，就是在神面前，在人面前，在天使面前，并在魔鬼面前作见证说：这个人信了耶稣，他的罪得赦免洗净了。受浸就是在神，在人，在天使和在鬼魔面前，承认说，我信基督为我所成功的是实在的事，是完全的，是靠得住的。受浸就是表明、见证这件事。</p>
<p>所以，亚拿尼亚叫扫罗起来受浸去。为何要受浸呢？为的是洗去你的罪。亚拿尼亚的意思，不是说，受浸能除去人的罪。<strong>不是受浸的本身能洗去人的罪，乃是受浸这件事所表明的事，所见证的事，能除去罪。</strong>全世界的水都不能洗去人一点的罪。但是受浸的水所表明，所见证的主的血，是会洗去人所有的罪。你信了么？既信了，要赶快起来受浸，洗去你的罪。受浸第一个意思是说洗去罪。</p>
</blockquote>
<blockquote>
<p><strong>在人里面的罪</strong></p>
<p>　　人不只有在神面前的罪，还有在人里面的罪。一个神学生对他的先生说，我今天在圣经里，找到一件新的事，就是罪的道理，圣经里也曾说到。我今天才看见。先生说，你今天才看见，才在圣经里找出罪的道理么？我早已在你心里找着了！不必到圣经里去找罪的道理，只要在人的心里就能找出来。每个人都能证明，罪不只是在神面前，也是在我里面！</p>
<p>　　你时常发脾气，你算这是因外面的事使你冒火发怒。其实，并不都是因外面的事，是因你里面有火，有一种东西时常要冒出来。你勉强把它压下去，也压不下，一有机会，就会发火炸起来。炸药爆发，不能怪外面有火，是因为里面有炸药。罪是从心里发出来的。许多人想，我心思顶污秽，充满了罪恶，这是因我看了外面不好的图书引诱我犯罪。我问你，许多时候环境顶美好清洁，没有引诱的事物，你的心都是完全清洁的么？一个少年人说，我看小说太多了，头脑充满邪恶污秽的念头，请问有何法能洁净我的思想呢？我们能否一直摇头，把污秽的东西摇出去呢？你想有这事么？我告诉你，你不能把它摇出去。</p>
<p>　　罪住在人里面，是有根的，没法除得去。许多罪人喜欢赌博、吃鸦片，不只是外面的事吸引他去作，乃是里面的罪逼他去作。罪在神面前是有刑罚的，但罪在你里面也是有势力抓住你，叫你作你所不愿意作的事的。你能用顶大的能力和意志，把它压下去一时，使它不发出来；但一有机会，它又会爆发了。这是人实在的情形。罪在人里面是作王的。我们是作它的奴仆的。罪有权力抓住我们，去作我们不愿作的事。</p>
</blockquote>
<blockquote>
<p><strong>血与十字架的功效</strong></p>
<p>　　主怎样为我们死，拯救我们脱离罪的两方面呢？圣经告诉我们说，有罪的人必要死。主替我们担当死的刑罚。祂流出血来，救赎洗净我们在神面前一切的罪。主的血洗净了我们。顶希奇，圣经从来没有告诉我们说，主的血洗净了我们的心。谁能找到一节圣经说，主的血是洗净我们的心呢？有人也许要说，希伯来书九章十四节，不是说主的血洗净我们的心么？但这节的小字怎么说呢？小字是说“良心”。让我顶直的告诉你们，全部圣经没有一处说，血洗净人的心，惟独说洗净我们的良心。良心是什么呢？良心就是那在我们里面控告我们说，我们不对，所以该死，该灭亡的。<strong>主的血只洗净人的良心，叫我们不受良心的控告，而得平安。</strong>主的血叫我们知道，虽然我们的罪是当受刑罚的，并且主就是为我们那些罪死了，成功了神的义，但是，没有人能靠主的血洗，在道德上变作好人，再不犯罪，从罪里得了释放。主的血只能使我们在神面前成为洁净，除去良心的控告，主的血并没有洗我们的心，使我们心里清洁，不再有罪藏在我们里面。主的血不是主观的，乃是客观的，不是洗人的心，乃是洗人的良心。</p>
<p>　　人都是污秽败坏的。有了主的血，罪就得赦免，不再受刑罚；但圣经没有告诉我们说，血能除去罪的势力。那是另一方面的事。圣经一方面告诉我们主的血，另外一方面也告诉我们主的十字架。血表明死，十字架也是表明死。血是关于刑罚，是对付在神面前的罪。十字架是对付在人里面罪的势力。是十字架使我心里清洁，能以胜过罪。</p>
<p>　　现在我要稍微提起十字架和血不同的地方。主的血是除去在神面前的罪的。十字架是对付在人里面的罪的。务要记得，十字架并不是钉死里面的罪的。这个我们要明白。许多说圣洁道理的人，把这个误会了。主的十字架没有把罪钉死。圣经中不能找出一节的经文说，十字架是钉死罪的。有没有谁找出一句的圣经说，十字架把他里面的罪，或是把他外面的罪钉在上面呢？没有。那么十字架是钉什么的呢？主钉在上面。不错。有人说罪也钉死在上面。这是谁说的呢？<strong>圣经告诉我们，不是罪被钉死，乃是我们的旧人被钉死。不是那有势力的罪被钉死，乃是这个喜欢听罪指挥的旧人被钉死。</strong>并不是罪根──那作根的罪──拔出来了，乃是旧人──那与罪根亲爱的人──被主钉在十字架上了。今天我告诉你一个福音，就是主钉十字架的时候，不单单祂自己钉在那里，也是把那败坏得不得了的我和你，犯罪污秽的我和你，同钉在十字架上！我们已经与祂同钉在那里了！</p>
</blockquote>
<blockquote>
<p>让我用比方来说明这里的意思。这里有三个东西：旧人、罪，和罪的身体。罪好像是主人，旧人好像是管家，身体好像是傀儡。罪没有权柄和能力来使用这个罪的身体，使之犯罪。罪主使旧人，当旧人赞成的时候，身体就作傀儡了。所以当我们旧人活着的时候，旧人是居在当中，身体在外面，罪在里面，里面的罪试探旧人，使旧人情欲发生，这样便叫旧人发命令，使身体犯罪，实行犯罪。身体是顶柔软的，你叫它作什么，它就作什么。它自己是没有主权的东西，自己不能作什么，必须旧人叫它作，它才作。现在主拯救我们，并不是把我们身体杀死，也不是把罪根消灭，乃是把我们的旧人钉死，叫旧人和祂同钉十字架。</p>
</blockquote>
<h1 id="第六课-得胜的生活"><a href="#第六课-得胜的生活" class="headerlink" title="第六课 得胜的生活"></a>第六课 得胜的生活</h1><p><strong>得救 &amp; 得胜</strong>：</p>
<ul>
<li>得救：本乎恩，不需要做什么，上帝已经付了代价。礼物</li>
<li>得胜：需要一个成长的过程，需要花功夫（和神一起同工）。<ul>
<li>成长就是有上上下下，所以下的时候不要太过愁苦，每个人都有跌倒的时间。</li>
<li>做得好就升级了，做的不好就留级了。</li>
</ul>
</li>
</ul>
<p><strong>如何花功夫</strong>：</p>
<ul>
<li>平常：平时多操练，灵修，就会使考试比较有底。（苦难就像是考试）<ul>
<li>通过考试可以让我们知道自己进步了，现在在哪里（小学？大学？）。神知道你在哪里，通过苦难来告诉你。</li>
<li>不断在打转，一直受同样的苦，就是因为一直留级。</li>
<li>魔鬼希望降级，上帝希望升级</li>
</ul>
</li>
<li>急时：考试</li>
</ul>
<blockquote>
<p>雅各书1：22 - 25</p>
<p>22 只是你们要行道，不要单单听道，自己欺哄自己。<br>23 因为听道而不行道的，就像人对着镜子看自己本来的面目。<br>24 看见，走后，随即忘了他的相貌如何。<br>25 惟有详细察看那全备使人自由之律法的，并且时常如此，这人既不是听了就忘，乃是实在行出来，就在他所行的事上必然得福。</p>
</blockquote>
<ul>
<li>道，好像一面镜子，看看自己哪里需要进步。</li>
</ul>
<p><strong>撒旦的诡计：</strong></p>
<ul>
<li>Desire 欲望</li>
<li>Delusion 假象</li>
<li>Decline 犯罪沉沦</li>
<li>从A地走向B地，撒旦会提出一条「捷径」，让我们离开上帝为我们预备的道路</li>
</ul>
<p><strong>对抗的办法：</strong></p>
<ul>
<li>Truth 真理：用神的话来对抗 <code>不是单靠食物，乃是靠神口里所出的一切话。</code><ul>
<li>回忆起耶稣反驳撒旦的三次试探，苦难一来的时候，我们要能想的起来经上的话，「用真理当作带子束腰」。</li>
</ul>
</li>
<li>Obedience 顺服</li>
<li>Experiencing God 感受神的大能、喜悦</li>
<li>Growth 成长</li>
<li>Exaltation 荣耀神<ul>
<li>神在看（耶稣在地上工作时多次受天使服侍）遇到苦难的时候破茧而出的过程对我们成长是很有必要的，在破茧之后，我们会得到服侍。</li>
</ul>
</li>
</ul>
<h1 id="第七课-明白神的旨意"><a href="#第七课-明白神的旨意" class="headerlink" title="第七课 明白神的旨意"></a>第七课 明白神的旨意</h1><p>一个人想买一个望远镜。一个方法是他可以努力工作，勤劳储蓄，最后买到这个望远镜。另一个办法是他可以直接去店里偷一个望远镜回家【撒旦的方法】。虽然最后都是得到，神不喜悦第二种。因为在勤劳做事的第一种中，望远镜不是最重要的，还可以学到很多吃苦耐劳的精神，而这个过程往往更重要。</p>
<p><strong>怎样明白神的旨意：</strong></p>
<ol>
<li>解决罪的问题</li>
<li>不能临时抱佛脚，平常和神多交流</li>
<li>真正动机。是需要神的批准，还是神的旨意？</li>
</ol>
<p>一个例子：在连续的十字路口，当前只有一个绿灯，接下来前方的都是红灯。所以我们既不要走的太快，毕竟前面是红灯，此路不通。也不要走得太慢，因为很可能会错过当前的这个绿灯。要走的正正好好，跟神一起走。慢慢的，下一个红灯就会变成绿灯。</p>
<p><strong>分辨神旨意的几个要诀：</strong></p>
<ol>
<li>异象。要注意有时候异象也不来自与神。</li>
<li>神的话。</li>
<li>圣灵的感动。</li>
<li>属灵的前辈</li>
<li>环境的印证。【我不需要很多门，一道就可以】</li>
</ol>
<p><strong>关于求印证：</strong></p>
<ul>
<li>基甸/亚伯拉罕仆人的例子</li>
<li>可以考虑禁食祷告，放下自己的需要</li>
<li>求得印证不可是故意刁难神，可以和你要求的事情相关。<ul>
<li>亚伯兰罕仆人的例子中，那女人给骆驼喝水，其实也是美好品格的一种表现</li>
</ul>
</li>
</ul>
<h1 id="第八课-教会生活"><a href="#第八课-教会生活" class="headerlink" title="第八课 教会生活"></a>第八课 教会生活</h1><p>一个见证：</p>
<ul>
<li>一般在我们跟老友聊天的时候，一般需要很长时间来叙旧，准备好状态，才能开始聊一点严肃的主题。</li>
<li>但是在我们和主内的弟兄聊天时，一般可以直入主题。圣灵的预备/工作。</li>
</ul>
<p>要杜绝山头主义，我们都是在为耶稣牧养羊群。</p>
<p>教会不仅是听讲，互动也很重要（教会的意义）。</p>
<ul>
<li>学习顺服的功课</li>
<li>世上的教会没有完美的，不完美之处就像是刺猬在笼子里。</li>
<li>服事是很重要的成长。</li>
</ul>
<p>如何发觉自己的恩赐：</p>
<ol>
<li>Easy</li>
<li>Enjoyable</li>
<li>Effective</li>
<li>Edify造就别人<ul>
<li>恩赐越大，越容易跌倒，vanity</li>
</ul>
</li>
<li>Exalt 荣耀神<ul>
<li>在世人面前见证</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Holy</category>
        <category>References</category>
        <category>郭振游门徒训练</category>
      </categories>
  </entry>
  <entry>
    <title>随手记</title>
    <url>/2020/07/08/%E9%9A%8F%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>平时看到比较有意义的视频/推文，会把笔记整理在此处供未来查阅。</li>
<li>数独技巧</li>
<li>Tetris</li>
<li>Puyo</li>
<li>旅行计划</li>
</ul>
<a id="more"></a>





<h1 id="旅行计划"><a href="#旅行计划" class="headerlink" title="旅行计划"></a>旅行计划</h1><h2 id="目前计划——Iowa-周末两日五园行"><a href="#目前计划——Iowa-周末两日五园行" class="headerlink" title="目前计划——Iowa 周末两日五园行"></a>目前计划——<a href="https://www.google.com/maps/d/edit?mid=1kgbni1BGpD5f4LzYne4d6r2dPwpmexrV&usp=sharing">Iowa 周末两日五园行</a></h2><p>人数：max8人？</p>
<p>天数：</p>
<ul>
<li>两天的话很密集，可能互动少一点，不过在走路的时候应该也可闲聊。</li>
<li>三天的话很宽松，互动多一点，晚饭后或许可以宾馆打游戏&amp;聊天？</li>
</ul>
<h3 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h3><h4 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h4><ul>
<li><p>Madison的朋友9点出发，驱车2小时到Maquoketa Caves State Park（Ames的朋友驱车3小时）</p>
<ul>
<li><p>在路上找点东西吃 / 可以带点东西到公园野餐</p>
</li>
<li><p>大约游玩4小时，给这个公园8分尊重</p>
</li>
<li><p>这个Park以Hiking著称，些许难爬，建议长裤+耐脏的衣服。</p>
<img src="https://media-cdn.tripadvisor.com/media/photo-o/03/f8/bf/c9/maquoketa-caves-state.jpg" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p>开30分钟到Bellevue State Park</p>
<ul>
<li><p>小看1小时，给与这个公园3分尊重</p>
<img src="https://media-cdn.tripadvisor.com/media/photo-m/1280/1b/ae/4b/04/bellevue-state-park.jpg" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p>开30分钟到Dubuque市中心，找个地方吃晚餐 + 准备第二天的picnic食材？</p>
</li>
<li><p>晚饭后密西西比河边散步，Mines of Spain Recreation Area</p>
<ul>
<li><p>小看2小时，给这个公园5分尊重</p>
<img src="https://media-cdn.tripadvisor.com/media/photo-o/05/03/9f/69/mines-of-spain-recreation.jpg" style="zoom: 33%;" />
</li>
</ul>
</li>
<li><p>晚上在Dubuque市中心小睡一晚</p>
<ul>
<li>酒店价格税前75刀</li>
</ul>
</li>
</ul>
<h4 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h4><ul>
<li><p>上午9点出发，开2小时15分钟车来到Dunning’s Spring Park</p>
<ul>
<li><p>这个瀑布有点牌面，IOWA热度前三名</p>
</li>
<li><p>之后转战另一个瀑布</p>
<ul>
<li>可以操作ABC计划，起点终点各放一辆车，沿着Trail走过去</li>
<li>可以直接开车，省去Trail这一步</li>
</ul>
</li>
<li><p>两个瀑布大约2小时，给与6分尊重</p>
<img src="https://media-cdn.tripadvisor.com/media/photo-o/04/10/75/d7/dunnings-spring-park.jpg" style="zoom: 67%;" />
</li>
</ul>
</li>
<li><p>下午开1小时车来到Pikes Peak State Park</p>
<ul>
<li><p>这个地方以高海拔视野开阔著称，两河交汇处</p>
</li>
<li><p>游玩3小时，给予8分尊重</p>
<img src="https://media-cdn.tripadvisor.com/media/photo-m/1280/1b/55/f5/b8/caption.jpg" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p>五点结束，开车两小时回麦迪逊（三小时回Ames）</p>
</li>
</ul>
<h2 id="Iowa"><a href="#Iowa" class="headerlink" title="Iowa"></a>Iowa</h2><p><a href="https://www.traveliowa.com/getinspireddetails/the-best-of-iowa-s-state-and-county-parks/237/">关注一下各类州立公园</a></p>
<p><img src="https://i.imgur.com/kuupIqQ.jpg" alt=""></p>
<p><strong>Maquoketa Caves State Park</strong>：Best Hike</p>
<ul>
<li><p>很多人推这个，Trip Advisor第一名</p>
</li>
<li><p>Suggested Duration : More than 3 hours</p>
</li>
<li><p>Some of the caves may require you to crawl at times to navigate them. 估计还要爬行。</p>
</li>
<li><p>洞穴地貌</p>
<img src="https://i.imgur.com/f9GwW5R.png" style="zoom: 67%;" />



</li>
</ul>
<p><strong>Backbone State Park</strong>：Best Camping</p>
<ul>
<li>Iowa 最老的州立公园</li>
<li>有人说鹅屎过多…先不去了</li>
</ul>
<p><strong>Pikes Peak State Park</strong></p>
<ul>
<li>地势比较高，或许可以看日出？【感觉这个公园靠视野，很需要一个好天气】</li>
<li>Trip Advisor评价很好</li>
<li>The main overlook has a beautiful view of the Mississippi River.</li>
<li></li>
</ul>
<p><strong>Dunnings Spring Park</strong>：</p>
<ul>
<li>溪水小公园</li>
<li>可以沿着Trail走到下面的另一个瀑布公园<ul>
<li><a href="https://www.traveliowa.com/getinspireddetails/13-wonderful-waterfalls-in-iowa/248/">Siewer’s Springs, Decorah</a></li>
</ul>
</li>
</ul>
<p><strong>Mines of Spain Recreation Area</strong>：</p>
<ul>
<li>有一个dubuque建市的标志</li>
</ul>
<p><strong>Bellevue State Park</strong>：</p>
<ul>
<li>可以顺路小看，没啥亮点</li>
</ul>
<h1 id="PuyoPuyo"><a href="#PuyoPuyo" class="headerlink" title="PuyoPuyo"></a>PuyoPuyo</h1><p>参考视频</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=IXNei0meZXU">Puyo puyo tips - building large chains consistently</a></li>
</ul>
<h2 id="Hanging"><a href="#Hanging" class="headerlink" title="Hanging"></a>Hanging</h2><p>考虑那些用来垫别的颜色的无用块，可以增加一连。</p>
<h2 id="Flat-and-convex"><a href="#Flat-and-convex" class="headerlink" title="Flat and convex"></a>Flat and convex</h2><p>目的：为了开始盖第二层。也就是说弄好了flat convex，相当于那块就不用计算了，可以放心的相信。</p>
<h1 id="Tetris"><a href="#Tetris" class="headerlink" title="Tetris"></a>Tetris</h1><h2 id="垃圾分类法"><a href="#垃圾分类法" class="headerlink" title="垃圾分类法"></a>垃圾分类法</h2><p>关于垃圾分类法如何解决两边过高的问题？</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=sMKnPzmM2v4&t=41s">完美摆放除了I之外的6块</a><ul>
<li>其实任何方式都可以，只要空的别太多</li>
</ul>
</li>
<li>三个I竖着摆</li>
</ul>
<h2 id="其他Loop"><a href="#其他Loop" class="headerlink" title="其他Loop"></a><a href="https://harddrop.com/wiki/T-Spin_Triple_Setups#Looping_Setups">其他Loop</a></h2><p>靠墙的<strong>0100</strong>，可以通过IO循环：</p>
<img src="https://i.imgur.com/WhdyfR6.png" alt="WhdyfR6" style="zoom:50%;" />

<p>靠墙的<strong>1200</strong>，可以通过IZ循环：</p>
<img src="https://i.imgur.com/Nik6LTU.png" alt="Nik6LTU" style="zoom:50%;" />

<p>靠墙的<strong>2100 / 1101</strong>：可以通过一个大循环：</p>
<img src="https://i.imgur.com/RAOoUdB.png" alt="RAOoUdB" style="zoom:50%;" />

<h2 id="花里胡哨"><a href="#花里胡哨" class="headerlink" title="花里胡哨"></a>花里胡哨</h2><p><a href="https://harddrop.com/wiki/Playing_forever">Playing Forever</a></p>
<p>DT炮的另一种放法：</p>
<img src="https://i.imgur.com/Cr3Aqjg.png" alt="Cr3Aqjg" style="zoom: 50%;" />

<p>三合一炮：</p>
<p><img src="https://inews.gtimg.com/newsapp_match/0/7757451766/0" alt=""></p>
<p>中途DT炮：</p>
<img src="https://i.imgur.com/VXOMlLb.png" style="zoom:35%;" />

<p>手速多块：</p>
<img src="https://i.imgur.com/tWxXakv.png" style="zoom:50%;" />

<h2 id="Double-PC"><a href="#Double-PC" class="headerlink" title="Double PC"></a>Double PC</h2><h3 id="第一个PC"><a href="#第一个PC" class="headerlink" title="第一个PC"></a>第一个PC</h3><h4 id="7-pieces-一共12种组合"><a href="#7-pieces-一共12种组合" class="headerlink" title="7 pieces 一共12种组合"></a>7 pieces 一共12种组合</h4><ul>
<li>含有O：TIJ 三选二，一共有三种组合。</li>
<li>T竖着放：SZ 2 / JL / SI 一共三种组合</li>
<li>T横着放：JI 2 / LI 2 / JS 2 一共三种组合</li>
<li>无T：LZI / JSI / JSZ 2  一共三种组合</li>
</ul>
<h1 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h1><p>本文的技巧都建立在以下两点的基础上：</p>
<ol>
<li>auto-pencil（自动补全所有铅笔+智能消除铅笔）</li>
<li>auto-single（自动补全hidden-single）</li>
</ol>
<p><strong>推荐这个app</strong>：<a href="https://apps.apple.com/us/app/sudoku/id285994151">:) sudoku +</a> 。它提供标准数独的各种功能（自动铅笔等），Hint的时候还有推理教程。下面的截图就是出自于这个软件。</p>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><strong>Unique Rectangle (Type1)</strong>：一个正方形中是2+2+2+3的形式，那么多出的那一个必是不同的，否则多解。【方块三带一】【注意！小方块必须在两个九宫格里面，不能属于四个不同的九宫格！】</p>
<img src="https://i.imgur.com/LLEalZE.jpg" alt="LLEalZE" style="zoom:25%;" />



<p><strong>Unique Rectangle (Type2)</strong>：因黄色格子必至少有一个包含3，所以其他红色部分不包含3。</p>
<img src="https://i.imgur.com/mHiEbyx.jpg" alt="mHiEbyx" style="zoom:25%;" />



<p><strong>Unique Rectangle (Type3)</strong>：中间的黄色必包含3/4 这样就和外面的34构成了naked。所以其他的红色不包含naked中的candidates</p>
<img src="https://i.imgur.com/Zdh8Vce.jpg" alt="Zdh8Vce" style="zoom:25%;" />



<p><strong>Unique Rectangle 4：</strong> 找个小方，外面的两块（绿色48）必是AB/AB，选定一个数字A，且这个数字A必须在那一列只有里面的两块有（黄色）。这时，可以把另一个B从两块黄色中删掉。【方块情侣砍单法】【注意！小方块必须在两个九宫格里面，不能属于四个不同的九宫格！】</p>
<img src="https://i.imgur.com/irJfkwG.jpg" alt="irJfkwG" style="zoom:25%;" />



<p><strong>Locked Candidates (pointing)</strong>: 九宫格里出现某个数字连成一条线时，可以把那条线上的其他candidates去掉。【九宫格狙神】</p>
<img src="https://i.imgur.com/Qm2nE7l.jpg" alt="Qm2nE7l" style="zoom:25%;" />



<p><strong>Locked Candidates (claiming)</strong>: 一条线上出现某个数字只落在一个九宫格内，那个九宫格其他位置都不可能是这个数字了。【爆竹开花】</p>
<img src="https://i.imgur.com/1uijFvS.jpg" alt="1uijFvS" style="zoom:25%;" />



<p><strong>BUG+1法</strong>：所有都是两个数字，只有一个是三个数字。这时候走一遍那三个数字，看行列宫，如果有奇数个候选位置那就是对的。三个数字中，只有一个candidate是奇数个候选。【奇数bug法】</p>
<img src="https://i.imgur.com/zbcrHrE.jpg" alt="zbcrHrE" style="zoom:25%;" />



<p><strong>Remote Pair：</strong> 属于特殊的首尾相连法。</p>
<img src="https://i.imgur.com/0msz7mc.jpg" alt="0msz7mc" style="zoom:25%;" />



<p><strong>Hidden Pair：</strong> Naked pair的隐藏版，用法一样。</p>
<img src="https://i.imgur.com/352f3sI.jpg" alt="352f3sI" style="zoom:25%;" />




<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><p><strong>Swordfish：</strong> X-Wing的升级版，四阶的被称作jellyfish。</p>
<img src="https://i.imgur.com/vyOc6h4.jpg" alt="vyOc6h4" style="zoom:25%;" />



<p><strong>Finned X-Wing</strong>: 找到两行中的一个方（一行是鱼鳍，那一行在九宫格A里的可以有candidate，另一行不能存在其他的candidate），那么无论鱼鳍是否是candidate，九宫格A里的方块线都不会是candidate。【鱼鳍方块】【扩展版本有swordfish和jellyfish】</p>
<img src="https://i.imgur.com/goZukdS.jpg" alt="goZukdS" style="zoom:25%;" />



<p><strong>W-Wing</strong>: 有两块AB/AB彼此交错，卡住了一个九宫格并且其中一个数字必在被卡的里面（1），则剩下的数字（2）必不在红色公共区域【犬牙差互】</p>
<img src="https://i.imgur.com/z9zQHVS.jpg" alt="z9zQHVS" style="zoom:25%;" />



<p><strong>利用填色法</strong>：Conjugate pairs共轭对，就是你若黑我必白的那种排除法，一对一对的能连起来。分别给涂色黄绿黄绿，那么黄绿的交错点上必没有那个candidate【黄绿涂色法】</p>
<img src="https://i.imgur.com/HWv95yJ.jpg" alt="HWv95yJ" style="zoom:25%;" />



<p><strong>XY-Chain：</strong> 疯狂链条，只要数字能连上，并且在同一宫。最后使得出发点和终止点相同candidate，则交汇处必没有那个candidate。【首尾相连法】【常用】</p>
<img src="https://i.imgur.com/X4Glrav.jpg" alt="X4Glrav" style="zoom:25%;" />



<p><strong>Sashimi X-Wing：</strong> 【个人感觉这个很好用】需要有两行有两个candidates，一对在同一列，另一对有重合的九宫格部分。这样可以构成两个X-Wings（上下）. 【刺身法】【扩展版本有swordfish和jellyfish】</p>
<img src="https://i.imgur.com/78uHQem.jpg" alt="78uHQem" style="zoom:25%;" />



<p><strong>XYZ-Wing：</strong> 三个数字首尾相连。AB-BC-ABC。其中AB和BC都与ABC有重合宫。则AB和BC的重合部分没有B。【AC装B法】</p>
<img src="https://i.imgur.com/AMZPeLf.jpg" alt="AMZPeLf" style="zoom:25%;" />



<p><strong>ALS:</strong> ALS指的是在N个格子里有N+1个数字。再多一点信息就可以确定了。如下图所示。这个蓝色框里必有一个1/2，但是右下角的黄色也是必有1/2，这样的话红色区域就不可能有1/2。</p>
<img src="https://i.imgur.com/eWSWRAy.jpg" alt="eWSWRAy" style="zoom:25%;" />



<p><strong>Hidden Unique Rectangle:</strong> 思路是若交叉线上有2的话，那么左下右上必为1，那么左上必为2，就构成了多解。</p>
<img src="https://i.imgur.com/FfwmPlf.jpg" alt="FfwmPlf" style="zoom:25%;" />




<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="2020-08-07-GSA-Ultra-编程竞赛"><a href="#2020-08-07-GSA-Ultra-编程竞赛" class="headerlink" title="2020/08/07 GSA-Ultra 编程竞赛"></a>2020/08/07 GSA-Ultra 编程竞赛</h2><p>第一年参加，啥也不会，但是激起了我学算法的兴趣。前几名的奖金很多，希望明年会更好。我把写的一部分代码贴下来了。</p>
<p><img src="https://i.imgur.com/zrNXmLf.jpg" alt=""></p>
<h3 id="Spacedogs"><a href="#Spacedogs" class="headerlink" title="Spacedogs"></a>Spacedogs</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ways to speed-up</span></span><br><span class="line"><span class="comment"># Heap ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">masses, locations</span>):</span></span><br><span class="line">    n = len(masses)</span><br><span class="line">    dic1 = &#123;&#125; <span class="comment"># Distance Matrix</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dis_tmp = [*map(<span class="keyword">lambda</span> x: eudis(locations[i],x), locations)]</span><br><span class="line">        <span class="comment"># dic1[i] = [(dis_tmp[j],j)for j in range(n) if j != i]</span></span><br><span class="line">        dic1[i] = &#123;j:dis_tmp[j] <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> j != i&#125;</span><br><span class="line">        <span class="comment"># heapq.heapify(dic1[i])</span></span><br><span class="line">    dic2 = &#123;i:masses[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125; <span class="comment"># Mass Matrix</span></span><br><span class="line">    <span class="comment"># dic2 = [(masses[i],i) for i in range(n)]  # Mass Matrix</span></span><br><span class="line">    <span class="comment"># heapq.heapify(dic2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(dic1) &gt; <span class="number">1</span>:</span><br><span class="line">        idx1 = min(dic2,key=dic2.get) <span class="comment"># Find the smallest</span></span><br><span class="line">        idx2 = min(dic1[idx1],key = dic1[idx1].get) <span class="comment"># Find the closet</span></span><br><span class="line">        <span class="comment"># idx1 = heapq.nsmallest(1,dic2)[0][1]</span></span><br><span class="line">        <span class="comment"># idx2 = heapq.nsmallest(1,dic1[idx1])[0][1]</span></span><br><span class="line"></span><br><span class="line">        masses.append(masses[idx1]+masses[idx2])</span><br><span class="line">        locations.append(tuple([(a+b)//<span class="number">2</span> <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(locations[idx1],locations[idx2])]))</span><br><span class="line"></span><br><span class="line">        n_tmp = len(masses)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">del</span> dic1[idx1]</span><br><span class="line">        <span class="keyword">del</span> dic1[idx2]</span><br><span class="line">        <span class="comment"># dis_list = []</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> dic1.keys():</span><br><span class="line">            <span class="comment"># dic1[k] = delheap(dic1[k], idx1)</span></span><br><span class="line">            <span class="comment"># dic1[k] = delheap(dic1[k], idx2)</span></span><br><span class="line">            <span class="keyword">del</span> dic1[k][idx1]</span><br><span class="line">            <span class="keyword">del</span> dic1[k][idx2]</span><br><span class="line">            <span class="comment"># dis_tmp = eudis(locations[k],locations[n_tmp])</span></span><br><span class="line">            <span class="comment"># heapq.heappush(dic1[k],(dis_tmp,n_tmp))</span></span><br><span class="line">            <span class="comment"># dis_list.append((dis_tmp,k))</span></span><br><span class="line">            dic1[k][n_tmp] = eudis(locations[k],locations[n_tmp]) <span class="comment"># Insert</span></span><br><span class="line">        dic1[n_tmp] = &#123;k:dic1[k][n_tmp] <span class="keyword">for</span> k <span class="keyword">in</span> dic1.keys()&#125; <span class="comment"># Insert</span></span><br><span class="line">        <span class="comment"># dic1[n_tmp] = dis_list</span></span><br><span class="line">        <span class="comment"># heapq.heapify(dic1[n_tmp])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dic2</span></span><br><span class="line">        <span class="keyword">del</span> dic2[idx1]</span><br><span class="line">        <span class="keyword">del</span> dic2[idx2]</span><br><span class="line">        <span class="comment"># delheap(dic2,idx1)</span></span><br><span class="line">        <span class="comment"># delheap(dic2, idx2)</span></span><br><span class="line">        <span class="comment"># heapq.heappush(dic2,(masses[n_tmp],n_tmp))</span></span><br><span class="line">        dic2[n_tmp] = masses[idx1]+masses[idx2] <span class="comment"># Insert</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(locations[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eudis</span>(<span class="params">v1, v2</span>):</span></span><br><span class="line">    dist = [(a - b)**<span class="number">2</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(v1, v2)]</span><br><span class="line">    dist = math.sqrt(sum(dist))</span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = solution(masses = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>], locations = [(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">6</span>)])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<h3 id="Dicey-Situation"><a href="#Dicey-Situation" class="headerlink" title="Dicey Situation"></a>Dicey Situation</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic idea:</span></span><br><span class="line"><span class="comment"># Alice calculate the expectation of the next step,</span></span><br><span class="line"><span class="comment"># and build up a strategy based on that</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">dice_vals, d, r</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Dice = 1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># dice_vals = [2, 9, 19, 20]</span></span><br><span class="line">    n = len(dice_vals)</span><br><span class="line">    p0 = np.array([<span class="number">1</span> / n] * n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    A0 = np.transpose(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>/n]*n,[<span class="number">1</span>/n]*n]))</span><br><span class="line">    p0 = np.array([<span class="number">1</span>/n]*n)</span><br><span class="line">    p_alice = A0.dot(p0)</span><br><span class="line"></span><br><span class="line">    A = np.transpose(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>/n]*n,[<span class="number">1</span>/n]*n,[<span class="number">1</span>/n]*n]))</span><br><span class="line">    p = A.dot(p0)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Alice 4</span></span><br><span class="line">    ans += -p_alice[<span class="number">0</span>] * (<span class="number">1</span>-p[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Alice 3</span></span><br><span class="line">    ans += p_alice[<span class="number">1</span>] * (p_alice[<span class="number">0</span>] - p_alice[<span class="number">2</span>]-p_alice[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Alice 2</span></span><br><span class="line">    A1 = np.transpose(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>/n]*n,[<span class="number">1</span>/n]*n]))</span><br><span class="line">    p1 = A1.dot(p0)</span><br><span class="line">    ans += p_alice[<span class="number">2</span>] * (p1[<span class="number">0</span>]+p1[<span class="number">1</span>]-p1[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Alice 1</span></span><br><span class="line">    A2 = np.transpose(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>/n]*n]))</span><br><span class="line">    p2 = A2.dot(p0)</span><br><span class="line">    ans += p_alice[<span class="number">3</span>] * (p2[<span class="number">0</span>]+p2[<span class="number">1</span>]+p2[<span class="number">2</span>])</span><br><span class="line">    (<span class="string">&quot;%.7f&quot;</span> % ans)[<span class="number">2</span>:]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>转移矩阵自乘</li>
<li>针对Alice的每一种情况，Bob只需要变一个转移矩阵，然后自乘</li>
</ul>
<h3 id="Grand-Hotel"><a href="#Grand-Hotel" class="headerlink" title="Grand Hotel"></a>Grand Hotel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, rs</span>):</span></span><br><span class="line">    <span class="comment"># n = 10</span></span><br><span class="line">    <span class="comment"># rs = [(&#x27;I&#x27;, 3), (&#x27;I&#x27;, 3), (&#x27;O&#x27;, 0), (&#x27;I&#x27;, 4), (&#x27;I&#x27;, 2), (&#x27;O&#x27;, 2), (&#x27;I&#x27;, 2)]</span></span><br><span class="line">    <span class="comment"># if len(rs) &gt; 10000:</span></span><br><span class="line">    <span class="comment">#     return 1</span></span><br><span class="line">    checkin = [] <span class="comment"># Record its start and number</span></span><br><span class="line">    checkin_list = set()</span><br><span class="line">    avail_set = &#123;<span class="number">0</span>:(<span class="number">0</span>,n<span class="number">-1</span>),n<span class="number">-1</span>:(<span class="number">0</span>,n<span class="number">-1</span>)&#125; <span class="comment"># Record each available interval, use both of its end as keys</span></span><br><span class="line">    avail_len = [(<span class="number">0</span>,n)] <span class="comment"># Record its start 0, and number of available consecutive rooms n</span></span><br><span class="line">    avail_len = sorted(avail_len)</span><br><span class="line">    <span class="keyword">for</span> a,b <span class="keyword">in</span> rs:</span><br><span class="line">        <span class="comment"># print(avail_set)</span></span><br><span class="line">        <span class="comment"># print(avail_len)</span></span><br><span class="line">        <span class="comment"># print([checkin[i] for i in checkin_list])</span></span><br><span class="line">        <span class="comment"># print(a,b)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;I&#x27;</span>: <span class="comment"># Check-in</span></span><br><span class="line">            checkin_list.add(len(checkin))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(avail_len)):</span><br><span class="line">                <span class="keyword">if</span> avail_len[i][<span class="number">1</span>] == b:</span><br><span class="line">                    checkin.append((avail_len[i][<span class="number">0</span>],b))</span><br><span class="line">                    <span class="keyword">del</span> avail_set[avail_len[i][<span class="number">0</span>]]</span><br><span class="line">                    <span class="keyword">del</span> avail_set[avail_len[i][<span class="number">0</span>]+b<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">del</span> avail_len[i]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> avail_len[i][<span class="number">1</span>] &gt; b:</span><br><span class="line">                    checkin.append((avail_len[i][<span class="number">0</span>], b))</span><br><span class="line">                    end_tmp = avail_set[avail_len[i][<span class="number">0</span>]][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">del</span> avail_set[avail_len[i][<span class="number">0</span>]]</span><br><span class="line">                    avail_set[avail_len[i][<span class="number">0</span>] + b] = (avail_len[i][<span class="number">0</span>] + b, end_tmp)</span><br><span class="line">                    avail_set[end_tmp] = (avail_len[i][<span class="number">0</span>] + b, end_tmp)</span><br><span class="line"></span><br><span class="line">                    ready_to_push = (avail_len[i][<span class="number">0</span>] + b, avail_len[i][<span class="number">1</span>]-b)</span><br><span class="line">                    <span class="keyword">del</span> avail_len[i]</span><br><span class="line">                    bisect.insort_left(avail_len, ready_to_push)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start_tmp, n_tmp = checkin[b]</span><br><span class="line">            checkin_list.remove(b)</span><br><span class="line">            <span class="keyword">if</span> start_tmp - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> avail_set.keys(): <span class="comment"># 前面住了人</span></span><br><span class="line">                <span class="keyword">if</span> start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> avail_set.keys(): <span class="comment"># 后面也住了人</span></span><br><span class="line">                    avail_set[start_tmp] = (start_tmp, start_tmp + n_tmp - <span class="number">1</span>)</span><br><span class="line">                    avail_set[start_tmp + n_tmp - <span class="number">1</span>] = (start_tmp, start_tmp + n_tmp - <span class="number">1</span>)</span><br><span class="line">                    bisect.insort_left(avail_len, (start_tmp,n_tmp))</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 后面没住人</span></span><br><span class="line">                    end_tmp = avail_set[start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                    avail_set[start_tmp] = (start_tmp, end_tmp)</span><br><span class="line">                    avail_set[end_tmp] = (start_tmp, end_tmp)</span><br><span class="line">                    <span class="keyword">del</span> avail_set[start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span>]</span><br><span class="line">                    idx_tmp = bisect.bisect_left(avail_len, (start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span>, end_tmp - (start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">del</span> avail_len[idx_tmp]</span><br><span class="line">                    bisect.insort_left(avail_len, (start_tmp, end_tmp - start_tmp + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">elif</span> start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> avail_set.keys(): <span class="comment"># 前面没住人， 后面住了人</span></span><br><span class="line">                s_tmp = avail_set[start_tmp - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                avail_set[s_tmp] = (s_tmp, start_tmp + n_tmp - <span class="number">1</span>)</span><br><span class="line">                avail_set[start_tmp + n_tmp - <span class="number">1</span>] = (s_tmp, start_tmp + n_tmp - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> avail_set[start_tmp - <span class="number">1</span>]</span><br><span class="line">                idx_tmp = bisect.bisect_left(avail_len, (s_tmp, start_tmp - <span class="number">1</span> - s_tmp + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">del</span> avail_len[idx_tmp]</span><br><span class="line">                bisect.insort_left(avail_len, (s_tmp, start_tmp + n_tmp - s_tmp))</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 前后都没人</span></span><br><span class="line">                s_tmp = avail_set[start_tmp - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                end_tmp = avail_set[start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                avail_set[s_tmp] = (s_tmp, end_tmp)</span><br><span class="line">                avail_set[end_tmp] = (s_tmp, end_tmp)</span><br><span class="line">                <span class="keyword">del</span> avail_set[start_tmp - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">del</span> avail_set[start_tmp + n_tmp - <span class="number">1</span> + <span class="number">1</span>]</span><br><span class="line">                idx_tmp = bisect.bisect_left(avail_len, (s_tmp, start_tmp - <span class="number">1</span> - s_tmp + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">del</span> avail_len[idx_tmp]</span><br><span class="line">                <span class="keyword">del</span> avail_len[idx_tmp] <span class="comment"># Delete the next one</span></span><br><span class="line">                bisect.insort_left(avail_len, (s_tmp, end_tmp - s_tmp + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># print([(i,checkin[i]) for i in checkin_list])</span></span><br><span class="line">    <span class="keyword">return</span> sum(i*checkin[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> checkin_list)</span><br></pre></td></tr></table></figure>

<h3 id="Gone-to-seed"><a href="#Gone-to-seed" class="headerlink" title="Gone to seed"></a>Gone to seed</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">skills</span>):</span></span><br><span class="line">    current = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    opponent = []</span><br><span class="line">    skills_new = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> a,b <span class="keyword">in</span> skills.items():</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;Andy&#x27;</span>:</span><br><span class="line">            skills_new[<span class="string">&#x27;A&#x27;</span>] = b</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            skills_new[current] = b</span><br><span class="line">            opponent.append(current)</span><br><span class="line">            current = chr(ord(current)+<span class="number">1</span>)</span><br><span class="line">    book = &#123;i+j:Fraction(skills_new[i],skills_new[i] + skills_new[j]) <span class="keyword">for</span> i <span class="keyword">in</span> skills_new.keys() <span class="keyword">for</span> j <span class="keyword">in</span> skills_new.keys()&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">s</span>):</span></span><br><span class="line">        cut = [s[<span class="number">0</span>+i:<span class="number">2</span>+i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s), <span class="number">2</span>)]</span><br><span class="line">        next_candidate = <span class="string">&#x27;&#x27;</span>.join(x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cut)</span><br><span class="line">        <span class="keyword">if</span> next_candidate <span class="keyword">not</span> <span class="keyword">in</span> book.keys():</span><br><span class="line">            book[next_candidate] = calculate(next_candidate)</span><br><span class="line">        ans = reduce(operator.mul,[book[i] <span class="keyword">for</span> i <span class="keyword">in</span> cut], <span class="number">1</span>) * book[next_candidate]</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">16</span>:</span><br><span class="line">            book[s] = ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    final = [<span class="string">&#x27;A&#x27;</span>+<span class="string">&#x27;&#x27;</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> itertools.permutations(opponent)]</span><br><span class="line">    all_possible = int(<span class="number">78</span> * len(skills_new) - <span class="number">309</span>) <span class="comment"># 4:3 5:315 实在不懂怎么算出来的了</span></span><br><span class="line">    result = sum(calculate(x) <span class="keyword">for</span> x <span class="keyword">in</span> final) / all_possible</span><br><span class="line">    <span class="keyword">return</span> str(result.numerator) + str(result.denominator)</span><br></pre></td></tr></table></figure>

<h3 id="Two-Quests"><a href="#Two-Quests" class="headerlink" title="Two Quests"></a>Two Quests</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import numpy as np</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="comment"># 目标：从 0,0 出发到 la, lb</span></span><br><span class="line">    a, b = [<span class="number">0</span>] + a, [<span class="number">0</span>] + b</span><br><span class="line">    la, lb = len(a), len(b)</span><br><span class="line">    book = [[<span class="number">0</span>]* lb <span class="keyword">for</span> i <span class="keyword">in</span> range(la)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(la):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(lb):</span><br><span class="line">            book[i][j] = abs(a[i]-b[j])</span><br><span class="line"></span><br><span class="line">    dp = &#123;(<span class="number">0</span>, <span class="number">0</span>): [(<span class="number">0</span>, <span class="number">0</span>)]&#125; <span class="comment"># (r,c):[(步数，目前的数字), (步数，目前的数字)]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, la):</span><br><span class="line">        dp[(i, <span class="number">0</span>)] = [(dp[(i - <span class="number">1</span>, <span class="number">0</span>)][<span class="number">0</span>][<span class="number">0</span>] + abs(a[i] - dp[(i - <span class="number">1</span>, <span class="number">0</span>)][<span class="number">0</span>][<span class="number">1</span>]), a[i]),</span><br><span class="line">                      (dp[(i - <span class="number">1</span>, <span class="number">0</span>)][<span class="number">0</span>][<span class="number">0</span>] + abs(a[i] - dp[(i - <span class="number">1</span>, <span class="number">0</span>)][<span class="number">0</span>][<span class="number">1</span>]), a[i])]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, lb):</span><br><span class="line">        dp[(<span class="number">0</span>, i)] = [(dp[(<span class="number">0</span>, i - <span class="number">1</span>)][<span class="number">0</span>][<span class="number">0</span>] + abs(b[i] - dp[(<span class="number">0</span>, i - <span class="number">1</span>)][<span class="number">0</span>][<span class="number">1</span>]), b[i]),</span><br><span class="line">                      (dp[(<span class="number">0</span>, i - <span class="number">1</span>)][<span class="number">0</span>][<span class="number">0</span>] + abs(b[i] - dp[(<span class="number">0</span>, i - <span class="number">1</span>)][<span class="number">0</span>][<span class="number">1</span>]), b[i])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digui</span>(<span class="params">r, c</span>):</span>  <span class="comment"># 目标：将dp字典填满</span></span><br><span class="line">        <span class="keyword">if</span> (r, c) <span class="keyword">in</span> dp:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            digui(r - <span class="number">1</span>, c)</span><br><span class="line">            digui(r, c - <span class="number">1</span>)</span><br><span class="line">            r1, r2 = dp[(r - <span class="number">1</span>, c)]</span><br><span class="line">            r_now = (min([r1[<span class="number">0</span>] + abs(r1[<span class="number">1</span>] - a[r]), r2[<span class="number">0</span>] + abs(r2[<span class="number">1</span>] - a[r])]), a[r])</span><br><span class="line">            c1, c2 = dp[(r, c - <span class="number">1</span>)]</span><br><span class="line">            c_now = (min([c1[<span class="number">0</span>] + abs(c1[<span class="number">1</span>] - b[c]), c2[<span class="number">0</span>] + abs(c2[<span class="number">1</span>] - b[c])]), b[c])</span><br><span class="line">            dp[(r, c)] = [r_now, c_now]</span><br><span class="line"></span><br><span class="line">    digui(la<span class="number">-1</span>,lb<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> min(x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> dp[(la<span class="number">-1</span>,lb<span class="number">-1</span>)])</span><br></pre></td></tr></table></figure>

<h3 id="Garden-Path"><a href="#Garden-Path" class="headerlink" title="Garden Path"></a>Garden Path</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">width, length, plants</span>):</span></span><br><span class="line">    arr = [[<span class="number">0</span>]*width <span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> plants:</span><br><span class="line">        arr[item[<span class="number">1</span>]][item[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">arr,la, lb</span>):</span></span><br><span class="line">        <span class="comment"># 左上到右下扫描</span></span><br><span class="line">        ans1 = ans2 = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; la <span class="keyword">and</span> flag:</span><br><span class="line">            <span class="keyword">while</span> j &lt; lb <span class="keyword">and</span> flag:</span><br><span class="line">                <span class="keyword">if</span> arr[i][j] == <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j + <span class="number">1</span> &lt; lb <span class="keyword">and</span> arr[i][j + <span class="number">1</span>] == <span class="number">0</span>:  <span class="comment"># 先试着横着放</span></span><br><span class="line">                        arr[i][j] = arr[i][j + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                        ans1 = helper(arr, la, lb)</span><br><span class="line">                        arr[i][j] = arr[i][j + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &lt; la <span class="keyword">and</span> arr[i + <span class="number">1</span>][j] == <span class="number">0</span>:  <span class="comment"># 再试着竖着放</span></span><br><span class="line">                        arr[i][j] = arr[i + <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">                        ans2 = helper(arr, la, lb)</span><br><span class="line">                        arr[i][j] = arr[i + <span class="number">1</span>][j] = <span class="number">0</span></span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans1 + ans2</span><br><span class="line">    <span class="keyword">return</span> helper(arr,length,width)</span><br></pre></td></tr></table></figure>

<h3 id="Papercut"><a href="#Papercut" class="headerlink" title="Papercut"></a>Papercut</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">qs</span>):</span></span><br><span class="line">    ans = [cutornot(x) <span class="keyword">for</span> x <span class="keyword">in</span> qs]</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">2</span> ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(qs)) <span class="keyword">if</span> ans[i] == <span class="number">1</span>) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutornot</span>(<span class="params">q</span>):</span></span><br><span class="line">    a,b,c,d = q</span><br><span class="line">    e, f, g, h = c % a, c % b, d % a, d % b</span><br><span class="line">    <span class="keyword">if</span> e + h == <span class="number">0</span> <span class="keyword">or</span> f + g == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> e + f == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> axbyc(a,b,d)</span><br><span class="line">    <span class="keyword">if</span> g + h == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> axbyc(a,b,c)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">axbyc</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> any((c - a * i) % b == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,c//a+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h3 id="Satisfaction"><a href="#Satisfaction" class="headerlink" title="Satisfaction"></a>Satisfaction</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, proposition</span>):</span></span><br><span class="line">    pa = proposition.replace(<span class="string">&#x27;AND&#x27;</span>,<span class="string">&#x27;and&#x27;</span>)</span><br><span class="line">    po = pa.replace(<span class="string">&#x27;OR&#x27;</span>,<span class="string">&#x27;or&#x27;</span>)</span><br><span class="line">    p_final = po.replace(<span class="string">&#x27;NOT&#x27;</span>,<span class="string">&#x27;not&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    l = int(<span class="number">2</span> ** n)</span><br><span class="line">    ans = [<span class="number">0</span>]* l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> ** n, <span class="number">2</span> ** (n + <span class="number">1</span>)):</span><br><span class="line">        assign_tmp = bin(i)[<span class="number">3</span>:]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            exec(chr(<span class="number">65</span> + j) + <span class="string">&quot;=&quot;</span> + assign_tmp[j])</span><br><span class="line">        ans[i - l] = eval(p_final)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(ans)</span><br><span class="line"></span><br><span class="line">s = solution(n,proposition)</span><br><span class="line"><span class="comment"># s = solution(3, &quot;A AND NOT NOT B OR C AND NOT (A OR B)&quot;)</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<h3 id="Prime-Feast"><a href="#Prime-Feast" class="headerlink" title="Prime Feast"></a>Prime Feast</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">s</span>):</span></span><br><span class="line">    prime_book = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, bound</span>):</span></span><br><span class="line">        <span class="comment"># if s not in book.keys():</span></span><br><span class="line">        candidate = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkn</span>(<span class="params">s, n, candidate</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s) - n + <span class="number">1</span>):</span><br><span class="line">                num_tmp = int(s[i:i + n])</span><br><span class="line">                <span class="keyword">if</span> num_tmp <span class="keyword">not</span> <span class="keyword">in</span> prime_book:</span><br><span class="line">                    <span class="keyword">if</span> i != <span class="string">&#x27;0&#x27;</span><span class="keyword">and</span> bound &gt; num_tmp <span class="keyword">and</span> primecheck(num_tmp):</span><br><span class="line">                        prime_book.add(num_tmp)</span><br><span class="line">                        candidate.append(int(s[i:i + n]) + helper(s[:i] + s[i + n:], num_tmp))</span><br><span class="line">                <span class="keyword">elif</span> i != <span class="string">&#x27;0&#x27;</span><span class="keyword">and</span> bound &gt; num_tmp <span class="keyword">and</span> primecheck(num_tmp):</span><br><span class="line">                    candidate.append(int(s[i:i + n]) + helper(s[:i] + s[i + n:], num_tmp))</span><br><span class="line">        checkn(s, <span class="number">4</span>, candidate)</span><br><span class="line">        checkn(s, <span class="number">3</span>, candidate)</span><br><span class="line">        checkn(s, <span class="number">2</span>, candidate)</span><br><span class="line">        checkn(s, <span class="number">1</span>, candidate)</span><br><span class="line">        <span class="comment"># book[s] = max(candidate, default=0)</span></span><br><span class="line">        <span class="comment"># print(s, candidate)</span></span><br><span class="line">        <span class="keyword">return</span> max(candidate, default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(s,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primecheck</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, math.floor(n ** <span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="Snakes-and-Ladders"><a href="#Snakes-and-Ladders" class="headerlink" title="Snakes and Ladders"></a>Snakes and Ladders</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, snakes, ladders</span>):</span></span><br><span class="line">    <span class="comment"># 会出现循环</span></span><br><span class="line">    <span class="comment"># 准备从递归变为迭代</span></span><br><span class="line">    <span class="comment"># 迭代跑得过慢，我准备用手算了</span></span><br><span class="line">    <span class="comment"># 不改了，居然在服务器上面跑的挺快的，...</span></span><br><span class="line">    <span class="comment"># 开始过了9/10 后来怎么也过不去了..原来第一次是蒙混过关</span></span><br><span class="line"></span><br><span class="line">    sl = snakes+ladders</span><br><span class="line">    trans = &#123;item[<span class="number">0</span>]:item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> sl&#125;</span><br><span class="line"></span><br><span class="line">    book = [(N - i + <span class="number">4</span>) // <span class="number">6</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">6</span>)]</span><br><span class="line">    flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">in</span> trans.keys():</span><br><span class="line">            book[number] = book[trans[number]]</span><br><span class="line">        <span class="keyword">elif</span> number &gt;= N<span class="number">-1</span>:</span><br><span class="line">            book[number] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans_tmp = <span class="number">1</span> + <span class="number">1</span> / <span class="number">6</span> * book[number + <span class="number">1</span>] + <span class="number">1</span> / <span class="number">6</span> * book[number + <span class="number">2</span>] + <span class="number">1</span> / <span class="number">6</span> * book[number + <span class="number">3</span>] + <span class="number">1</span> / <span class="number">6</span> * book[number + <span class="number">4</span>] + <span class="number">1</span> / <span class="number">6</span> * book[number + <span class="number">5</span>] + <span class="number">1</span> / <span class="number">6</span> * book[number + <span class="number">6</span>]</span><br><span class="line">            book[number] = ans_tmp</span><br><span class="line">        <span class="keyword">return</span> book[number]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        book_backup = book[::]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            helper(i)</span><br><span class="line">        diff = sum(abs(book_backup[i] - book[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(N))</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0.001</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> int(book[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Task-Genie"><a href="#Task-Genie" class="headerlink" title="Task Genie"></a>Task Genie</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实在不会，用了穷举法</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">ts, w</span>):</span></span><br><span class="line">    <span class="comment"># print(ts,w)</span></span><br><span class="line">    <span class="comment"># now = [[0]]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">ts</span>):</span></span><br><span class="line">        leaf = set([*range(len(ts))])</span><br><span class="line">        d = collections.defaultdict(dict)</span><br><span class="line">        d[<span class="number">0</span>] = &#123;ts[<span class="number">0</span>][<span class="number">1</span>]:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(ts)):</span><br><span class="line">            d[i] = d[ts[i][<span class="number">0</span>]].copy()</span><br><span class="line">            d[i][ts[i][<span class="number">1</span>]] = i</span><br><span class="line">            leaf = leaf - &#123;ts[i][<span class="number">0</span>]&#125;</span><br><span class="line">            <span class="comment"># now.append(now[ts[i][0]] + [ts[i][1]])</span></span><br><span class="line"></span><br><span class="line">        max_tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> leaf:</span><br><span class="line">            sum_tmp = sum(d[i].keys())</span><br><span class="line">            <span class="keyword">if</span> sum_tmp &gt; max_tmp:</span><br><span class="line">                max_tmp = sum_tmp</span><br><span class="line">        <span class="keyword">return</span> max_tmp</span><br><span class="line"></span><br><span class="line">    ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> candidate <span class="keyword">in</span> itertools.combinations(range(len(ts)),w):</span><br><span class="line">        tsc = ts.copy()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> candidate:</span><br><span class="line">            tsc[i] = (tsc[i][<span class="number">0</span>], <span class="number">0</span> )</span><br><span class="line">        ans.append(helper(tsc))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min(ans)</span><br></pre></td></tr></table></figure>

<h3 id="Wascally-Wabbits"><a href="#Wascally-Wabbits" class="headerlink" title="Wascally Wabbits"></a>Wascally Wabbits</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wabbits = [(<span class="number">-1</span>, <span class="string">&#x27;R&#x27;</span>), (<span class="number">0</span>, <span class="string">&#x27;R&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;?&#x27;</span>)]</span><br><span class="line">p_numerator, p_denominator = <span class="number">1</span>, <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">wabbits, p_numerator, p_denominator</span>):</span></span><br><span class="line">    candidate = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wabbits)) <span class="keyword">if</span> wabbits[i][<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">    book = &#123;(<span class="string">&#x27;RR&#x27;</span>,<span class="string">&#x27;RR&#x27;</span>):Fraction(<span class="number">16</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;Rg&#x27;</span>,<span class="string">&#x27;RR&#x27;</span>):Fraction(<span class="number">4</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;gg&#x27;</span>,<span class="string">&#x27;RR&#x27;</span>):Fraction(<span class="number">1</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;RR&#x27;</span>,<span class="string">&#x27;Rg&#x27;</span>):Fraction(<span class="number">8</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;Rg&#x27;</span>,<span class="string">&#x27;Rg&#x27;</span>):Fraction(<span class="number">17</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;gg&#x27;</span>,<span class="string">&#x27;Rg&#x27;</span>):Fraction(<span class="number">8</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;RR&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>):Fraction(<span class="number">1</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;Rg&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>):Fraction(<span class="number">4</span>,<span class="number">25</span>),</span><br><span class="line">            (<span class="string">&#x27;gg&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>):Fraction(<span class="number">16</span>,<span class="number">25</span>)&#125;</span><br><span class="line"></span><br><span class="line">    pos = [<span class="string">&#x27;RR&#x27;</span>,<span class="string">&#x27;Rg&#x27;</span>,<span class="string">&#x27;gg&#x27;</span>]</span><br><span class="line">    ans = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> pos:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> pos:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> pos:</span><br><span class="line">                ans[(a,b,c)] = book[(a,b)] * book[(b,c)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> ans.keys():</span><br><span class="line">        <span class="keyword">if</span> k[<span class="number">0</span>] == <span class="string">&#x27;Rg&#x27;</span>:</span><br><span class="line">            ans[k] = ans[k] / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans[k] = ans[k] / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    denominator = sum(ans[k] <span class="keyword">for</span> k <span class="keyword">in</span> ans.keys() <span class="keyword">if</span> k[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span> <span class="keyword">and</span> k[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    numerator = sum(ans[k] <span class="keyword">for</span> k <span class="keyword">in</span> ans.keys() <span class="keyword">if</span> k[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span> <span class="keyword">and</span> k[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span> <span class="keyword">and</span> k[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;32275&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2020-07-22-高考系列纪录片"><a href="#2020-07-22-高考系列纪录片" class="headerlink" title="2020/07/22 高考系列纪录片"></a>2020/07/22 <a href="https://www.youtube.com/playlist?list=PLwXMmy5fUrVw2prjsGuKla15LPRVnSv6G">高考系列纪录片</a></h2><h4 id="第四集"><a href="#第四集" class="headerlink" title="第四集"></a>第四集</h4><p>关于国学老师：</p>
<ul>
<li>确实，他看起来没有“因材施教”。评论区有人说到或许可以从英文讲国学的视频入手，吸引学生兴趣再来讲。有道理，但我不太认同。因为国学就是国学，或许有一丝当仁不让的意思在里面。国外来的始终还是二手货。这有点像将圣经的说法加以普世的修改，从而吸引更多的人来教会。对一个东西忠诚，就应该将它原貌展示给大家。要靠他本身的魅力去吸引人，而不是媒介。</li>
<li>这个老师的热情已经难觅了。我就想找到这样的热情！</li>
<li>关于文化认同，我觉得有道理。或许在发现自己无法融入外国社会的时候，对自己民族更有认同感吧。可这也无可厚非？</li>
</ul>
<p>关于不同的家庭：</p>
<ul>
<li>确实和前几集学生的差距较大。但是哪一种方式更好呢？想起了前一阵看阿凡达时的体会。那个星球的蓝色居民，他们不快乐吗？如果有的选，你会选择成为他们中的一员吗？更好的阶级/优质的家庭 = 更多的选择，选择多了对于能力不足的人来说，也会带来问题。</li>
<li>这些美本确实很厉害，从热情到自信。如果能有国内学生的努力刻苦，再加上国外学生的自信热情，就完美了。</li>
</ul>
<h2 id="2020-07-16-盖洛普测试"><a href="#2020-07-16-盖洛普测试" class="headerlink" title="2020/07/16 盖洛普测试"></a>2020/07/16 盖洛普测试</h2><p>用学生优惠做了一个基础版<a href="https://www.gallup.com/home.aspx">盖洛普测试</a> ，把结果po在下面。整体上来说，和我对自己的估计差不多。</p>
<img src="https://i.imgur.com/N8ol6O6.png" alt="N8ol6O6" style="zoom:50%;" />



<h4 id="性格分析"><a href="#性格分析" class="headerlink" title="性格分析"></a>性格分析</h4><ul>
<li><p>By nature, you are inclined to <strong>finish whatever is assigned to you</strong> each day.</p>
</li>
<li><p>Because of your strengths, you have an insatiable — that is, incapable of being satisfied — appetite for <strong>information</strong>.</p>
</li>
<li><p>You contend that <strong>harming another human being eventually harms you</strong>.</p>
</li>
<li><p>You may have <strong>fewer emotional ties to your job</strong> than some people do. As a result, you might be able to help others objectively look at the facts about their positions, pay, coworkers, employers, or workplace issues</p>
<ul>
<li>这一点好处我从未想过…</li>
</ul>
</li>
<li><p>Because of your strengths, you like to <strong>set up systems for dealing with repetitious tasks</strong>. You are delighted when everyone in a group adopts your methodical procedures. People who insist on performing an assignment, chore, or program their own way annoy you.</p>
</li>
<li><p>You like to redesign how a task is performed so those doing it only have to follow the pattern you create.</p>
</li>
<li><p>As a result, the people with whom you live, work, and study can usually predict what you will say or do.</p>
</li>
<li><p>You may seek out specific kinds of problems that <strong>you have met many times before</strong> and that you are confident you can fix.</p>
</li>
<li><p>Belief provides you with direction, <strong>guiding you through the temptations</strong> and distractions of life toward a consistent set of priorities.</p>
</li>
</ul>
<h4 id="就业指导"><a href="#就业指导" class="headerlink" title="就业指导"></a>就业指导</h4><ul>
<li>Seek roles in which you are paid to solve problems or in which your success depends on your ability to restore and resolve. You might particularly enjoy roles in <strong>medicine, consulting, computer programming, or customer service.</strong></li>
<li><strong>Let other people solve their own problems</strong>. You might want to rush in and solve things for them, but by doing that, you might hinder their learning. Watch out for this, particularly if you are in a manager, coach, teacher, or parent role.</li>
<li>Leverage your Restorative talents not only to tackle existing problems, but also to <strong>anticipate and prevent problems</strong> before they occur. </li>
<li><strong>Partner with someone with strong Communication talents.</strong> This person can help you with the words you need to describe vivid examples of connection in the real world.</li>
<li><strong>Don’t spend too much time attempting to persuade others to see the world as a linked web.</strong> Be aware that your sense of connection is intuitive. If others don’t share your intuition, rational argument will not persuade them.</li>
<li><strong>Avoid roles that will lead you to confront people on a daily basis.</strong> Sales roles based on “cold calls” or roles in highly competitive workplaces, for example, will frustrate or upset you.</li>
<li><strong>Practice your techniques for resolving conflict without confrontation.</strong> Without these polished techniques, you might find yourself simply running away from conflicts, leaving them unresolved. This could lead you to passive-aggressive behavior.<ul>
<li>防治正面冲突不等于逃避问题。问题还是得解决。</li>
</ul>
</li>
<li><strong>Partner with someone especially talented in Command or Activator</strong>. When all your best efforts to resolve a conflict have met with no success, this person can help you confront it head-on.<ul>
<li>不能包抄迂回的时候，需要有人推你一把。</li>
</ul>
</li>
<li>A <strong>balance between listening and efficiency</strong> is key to harmony.<ul>
<li>有人如果不珍惜平等交流的好机会，反而用来夹带私货，要及时制止</li>
</ul>
</li>
<li>Deference comes naturally for you. You easily <strong>step aside when someone with superior expertise enters.</strong> Take the next step by inviting those with greater expertise to consult.<ul>
<li>给大佬递茶</li>
</ul>
</li>
<li>Find a role in which you can enforce compliance to a set of standards. Always be ready to <strong>challenge people who break the rules</strong> or “grease the wheels” to earn an unfair advantage for themselves.<ul>
<li>有人打破了规则为自己谋利，要及时制止</li>
</ul>
</li>
<li><strong>Partner with someone with powerful Maximizer or Individualization talents.</strong> This person can remind you when it is appropriate to accommodate individual differences.<ul>
<li>要有人帮我注意到事实的另一方面</li>
</ul>
</li>
<li>Clarify your values by <strong>thinking about one of your best days ever</strong>. How did your values play into the satisfaction that you received on that day? How can you organize your life to repeat that day as often as possible?<ul>
<li>如何过我的生活，从而能使我最美好的一天能不断的重现？</li>
</ul>
</li>
<li>Create a gallery of letters and/or pictures of the people whose lives you have substantially influenced. When you are feeling down or overwhelmed, remind yourself of your value by looking at this gallery. It will energize you and revive your commitment to helping others.<ul>
<li>如何重拾力量？</li>
</ul>
</li>
<li>Accept that the values of other people might differ from your own. <strong>Express your beliefs without being judgmental.</strong><ul>
<li>哎…</li>
</ul>
</li>
</ul>
<h4 id="类似性格人的分享"><a href="#类似性格人的分享" class="headerlink" title="类似性格人的分享"></a>类似性格人的分享</h4><blockquote>
<ol>
<li>You start to feel connected to others because you know they have wisdom that you don’t. <strong>You can’t feel connected if you think you have everything.</strong></li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>Consistency 还有一种含义是一视同仁。不能见人下菜碟。</li>
<li>如果你做的事不重要，为何要做？</li>
</ol>
</blockquote>
<h2 id="2020-07-08-【半佛】应届生求职利益最大化指南"><a href="#2020-07-08-【半佛】应届生求职利益最大化指南" class="headerlink" title="2020/07/08 【半佛】应届生求职利益最大化指南"></a>2020/07/08 <a href="https://www.bilibili.com/video/BV1st4y197pq">【半佛】应届生求职利益最大化指南</a></h2><p><img src="https://i.imgur.com/tVHJ6SX.jpg" alt="tVHJ6SX"></p>
<h3 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h3><p>如果想体现个人的价值，尽量要去<strong>朝阳行业</strong>，和<strong>竞争充分的行业</strong>。</p>
<ul>
<li>充分竞争：这个行业的薪酬是存在较大变数的。对人才的渴求高，猎头活跃，跳槽有的跳。（互联网/金融）</li>
<li>不充分竞争：这个行业大家差不多，没啥好跳的，入门也没什么好选的，一个萝卜一个坑。（国企公务员）</li>
</ul>
<p>在选择行业的时候，忽视自己的梦想，只选风口，因为大多数人的努力未必会产生什么结果。</p>
<h3 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h3><p>交通便利降低了城市的重要性，大城市能玩的/看的/知道的，小城市也差不多。</p>
<p>城市的选择影响生活品质。</p>
<ul>
<li>要选择<strong>高速发展，人口高速流入</strong>的城市（机会会越来越多）。</li>
<li>小城市的一个问题：过于关系社会</li>
</ul>
<h3 id="公司地位"><a href="#公司地位" class="headerlink" title="公司地位"></a>公司地位</h3><p>第一份工作，厂越大越好。行业地位越高越好。核心点是：<strong>让自己变得更加值钱，稳妥落地</strong>。</p>
<ul>
<li>小公司的问题：随时为生存奔波，不稳定。<ul>
<li>螺丝钉：不是哪里适合往哪拧，是哪里缺人往哪里拧。</li>
<li>大佬可以去小厂享受红利，应届生不行。</li>
</ul>
</li>
</ul>
<p>每个人的价格定义：公司背书 + 项目履历 + 职位类型。</p>
<h3 id="岗位性质"><a href="#岗位性质" class="headerlink" title="岗位性质"></a>岗位性质</h3><p>岗位的选择：<strong>越核心，门槛越高</strong>越好。</p>
<ul>
<li>技术 &gt; 产品 &gt; 运营 &gt; 行政 &gt; 销售</li>
</ul>
<p>岗位要和公司加在一起选择。如果从事直播，那么斗鱼&gt;&gt;百度。</p>
<h3 id="直属领导的SB程度"><a href="#直属领导的SB程度" class="headerlink" title="直属领导的SB程度"></a>直属领导的SB程度</h3><p>老板跟你的利益是冲突的。只有榨取你的价值，才能铸就他晋升的阶梯。</p>
<p>核心两个点（老板是否值得追随）：</p>
<ol>
<li>许下的承诺能否兑现</li>
<li>有没有经常用梦想和荣誉给你洗脑（但是不给钱）<ul>
<li>谁的梦想是上班？简直是脑子有病。</li>
</ul>
</li>
</ol>
<p>没有你，公司一样转。但是没有你，家庭就会面临很大的问题。</p>
<h3 id="薪酬"><a href="#薪酬" class="headerlink" title="薪酬"></a>薪酬</h3><p>问一下公司对于应届生的培养有什么样子的规划。</p>
<ul>
<li>最好能够给出一个具体的案例。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>没有议价权，就没有主动权。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随手记</category>
      </categories>
  </entry>
  <entry>
    <title>名人传</title>
    <url>/2020/07/13/%E5%90%8D%E4%BA%BA%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>《名人传》是法国作家罗曼·罗兰所著《贝多芬传》、《米开朗琪罗传》和《托尔斯泰传》的合称。《名人传》的三位传主都是人类历史上极富天才而创建至伟的人物，他们的人生丰富多彩，他们的作品精深宏博，他们的影响历经世代而不衰，罗曼·罗兰紧紧把握住这三位有着各自领域的艺术家的共同之处，着力刻画他们在扰患困顿的人生征途上历尽苦难与颠踬而不改初衷的心路历程，凸现他们崇高的人格、博爱的情感和广阔的胸襟，从而为我们谱写了另一阕“英雄交响曲”。</p>
<a id="more"></a>



<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>罗曼·罗兰（法語：Romain Rolland；1866年1月29日－1944年12月30日），20世纪的法国著名作家、音乐评论家，1915年度的诺贝尔文学奖得主。</p>
<h1 id="贝多芬传"><a href="#贝多芬传" class="headerlink" title="贝多芬传"></a>贝多芬传</h1><blockquote>
<p>他所谓英雄，不是通常所称道的英雄人物。<strong>那种人凭借强力，在虚荣或个人野心的驱策下，能为人类酿造巨大的灾害。</strong>罗曼罗兰所指的英雄，只不过是”人类的忠仆“。只因为具有伟大的品格；他们之所以伟大，是因为能倾心为公众服务。</p>
</blockquote>
<p>我们每一个平凡人，即使没什么天分，只要我们锤炼自己的品格，也可以成为英雄。</p>
<blockquote>
<p>我愿证明，凡是行为善良与高尚的人，定能因之而担当患难。—— 贝多芬</p>
</blockquote>
<p>选择走艰难的道路</p>
<blockquote>
<p>没有伟大的品格，就没有伟大的人，甚至也没有伟大的艺术家，伟大的行动者。</p>
<p>所有的只是些空虚的偶像，匹配下贱的群众。</p>
<p>时间会把他们一齐摧毁 ! 成败又有什么相干。主要是成为伟大，而非显得伟大 !</p>
</blockquote>
<p>而非显得伟大/显得厉害。空虚的偶像 = 下贱的群众。</p>
<blockquote>
<p>所以不幸的人啊，切勿过于怨叹。人类中最优秀的和你们同在 ! </p>
<p>汲取他们的勇气做我们的养料罢！倘使我们太弱，就把我们的头枕在他们膝上休息一会罢，他们会安慰我们 !</p>
<p>你会发现，生命从没像处于患难时的那么伟大、 那么丰满、那么幸福 !</p>
</blockquote>
<p>倘若我们处在不幸之中，我们要告诉自己，我们正在和人类中最优秀的同在！</p>
<blockquote>
<p>一八二五年，雷斯塔伯说，看见他温柔的眼睛及其剧烈的痛苦时，他需要竭尽全力才能止住眼泪。</p>
</blockquote>
<blockquote>
<p>贝多芬的童年尽管如是悲惨。他对这个时代和消磨这时代的地方，永远保持着一种温柔而凄凉的回忆。</p>
</blockquote>
<p>贝多芬还真是一个温柔的人。</p>
<blockquote>
<p>一七九六年至一八零零年，耳聋已开始它的酷刑。</p>
<p>同时我们可注意他的作品目录。惟有包括三支三重奏的作品第一号是一七九六年以前的制作，包括三支最初的奏鸣曲的作品第二号，是一七九六年三月刊行的。</p>
<p>因此贝多芬全部的作品可说都是耳聋后写的</p>
</blockquote>
<p>1770出生，26岁就开始失聪了…</p>
<blockquote>
<p>在这些肉体的痛苦之上，再加另外一种痛苦。韦格勒说，他从没见过贝多芬不抱着一股剧烈的热情。这些爱情似乎永远是非常纯洁的。</p>
<p>热情与欢娱之间毫无连带关系。现代的人们把这两者混为一谈，实在是他们全不知道何谓热情，也不知道热情之如何难得。</p>
</blockquote>
<blockquote>
<p>据说他不能原谅莫扎特，因为他不惜屈辱自己的天才去写《唐璜》</p>
</blockquote>
<blockquote>
<p>其次，圭恰迪妮是风骚的、稚气的、自私的，使贝多芬苦恼。她嫁了加伦贝格伯爵，随后她还利用贝多芬以前的情爱，要他帮助她的丈夫。贝多芬立刻答应了。</p>
<p>他在一八二一年和申德勒会见时在谈话手册上写道，他是我的敌人，所以我更要尽力帮助他，但他因之而更瞧不起她。“她到维也纳来找我。一边哭着，但是我瞧不起她”</p>
</blockquote>
<p>他为什么要尽力的帮助自己的敌人？</p>
<blockquote>
<p>他的遗嘱里有一段说：“把德性教给你们的孩子，使人幸福的是德性，而非金钱，这是我的经验之谈。在患难中支持我的是道德，使我不曾自杀的，除了艺术以外也是道德。“</p>
</blockquote>
<blockquote>
<p>他的强毅的天性不能遇到磨难就屈服。”我的体力和智力突飞猛进，我的青春！是的，我感到我的青春不过才开始！我窥见我不能加以肯定的目标，我每天都迫近它一些！……噢，如果我摆脱了这疾病，我将拥抱世界！一些休息都没有！除了睡眠以外我不知还有什么休息，而可怜我对于睡眠不得不花费比从前更多的时间。但愿我能在疾病中解放出一半，那时候！……不，我受不了！我要扼住命运的咽喉！它决不能使我完全屈服……噢，能把人生活上千百次，真是多美！”</p>
</blockquote>
<blockquote>
<p>《热情奏鸣曲》（作品第五十七号1804）俾斯麦曾经说过：“倘我常听到它，我的勇气将永远不竭。”</p>
</blockquote>
<blockquote>
<p>特雷泽曾把她的肖像赠与贝多芬，题着：“给希有的天才、伟大的艺术家、善良的人。” 这幅肖像至今还在波恩的贝多芬家。在贝多芬晚年，一位朋友无意中撞见他独自拥抱着这幅肖像，哭着，高声地自言自语着（这是他的习惯）“你这样的美、这样的伟大、和天使一样！” 朋友退了出去。</p>
<p>过了一会再进去，看见他在弹琴，便对他说：“今天，我的朋友，你的脸上全无可怕的气色。” 贝多芬答道，因为我的好天使来访问过我了。</p>
</blockquote>
<blockquote>
<p>罗西尼的歌剧《唐克雷迪》足以撼动整个的德国音乐。一八一六年时维也纳沙龙里的意见，据鲍恩费尔德的日记所载是：“莫扎特和贝多芬是老学究，只有荒谬的上一代赞成他们。但直到罗西尼出现，大家方知何谓旋律。”《菲岱里奥》是一堆垃圾，真不懂人们怎会不怕厌烦地去听它。</p>
</blockquote>
<blockquote>
<p>一个英国游历家罗素，一八二五年时看见过他弹琴，说当他要表现柔和的时候，琴键不曾发声。在这静寂中看着他情绪激动的神气，脸部和手指都抽搐起来，真是令人感动！</p>
</blockquote>
<blockquote>
<p>一八一五年时认识他的查理·纳德，说他从未见过一个人像他这样的爱花木、云彩、自然。他似乎靠着自然生活。</p>
</blockquote>
<p>这贝多芬…有点完美了</p>
<blockquote>
<p>他为金钱的烦虑弄得困惫不堪。一八一八年时他写道：“我差不多到了行乞的地步，而我还得装做日常生活并不艰窘的神气。”此外他又说，作品第106号的奏鸣曲是在紧急情况中写的，要以工作来换取面包实在是一件苦事。施波尔说他往往不能出门，为了靴子洞穿之故。他对出版商负着重债，而作品又卖不出钱。D调弥撒曲发售预约时，只有七个预约者，其中没有一个是音乐家。他全部美妙的奏鸣曲，每曲都得花费他三个月的工作——只给他挣了三十至四十杜加。加利钦亲王要他制作的四重奏作品第127/130/132号，也许是他作品中最深刻的、仿佛用血泪写成的。结果是一文都不曾拿到。把贝多芬煎熬完的是，日常的窘况，无穷尽的讼案，或是要人家履行津贴的诺言，或是为争取侄儿的监护权。</p>
</blockquote>
<p>这太惨了…</p>
<blockquote>
<p>反复原谅侄子，因侄子而苍老得像“七十岁的老人”。贝多芬的葬礼上侄子却没有出现。</p>
<p>在此悲苦的深渊里 ，贝多芬从事于讴歌欢乐。</p>
</blockquote>
<p>…</p>
<blockquote>
<p>巨人的巨著终于战胜了群众的庸俗，维也纳轻浮的风气被它震撼了一刹那，这都城当时是完全在罗西尼与意大利歌剧的势力之下的。</p>
</blockquote>
<blockquote>
<p>一八二四年五月七日，在维也纳举行D调弥撒曲,和第九交响曲的第一次演奏会,获得空前的成功！情况之热烈，几乎含有暴动的性质。当贝多芬出场时，受到群众五次鼓掌的欢迎。在此讲究礼节的国家，对皇族的出场习惯也只用三次的鼓掌礼，因此警察不得不出面干涉。交响曲引起狂热的骚动，许多人哭起来。贝多芬在终场以后感动得晕去，大家把他抬到申德勒家，他朦朦胧胧地和衣睡着、不饮不食、直到次日早上。可是胜利是暂时的，对贝多芬毫无盈利。音乐会不曾给他挣什么钱，物质生活的窘迫依然如故，他贫病交迫、孤独无依、可是战胜了。战胜了人类的平庸，战胜了他自己的命运，战胜了他的痛苦。</p>
</blockquote>
<blockquote>
<p>他自己也感到，他时常提起，他的责任是把他的艺术来奉献于“可怜的人类”，“将来的人类”，为他们造福利、给他们勇气、唤醒他们的迷梦、斥责他们的懦怯！</p>
</blockquote>
<p>哎！</p>
<blockquote>
<p>一个不幸的人、贫穷、残废、孤独、由痛苦造成的人。世界不给他欢乐，他却创造了欢乐来给予世界！他用他的苦难来铸成欢乐，好似他用那句豪语来说明的，那是可以总结他一生，可以成为一切英勇心灵的箴言的：</p>
<p>“用痛苦换来的欢乐”</p>
</blockquote>
<blockquote>
<p>我和伏尔泰一样的想，“几个苍蝇咬几口，决不能羁留一匹英勇的奔马。”</p>
</blockquote>
<blockquote>
<p>青年时，朋友们向他提起他的声名。他回答说：“无聊，我从未想到声名和荣誉而写作。我心坎里的东西要出来，所以我才写作。”</p>
</blockquote>
<blockquote>
<p>他的钢琴即兴，素来被认为具有神奇的魔力。当时极优秀的钢琴家里斯和车尔尼辈都说，除了思想的特异与优美之外，表情中间另有一种异乎寻常的成分。他赛似狂风暴雨中的魔术师，会从“深渊里”把精灵呼召到“高峰上”，听众嚎啕大哭。他的朋友雷夏尔特流了不少热泪，没有一双眼睛不湿。当他弹完以后看见这些泪人儿时，他耸耸肩，放声大笑道：“啊!疯子！你们真不是艺术家。艺术家是火!他是不哭的”</p>
</blockquote>
]]></content>
      <categories>
        <category>Books</category>
        <category>名人传</category>
      </categories>
  </entry>
  <entry>
    <title>酒店</title>
    <url>/2020/07/22/%E9%85%92%E5%BA%97/</url>
    <content><![CDATA[<p>这里记录曾住过的酒店以及评价。地区和餐厅都是按照首字母排序。</p>
<a id="more"></a>




<h1 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h1><h2 id="首都国际希尔顿"><a href="#首都国际希尔顿" class="headerlink" title="首都国际希尔顿"></a>首都国际希尔顿</h2><p>2019年10月28日 大床房：亲友 RMB 698.43</p>
<blockquote>
<p>沛吉和仁聪一起来，我觉得三个人睡没什么问题，虽然有一点不好转身，中间那个人有点惨，不过不算人挤人，还可。房间不是很大，没有升房，可能因为我去的太晚了吧，不过要了白酒杯，很快就拿来了。</p>
</blockquote>
<h1 id="华盛顿"><a href="#华盛顿" class="headerlink" title="华盛顿"></a>华盛顿</h1><h2 id="Hilton-Garden-Inn-Reagan-National-Airport"><a href="#Hilton-Garden-Inn-Reagan-National-Airport" class="headerlink" title="Hilton Garden Inn Reagan National Airport"></a>Hilton Garden Inn Reagan National Airport</h2><p>05 Apr 2019 - 06 Apr 2019<br>07 Apr 2019 - 08 Apr 2019</p>
<blockquote>
<p>大床 问了前台，没有小吃，所以也就没问升级的事情。用手机开了酒店的后门</p>
</blockquote>
<h2 id="Hampton-Inn-amp-Suites-Reagan-National-Airport"><a href="#Hampton-Inn-amp-Suites-Reagan-National-Airport" class="headerlink" title="Hampton Inn &amp; Suites Reagan National Airport"></a>Hampton Inn &amp; Suites Reagan National Airport</h2><p>06 Apr 2019 - 07 Apr 2019</p>
<blockquote>
<p>大床 没问升级的事情。跟 Hilton Garden Inn Reagan National Airport 离得超近，就在隔壁，很适合切Stay</p>
</blockquote>
<h2 id="Hilton-Alexandria-Old-Town"><a href="#Hilton-Alexandria-Old-Town" class="headerlink" title="Hilton Alexandria Old Town"></a>Hilton Alexandria Old Town</h2><p>08 Apr 2019 - 09 Apr 2019</p>
<blockquote>
<p>大床 提前发了邮件谈心，没有获得回复，到店也没有升级。不过备品还可以，早餐有培根（还行）和小香肠（不好吃）。有个带着果酱的圆面包还挺好吃的。</p>
</blockquote>
<h1 id="加州其他地方"><a href="#加州其他地方" class="headerlink" title="加州其他地方"></a>加州其他地方</h1><h2 id="Hilton-Garden-Inn-Monterey"><a href="#Hilton-Garden-Inn-Monterey" class="headerlink" title="Hilton Garden Inn Monterey"></a>Hilton Garden Inn Monterey</h2><p>17 Mar 2019 - 18 Mar 2019</p>
<blockquote>
<p>停车费15刀 三星级 问了前台，有空房也没给升套，其次也不给小食… 这家Garden Inn的早饭是直接记录在房间号上面，每个房间两个人。</p>
</blockquote>
<h2 id="Hampton-Inn-amp-Suites-Arroyo-Grande-Pismo-Beach-Area"><a href="#Hampton-Inn-amp-Suites-Arroyo-Grande-Pismo-Beach-Area" class="headerlink" title="Hampton Inn &amp; Suites Arroyo Grande/Pismo Beach Area"></a>Hampton Inn &amp; Suites Arroyo Grande/Pismo Beach Area</h2><p>18 Mar 2019 - 19 Mar 2019</p>
<blockquote>
<p>双床</p>
</blockquote>
<h1 id="旧金山"><a href="#旧金山" class="headerlink" title="旧金山"></a>旧金山</h1><h2 id="Hampton-Inn-amp-Suites-Mountain-View"><a href="#Hampton-Inn-amp-Suites-Mountain-View" class="headerlink" title="Hampton Inn &amp; Suites Mountain View"></a>Hampton Inn &amp; Suites Mountain View</h2><p>16 Mar 2019 - 17 Mar 2019</p>
<blockquote>
<p>双床房，问了前台，被升级了套房，送了吃的</p>
</blockquote>
<h2 id="Hampton-Inn-San-Francisco-Daly-City"><a href="#Hampton-Inn-San-Francisco-Daly-City" class="headerlink" title="Hampton Inn San Francisco-Daly City"></a>Hampton Inn San Francisco-Daly City</h2><p>入住时间：17 Mar 2019 - 18 Mar 2019</p>
<blockquote>
<p>双床房，问了前台没得到升级，小食和水也是要来的</p>
</blockquote>
<h2 id="Four-Points-by-Sheraton-San-Francisco-Bay-Bridge"><a href="#Four-Points-by-Sheraton-San-Francisco-Bay-Bridge" class="headerlink" title="Four Points by Sheraton San Francisco Bay Bridge"></a>Four Points by Sheraton San Francisco Bay Bridge</h2><p>入住时间：2019年7月4日 - 2019年7月5日 Double Queen 164.06刀</p>
<blockquote>
<p>入住的很晚了，大概十一点半，只剩下一楼的一间房了…房间光线不好，占地面积还不错，洗手池在门口有点怪，不值这个价格</p>
</blockquote>
<h2 id="Hyatt-Centric-Fisherman’s-Wharf-San-Francisco"><a href="#Hyatt-Centric-Fisherman’s-Wharf-San-Francisco" class="headerlink" title="Hyatt Centric Fisherman’s Wharf San Francisco"></a>Hyatt Centric Fisherman’s Wharf San Francisco</h2><p>入住时间：2019年7月5日 - 2019年7月6日  Double Queen 15000点数 + 25刀</p>
<blockquote>
<p>被升级成了角房，收了25刀目的地费（一点也没用上），给了三瓶水以及两个巧克力。地角不错，不过对面是个HIX我猜应该更便宜，房间挺大的，装修风格也不错，不过不值250刀…</p>
</blockquote>
<h1 id="坎昆"><a href="#坎昆" class="headerlink" title="坎昆"></a>坎昆</h1><h2 id="Hyatt-Ziva-Cancun"><a href="#Hyatt-Ziva-Cancun" class="headerlink" title="Hyatt Ziva Cancun"></a>Hyatt Ziva Cancun</h2><p>入住时间：2019年12月24日 - 2019年12月27日 Hyatt 25K*3 + 294刀（升级到TURQUOIZE）</p>
<blockquote>
<p>吃的玩的都不错，感觉没啥必要升级，只是看了一下那个无边泳池，其他没什么区别。可以免费借海上的paddle board和kayak。我觉得水上项目没有Xel-ha提供的种类丰富。当然吃的确实Hyatt更好，法餐牛排馆都有不错的食物。这个地方适合度假，就是有钱的人过来休息休息的那种，不适合我们这种学生啦。</p>
</blockquote>
<h1 id="洛杉矶"><a href="#洛杉矶" class="headerlink" title="洛杉矶"></a>洛杉矶</h1><h2 id="Hilton-Los-Angeles-Airport"><a href="#Hilton-Los-Angeles-Airport" class="headerlink" title="Hilton Los Angeles Airport"></a>Hilton Los Angeles Airport</h2><p>入住时间： 2019年7月2日 - 2019年7月3日 Double Queen 92.17刀 + 130元</p>
<blockquote>
<p>难得在美国碰到一个带酒廊的希尔顿。这次没吃到酒廊的热菜，晚上的dessert只有饼干，这个酒廊喝酒是收费的。酒廊早餐中规中矩。房间在五楼，没有升级，没有欢迎礼。价格倒是还不错的，地址还行，有机场大巴，也有公交车到这边。大堂装修还挺奢华的！</p>
</blockquote>
<h2 id="Hilton-Garden-Inn-Los-Angeles-Hollywood"><a href="#Hilton-Garden-Inn-Los-Angeles-Hollywood" class="headerlink" title="Hilton Garden Inn Los Angeles/Hollywood"></a>Hilton Garden Inn Los Angeles/Hollywood</h2><p>入住时间： 2019年7月3日 - 2019年7月4日 Double Queen 126.69刀</p>
<blockquote>
<p>房间有个大电视。没有升级，没有欢迎礼，房间在顶楼7楼。早餐只有两个人的，可以点Omelette的那种。中规中矩。没有太多值得说的地方</p>
</blockquote>
<h1 id="麦迪逊"><a href="#麦迪逊" class="headerlink" title="麦迪逊"></a>麦迪逊</h1><h2 id="Hampton-Inn-amp-Suites-Madison-Downtown"><a href="#Hampton-Inn-amp-Suites-Madison-Downtown" class="headerlink" title="Hampton Inn &amp; Suites Madison / Downtown"></a>Hampton Inn &amp; Suites Madison / Downtown</h2><p>入住时间：24 Mar 2019 - 30 Mar 2019</p>
<blockquote>
<p>大床，mlq父母住的。进屋看了一下，地方虽然不大，但是床边是一个打落地窗，挺好看的。我是提前一天在手机上Check-In的，到店之后依旧被升级了，变成顶楼小套。</p>
</blockquote>
<h1 id="纽约"><a href="#纽约" class="headerlink" title="纽约"></a>纽约</h1><h2 id="Hilton-Garden-Inn-New-York-West-35th-Street"><a href="#Hilton-Garden-Inn-New-York-West-35th-Street" class="headerlink" title="Hilton Garden Inn New York/West 35th Street"></a>Hilton Garden Inn New York/West 35th Street</h2><p>入住时间： 2019年7月7日 - 2019年7月8日 Double Queen: 128.55刀 908房间</p>
<blockquote>
<p>早上大概7点半来的，没法check-in 下午两点再来的时候有房间了。行李寄存是一个单独的地方，我看存了好多行李，旁边有个Hampton Inn。感觉这个价格还行，房间有个大LG电视，不过没有什么额外的操作，办理入住的时候前台问我要早餐还是要积分，当然是早餐了啊！</p>
</blockquote>
<h2 id="DoubleTree-by-Hilton-Hotel-New-York-Times-Square-South"><a href="#DoubleTree-by-Hilton-Hotel-New-York-Times-Square-South" class="headerlink" title="DoubleTree by Hilton Hotel New York - Times Square South"></a>DoubleTree by Hilton Hotel New York - Times Square South</h2><p>入住时间： 2019年7月8日 - 2019年7月9日 Double Queen: 129.15刀 + 130</p>
<blockquote>
<p>住的房间很小，楼下有听课房的促销。地脚一般，早餐没吃上…父母都觉得这里不好，好吧，下次不来了…</p>
</blockquote>
<h2 id="Hampton-Inn-New-York-LaGuardia-Airport"><a href="#Hampton-Inn-New-York-LaGuardia-Airport" class="headerlink" title="Hampton Inn New York - LaGuardia Airport"></a>Hampton Inn New York - LaGuardia Airport</h2><p>入住时间： 2019年7月9日 - 2019年7月10日 Double Queen 150.38刀</p>
<blockquote>
<p>早餐还可以，两种Omelette，一个烤肠，还有果汁。去机场的大巴从4点起每20分钟一趟。住的房间还很大，感觉不错。打车从法拉盛到酒店只要10刀，不过那个Q48左等右等也不来。</p>
</blockquote>
<h2 id="Hilton-Garden-Inn-New-York-Times-Square-South"><a href="#Hilton-Garden-Inn-New-York-Times-Square-South" class="headerlink" title="Hilton Garden Inn New York Times Square South"></a>Hilton Garden Inn New York Times Square South</h2><p>入住时间： 2019年9月27日 - 2019年9月28日 King 55000分 2502</p>
<blockquote>
<p>手机check-in。选了最高楼层。房间不是很大，感觉房间挺干净的。没有牙膏还让楼下送上来了两个牙刷和四个牙膏。高露洁的。没吃早饭</p>
</blockquote>
<h2 id="Conrad-New-York-Downtown"><a href="#Conrad-New-York-Downtown" class="headerlink" title="Conrad New York Downtown"></a>Conrad New York Downtown</h2><p>入住时间： 2019年9月28日 - 2019年9月29日 King Aspire-FN 1224</p>
<blockquote>
<p>手机试着Check-In的时候发现已经被升级了，出现了OurPick的字样，于是就没继续Check-In。升级了一级房型，Hudson River View。感觉挺好看的。不过这个康莱德设备不太好，甚至不如天津凯悦，都不能自动升降窗帘。位置也不好，附近没有车站，南端倒是有很多大公司，不过对于乘坐公共交通的我们来说，实在是有点难办。跟芝加哥康莱德比差得很多。房间里面也是没啥东西，送了巧克力和两瓶水，以后应该不会来了。</p>
<p>后续：没用出来FN，被扣了500+刀。跟希尔顿打电话抱怨，获得全额reimbursement和一个FN。很厚道了！</p>
</blockquote>
<h2 id="Hilton-Garden-Inn-New-York-Manhattan-Midtown-East"><a href="#Hilton-Garden-Inn-New-York-Manhattan-Midtown-East" class="headerlink" title="Hilton Garden Inn New York/Manhattan-Midtown East"></a>Hilton Garden Inn New York/Manhattan-Midtown East</h2><p>入住时间： 2019年9月29日 - 2019年9月30日 King</p>
<blockquote>
<p>手机check-in的时候发现最高只有19楼，觉得是否提前check-in并不关键，所以作罢。没想到当晚八点多再看的时候，发现已经被提升到了20+楼层，出现了OurPick的字样，这说明如果check-in的时候发现房间不好，可以等等，因为很有可能那个房型最后会被占满，从而无处安放，只好给安排更好的楼层。这个就像AA check-in的时候如果普通座分完了之后就可以免费做高级座-.- 不过房间感觉有点脏，地毯和设施给人脏兮兮的感觉。房间还很小，体验不是很好，屋外是一个阳台，不过没什么风景，下次不会再来了应该。</p>
</blockquote>
<h1 id="天津"><a href="#天津" class="headerlink" title="天津"></a>天津</h1><h2 id="天津东凯悦"><a href="#天津东凯悦" class="headerlink" title="天津东凯悦"></a>天津东凯悦</h2><p>入住时间： 2019年8月3日 - 2019年8月4日双床房 5K凯悦积分 </p>
<img src="https://i.imgur.com/u2d025i.jpg" style="zoom:50%;" />

<blockquote>
<p>问了前台，升级成行政楼层，无早餐，延迟2点退房 地方挺大的，卫生间也比较高端，实话说我觉得这个床虽然不大，但是睡两个人也是勉强可以。我觉得这个酒店的质量挺好，跟国外的5K比肯定是好的了。没早餐有点难过</p>
</blockquote>
<h2 id="天津丽思卡尔顿"><a href="#天津丽思卡尔顿" class="headerlink" title="天津丽思卡尔顿"></a>天津丽思卡尔顿</h2><p>入住时间： 2019年8月7日 - 2019年8月8日 情人节 大床房 25K万豪点数</p>
<img src="https://i.imgur.com/06TwQ5z.jpg" style="zoom:50%;" />

<blockquote>
<p>提前打电话要了布置，问了前台，积分兑换奖励变少，不到白金的话早餐没有升房也没有，只有个延迟2点退房<br>位置不错，环境也好，布置的挺温馨，有玫瑰花瓣和小天鹅。整个酒店都是那种复古风格，青花瓷系列。从进门到退宿都有服务员上前服务，不得不说做的确实好。晚上五点有人来送水果，还有人来开夜床（被yqy拒绝了）服务到位，但是国内25K我还是嫌贵，要不是有这种特殊的节日我肯定是不会换的…免房券用在这里也不是特别赚。不过这家店着实是我来过的店里面最好的了，我觉得比芝加哥康莱德要好。</p>
</blockquote>
<h1 id="芝加哥"><a href="#芝加哥" class="headerlink" title="芝加哥"></a>芝加哥</h1><h2 id="Hilton-Garden-Inn-Chicago-North-Loop"><a href="#Hilton-Garden-Inn-Chicago-North-Loop" class="headerlink" title="Hilton Garden Inn Chicago/North Loop"></a>Hilton Garden Inn Chicago/North Loop</h2><p>入住时间：21 Nov 2018 - 25 Nov 2018</p>
<blockquote>
<p>大床房，问了前台，被升级到了最高层</p>
</blockquote>
<h2 id="Conrad-Chicago"><a href="#Conrad-Chicago" class="headerlink" title="Conrad Chicago"></a>Conrad Chicago</h2><p>入住时间：12 May 2019 - 13 May 2019</p>
<blockquote>
<p>大床房，两个人送了共计30刀的dining credit。in-room dining也可以用。但是提前要算好小费在里面。没有提前check-in，房间被升了一级。下午的时候还去拿了免费的Brunch甜点（也太甜了…）备品是上海滩，感觉还可以。check-in lobby在20层</p>
</blockquote>
<p>入住时间：2019年7月10日 - 2019年7月11日 双床房1418</p>
<img src="https://i.imgur.com/UfAYVVW.jpg" style="zoom:50%;" />

<blockquote>
<p>三个人的话早餐也只有30刀。In-room dining 了 Egg Benedict不好吃，那个土豆脆脆的好像没熟，那个鸡蛋太嫩了… 不过去了4pm-6pm的Hilton Honors Lounge. 免费喝点酒和小食。不过发现房间里面没有微波炉。</p>
</blockquote>
<p>入住时间： 2019年11月27日</p>
<blockquote>
<p>大床：亲友87.47，没什么亮点。不过他们家好像从一个半月之前开始做自助早餐了。</p>
</blockquote>
<h2 id="Home2-Suites-by-Hilton-Chicago-River-North"><a href="#Home2-Suites-by-Hilton-Chicago-River-North" class="headerlink" title="Home2 Suites by Hilton Chicago River North"></a>Home2 Suites by Hilton Chicago River North</h2><p>入住时间：13 May 2019 - 14 May 2019</p>
<blockquote>
<p>分数是折半算的，房间里居然还有菜刀和碗…幸亏多一个小毯子给女朋友盖上了…</p>
</blockquote>
<h2 id="The-Rose-Hotel-Chicago-O’Hare-Tapestry-Collection-by-Hilton"><a href="#The-Rose-Hotel-Chicago-O’Hare-Tapestry-Collection-by-Hilton" class="headerlink" title="The Rose Hotel Chicago O’Hare, Tapestry Collection by Hilton"></a>The Rose Hotel Chicago O’Hare, Tapestry Collection by Hilton</h2><p>入住时间：14 May 2019 - 15 May 2019</p>
<blockquote>
<p>屋内颜色有一点妖艳，不过感觉比W那还是差了很多（虽然我也没去过）。早餐是券的形式，每个人可以点一个主菜+一个饮品。感觉Omelette不好吃，女朋友那个Panini感觉还可以，点了个chocolate milk挺好喝的。</p>
</blockquote>
<h2 id="Hilton-Garden-Inn-Chicago-Downtown-Magnificent-Mile"><a href="#Hilton-Garden-Inn-Chicago-Downtown-Magnificent-Mile" class="headerlink" title="Hilton Garden Inn Chicago Downtown/Magnificent Mile"></a>Hilton Garden Inn Chicago Downtown/Magnificent Mile</h2><p>入住时间：2019年7月11日 - 2019年7月12日 Double Queen 99.79刀</p>
<blockquote>
<p>房间大小还可以，早餐是楼下的Weber Grill. 可以单点+自助。整体来说虽然人不少，但是速度还是很快的，吃饭这一项加分了，其他中规中矩，还可以。</p>
</blockquote>
<h2 id="Hampton-Inn-Chicago-Downtown-Magnificent-Mile"><a href="#Hampton-Inn-Chicago-Downtown-Magnificent-Mile" class="headerlink" title="Hampton Inn Chicago Downtown/Magnificent Mile"></a>Hampton Inn Chicago Downtown/Magnificent Mile</h2><p>入住时间：2019年7月12日 - 2019年7月13日 Double Queen 166.71刀</p>
<blockquote>
<p>这家店一共有40层，早餐时间根本等不到电梯。服务中规中矩，完全是因为地脚好从而有加成，我觉得一个Hampton Inn不值这么贵，房间一般般。</p>
</blockquote>
<h2 id="Hilton-Chicago"><a href="#Hilton-Chicago" class="headerlink" title="Hilton Chicago"></a>Hilton Chicago</h2><p>入住时间：2019年7月13日 - 2019年7月14日 Double Queen：150.86刀 + 50刀早餐 = 200.86刀</p>
<blockquote>
<p>地方还行，离那些公园（千禧公园）很近，装修还可以，房间里面两个厕所，但是下次打死我也不去了！早餐没有热食，热食要额外付款，这种糟心被坑的体验是很令人沮丧的。我觉得他并没有写清楚。</p>
</blockquote>
<p>入住时间： 2019年11月28日- 2019年12月1日 King：亲友191.47/3晚</p>
<p>入住时间： 2019年12月27日- 2019年12月28日 King：亲友58.11</p>
<blockquote>
<p>升级到了行政楼层2319，感觉没什么区别，房间没有变大，卫生间有两个洗面池。整体来讲，只要不吃早餐，那么这家店的价格很值得。</p>
</blockquote>
<h2 id="Hampton-Inn-Chicago-Downtown-West-Loop"><a href="#Hampton-Inn-Chicago-Downtown-West-Loop" class="headerlink" title="Hampton Inn Chicago Downtown West Loop"></a>Hampton Inn Chicago Downtown West Loop</h2><p>入住时间： 2019年12月1日 - 2019年12月2日 King：亲友69.86刀</p>
<blockquote>
<p>搞了一个残疾人的房间，确实大…感觉酒店是新建的，不过这个空调声音太大了，半夜没开空调，冷着睡的…</p>
</blockquote>
<h2 id="The-Drake-a-Hilton-Hotel"><a href="#The-Drake-a-Hilton-Hotel" class="headerlink" title="The Drake, a Hilton Hotel"></a>The Drake, a Hilton Hotel</h2><p>入住时间： 2019年12月19日 - 2019年12月20日 King：亲友63.98刀</p>
<img src="https://i.imgur.com/qViQebL.jpg" style="zoom:50%;" />

<blockquote>
<p>给我升了级，房间挺大的，但是暖气好像有点问题，开了85°也不热，盖着被还好，加上屋里有暖气。第一次见过电梯里面带一个小沙发的。住在1007，半夜外面有点动静，带着耳塞才可以睡着。酒廊还不错，下午去拿了一瓶可乐，三个水果，早餐的牛角包很好吃，不过没太多热食，有一个固体鸡蛋糕。下次来或许会选吧~就是位置有点偏。</p>
</blockquote>
<h2 id="HILTON-GARDEN-INN-CHICAGO-MIDWAY-AIRPORT"><a href="#HILTON-GARDEN-INN-CHICAGO-MIDWAY-AIRPORT" class="headerlink" title="HILTON GARDEN INN-CHICAGO MIDWAY AIRPORT"></a>HILTON GARDEN INN-CHICAGO MIDWAY AIRPORT</h2><p>入住时间： 2019年12月20日 - 2019年12月21日 King: 亲友 69.92</p>
<blockquote>
<p>早饭一般，房间的空调声音很大，制热效果一般。地角还行，不过下次可以试试旁边的欢朋。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
        <category>酒店</category>
      </categories>
  </entry>
  <entry>
    <title>餐馆</title>
    <url>/2020/07/22/%E9%A4%90%E9%A6%86/</url>
    <content><![CDATA[<p>这里记录曾吃过的餐馆以及评价。地区和餐厅都是按照首字母排序。</p>
<a id="more"></a>



<h1 id="安娜堡"><a href="#安娜堡" class="headerlink" title="安娜堡"></a>安娜堡</h1><h2 id="Asian-Legend-老地方"><a href="#Asian-Legend-老地方" class="headerlink" title="Asian Legend 老地方"></a>Asian Legend 老地方</h2><ul>
<li>Onion Pancakes 葱油饼 6分<ul>
<li>外卖，无功无过，不够咸，有点脆。</li>
</ul>
</li>
<li>Onion Pancake Wrapped with Beef 牛肉卷饼 5分<ul>
<li>不觉得牛肉跟这个饼很搭</li>
</ul>
</li>
<li>Chili Stir Fried Chili ( W . Chicken) 辣炒辣 6分<ul>
<li>比较下饭，不够咸，味道是之前没吃过的，不太熟悉。</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/3JtfFhN.jpg" style="zoom:15%;" />

<h2 id="Buddy’s-Pizza"><a href="#Buddy’s-Pizza" class="headerlink" title="Buddy’s Pizza"></a>Buddy’s Pizza</h2><p>2020/07/27 两人</p>
<ul>
<li><p>Detroiter (4 squares) 7分</p>
<ul>
<li>一般的pizza味道，还不错，油略微有点多，方块切块方式有点新颖</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/wmauSAo.jpg" style="zoom:10%;" />

<h2 id="Evergreen"><a href="#Evergreen" class="headerlink" title="Evergreen"></a>Evergreen</h2><p>2020/07/14 两人</p>
<ul>
<li>Chopped Pepper Fish 剁椒鱼片 4分<ul>
<li>干巴巴的，不好吃，中餐馆做成这样？</li>
</ul>
</li>
</ul>
<h2 id="Nagomi-Sushi"><a href="#Nagomi-Sushi" class="headerlink" title="Nagomi Sushi"></a>Nagomi Sushi</h2><p>2020/07/27 两人</p>
<ul>
<li>California 4分<ul>
<li>居然是蟹足棒…</li>
</ul>
</li>
<li>Special California 6分<ul>
<li>蟹肉…很一般 </li>
</ul>
</li>
<li>Shrimp Tempura 5分<ul>
<li>没有虾尾，甚至没有吃出脆脆的感觉 </li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/kt1bKOU.jpg" style="zoom:40%;" />

<h2 id="Slurping-Turtle"><a href="#Slurping-Turtle" class="headerlink" title="Slurping Turtle"></a>Slurping Turtle</h2><p>2020/07/30 三人</p>
<ul>
<li>Duck Fat Fried Chicken 8分<ul>
<li>很脆，沾千岛酱好吃的！</li>
</ul>
</li>
<li>Takoyaki 6分<ul>
<li>无功无过</li>
</ul>
</li>
<li>Classic Tokyo Shoyu 6分<ul>
<li>有点咸，不过肉和蛋还不错</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/3JtfFhN.jpg" style="zoom:15%;" />

<h2 id="Tomukun-BBQ"><a href="#Tomukun-BBQ" class="headerlink" title="Tomukun BBQ"></a>Tomukun BBQ</h2><p>2020/07/22 四人</p>
<ul>
<li>海鲜饼 Seafood Pancake 7分<ul>
<li>还不错，味道比较正 </li>
</ul>
</li>
<li>骨头汤 * 2 Galbi Tang 7分<ul>
<li>汤不算太浓，有点咸，滋味有一些</li>
<li>没吃到肉，不知如何</li>
</ul>
</li>
<li>海鲜豆腐汤 Seafood Soondubu 8分<ul>
<li>有点辣，海鲜挺足的，挺好。</li>
</ul>
</li>
<li>韩式牛肉饭 Bulgogi 5分<ul>
<li>中规中矩吧</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/0p2AV7J.jpg" style="zoom:17%;" />



<h1 id="麦迪逊"><a href="#麦迪逊" class="headerlink" title="麦迪逊"></a>麦迪逊</h1><h2 id="Sol’s-on-the-square"><a href="#Sol’s-on-the-square" class="headerlink" title="Sol’s on the square"></a>Sol’s on the square</h2><p>2020/08/17 三人</p>
<ul>
<li>BudaeJigae 部队锅 NA<ul>
<li>没咋吃到…对部队锅不是很感兴趣</li>
</ul>
</li>
<li>Egg Roll 7分<ul>
<li>嘿，这春卷还不错，搞得脆脆的</li>
</ul>
</li>
<li>Gyeran Jjim 6分<ul>
<li>鸡蛋糕还行，中规中矩。加料丰富，味道还行，不够滑嫩</li>
</ul>
</li>
<li>Soondubu Jjigae 5分<ul>
<li>不够咸，海鲜不够多，味道感觉没出来</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
        <category>餐馆</category>
      </categories>
  </entry>
  <entry>
    <title>圆圈正义</title>
    <url>/2020/07/24/%E5%9C%86%E5%9C%88%E6%AD%A3%E4%B9%89/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>《圆圈正义》一书共收录作者的49篇随笔文章,分为“圆圈正义”“何谓榜样”“道德谴责的打开方式”“身负权力 各自珍重”“法律人的理智和多数人的情感”“生命的尊严”“心怀永恒 活在当下”七大部分，作者在本书中运用特有的坦诚、自省而尖锐的笔调，探讨了法律、正义、道德、权力的理念与现实、分析了如张扣扣案、莫某纵火案等社会热点案件、分享了自身求学经验和对人生的思考。本书不仅启蒙读者法律意识和法治观念，更在于帮助读者理解法律背后更深层次的价值基础。</p>
<a id="more"></a>



<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><h3 id="代序-法律人的热点写作"><a href="#代序-法律人的热点写作" class="headerlink" title="代序: 法律人的热点写作"></a>代序: 法律人的热点写作</h3><blockquote>
<p>柏拉图在《理想国》中就告诉人们,正义不仅本身值得追求,其结果也往往合乎欲求。一种正当的技艺不仅有其独特的追求,也能带来附随的好处。正如医生要追求医术高明、妙手回春,而这种追求同时也会带来良好的声誉与可观的收入,这没有什么不道德。但如果医生只是追名逐利,为了名利可以放弃医疗职业本身的追求,那么医生也就不再是医生,他放弃了医术这种特定的技艺。柏拉图以此来论证从政为官也是一种独特的技艺,做官不能只是为了追逐自己的利益,否则就不再是一种技艺。</p>
</blockquote>
<ul>
<li>霍。感觉有点意思，并不是涉及利益就是污秽的，而是当你放弃了技艺的那一刻。</li>
</ul>
<blockquote>
<p>人们常说“但行好事,莫问前程”,通常的情况是,为了好事去努力,也就有可能得到所附随的前程。但如果“只为前程,无所谓好事”,很可能既无好事,又无前程。</p>
</blockquote>
<blockquote>
<p>《纳尼亚传奇》的作者刘易斯也提醒我们,行为有自然结果和非自然结果,追逐自然结果非常道德,而<strong>如果追逐的是非自然结果,那就非常的不道德。</strong>因为爱情所以想要结婚,这非常道德,因为结婚是爱情的自然结果。但如果因为对方有钱,所以想要结婚,这就不道德,因为<strong>金钱并非爱情的自然结果。</strong></p>
<p>因此,写作带来名声,没有什么不道德,但名声只是写作的附随结果,而非自然结果,不能为了名声而去写作,否则不仅不道德,也使得写作不再成为一种独特的技艺。</p>
</blockquote>
<blockquote>
<p>很多人喜欢用康德的名言“人是目的,而不是手段”来谴责对他人的利用。但是,这种引用经常是一种以讹传讹的情绪化误读。康德的原话是:“在这个目的秩序中,人就是自在的目的本身,亦即他永远不能被某个人单纯作为手段而不是在此同时自身又是目的,所以在我们人格中的人性对我们来说本身必定是神圣的……”</p>
<p>可见,<strong>康德从来没有主张过人不能是他人的手段,他只是说人不能“单纯”作为手段。</strong>万事互为效力,任何人都可以既是他人的手段,又是自身的目的。如果人只是手段,这会走向毫不掩饰的极权主义。<strong>如果人只是目的,那也会走向过于放纵的个人主义。</strong></p>
</blockquote>
<blockquote>
<p>大致说来,剥削是一种忽视他人尊严的不道德利用。一种利用是否属于剥削,可以从后果和动机两个方面进行判断。</p>
</blockquote>
<blockquote>
<p>从后果的角度,如果一种对他人不幸处境或人性弱点的利用,没有传递任何积极正面的道德价值,那它就属于不道德的剥削。<strong>这种剥削即便得到了被剥削者的同意,在道德上也值得谴责,严重的甚至可以犯罪论处。</strong>如组织卖淫行为,和强迫卖淫不同,在组织卖淫的情况下,卖淫者往往是自愿的,组织者利用了卖淫者经济上的不利地位或者道德上的缺陷。如果不考虑道德价值,组织卖淫这种行为对卖淫者、嫖客、组织者都是有利的,如果允许国家征税,甚至会造成“四方共赢”的局面。但这种利用行为没有任何积极正面道德价值,因此属于剥削,值得谴责,甚至可以犯罪论处。</p>
</blockquote>
<ul>
<li>霍，组织卖淫。</li>
</ul>
<blockquote>
<p>在电影《象人》中,有人指责医生出于研究的目的治疗“象人”,浪费医疗资源,沽名钓誉,卑鄙可耻。医生不断地追问自己的内心“我真的只是在利用他吗?”医生的自省是高贵的,而他人的论断指责则是卑劣的。</p>
</blockquote>
<blockquote>
<p>我们很容易对他人的动机作出恶意的评价,严于律他、宽于律己是人之本性。批评他人可以让我们轻易地掩盖自己的道德丑陋,从容地逃避自己的道德责任。真正畸形的不是“象人”而是人心。因此,每当想对他人的动机作出恶意的评价,<strong>我们要先有一个代入</strong>——去想一想在类似的情况下,我们的行为举止是否会比他人更高尚。</p>
</blockquote>
<blockquote>
<p>理查德·巴克斯特说:我们时常妒忌比我们地位高的人,藐视地位不及我们的人;垂涎别人的名望、财富,或者傲慢、冷酷地看待别人的贫寒窘迫。看到外形姣好的人,则诱发我们的情欲;看见有残疾的人,就引发我们的鄙夷之心……我们自己才是自己最大的网罗。</p>
</blockquote>
<blockquote>
<p>有朋友提醒我,从事文字写作要把自己看成一支铅笔。最重要的是知道自己为何写作,要知道铅笔在谁的手中。对于铅笔而言,最重要的是笔芯,我们要保守自己的心甚于保守其他一切。<strong>良心是唯一不能从众之事。写作不是为权力的垂青,不是为获得群众的掌声,而是向自己的良心负责。</strong></p>
<p>对于铅笔而言,字迹是可被擦去的。我们的观点可能有错,需要随时被纠正。</p>
<p>对于铅笔而言,它是有限的,有一天它会写到尽头。作者也许会发现自己所写的其实没有太大价值,我们要接受自己的有限性。</p>
</blockquote>
<ul>
<li>哇，这比喻真好。</li>
</ul>
<h3 id="做一个勇敢的法律人"><a href="#做一个勇敢的法律人" class="headerlink" title="做一个勇敢的法律人"></a>做一个勇敢的法律人</h3><blockquote>
<p>我一直想做一个勇敢的人,所以我一直在寻找勇敢的正当化根据。</p>
</blockquote>
<ul>
<li>真相了。没有勇气的人，就是需要一个根据才能建立起自己的「勇气」</li>
</ul>
<blockquote>
<p>边沁认为,幸福没有高下之分,口腹之欲和心智之养没有区别。如果人只<strong>根据自己的经验</strong>计算利害得失,不可避免地会走向庸俗。这种功利观<strong>一定会让人追求现实的快乐,追逐眼前的利益</strong>,在勇敢和懦弱之间,后者往往是最佳的选择</p>
<p>但是穆勒却认为,幸福是有高下之分的。“做一个不满足的人,胜于做一只满足的猪;做不满足的苏格拉底,胜于做一个满足的傻瓜。如果那个傻瓜或猪有不同的看法,那是因为他们只知道自己那个方面的问题,而相比较的另一方即苏格拉底之类的人,则对双方的问题都很了解。”</p>
<p>穆勒的说法比边沁的观点应该更加合理。如果你阅读过低俗小说和高雅书籍,虽然两者都能给你带来快乐,但是如果你要慎重地选择其中一本书送给子孙后代,估计大部分人会选择后者。大部分人还是希望自己以及后代做一个高尚的人,能够享受高级的快乐。</p>
</blockquote>
<ul>
<li>问题发生了变化，因为子孙后代，代表了「永恒」。</li>
</ul>
<blockquote>
<p>如果幸福没有高尚和庸俗之别,那么一切都会变得平庸,劣币终将驱逐良币。事实上,人类语言中存在“高尚”与“庸俗”这组反义词,本身就告诉我们人类追求的幸福是有高下之分的。</p>
<p>那么,如何区分高级和低级的快乐呢?穆勒告诉我们,<strong>越是能够体现人的尊严的快乐就是越高级的快乐。</strong></p>
</blockquote>
<h3 id="在自恋中攀登仇恨的高峰"><a href="#在自恋中攀登仇恨的高峰" class="headerlink" title="在自恋中攀登仇恨的高峰"></a>在自恋中攀登仇恨的高峰</h3><blockquote>
<p>人的本性喜好拉帮结派,甚至不惜“互拉仇恨”,其中的根源在于人的自恋。</p>
<p>当生命中缺乏一个终极的敬仰对象,人就不可避免地会把自己置于生命中最重要的地位,形成无法抑制的自恋。</p>
</blockquote>
<ul>
<li>…恍然大悟。这也是为什么要把耶稣放在生命的中心。</li>
</ul>
<blockquote>
<p>自恋让人很容易发现并放大他人的问题,但却很少会反思自己也犯着相同的问题。“为什么看见你弟兄眼中有刺,却不想自己眼中有梁木呢?”我们很容易记起近代史的屈辱与伤害,但很少愿意思考我们曾经对外族,甚至是同胞犯下的罪过。</p>
<p>自恋让人执着于对他人的利用,所有的人际交往都只是在满足自我的需要。如果他人不再有利用价值,人的“爱”也就会消失殆尽。因此,我们很容易记住对他人的恩惠,却很容易忘记他人对自己的恩情。</p>
</blockquote>
<blockquote>
<p>爱不是爱抽象的概念,而是爱具体的人;<strong>不是爱“人类”,而是爱“人”。</strong>有许多伟大的知识分子都非常爱人类,但他们却很难爱真正具体的人。有一个叫卢梭的人,曾经写过《论人类不平等的起源》,据说他一想到人类的苦难就会伤心落泪。但他却把自己的五个孩子送往孤儿院。他太忙了,忙着爱人类,而没有时间去爱具体的人。</p>
<p>爱“人类”,却不爱具体的人是很多文人的通病。<strong>人类是抽象的,并无具体的对象,无须投入真心,收放自如,还可以为自己赢得道德上的优越感,但具体的人总是有那么多的问题,总是那么的不可爱。</strong>爱是要付出代价、恒久忍耐的。真正的爱永远是对具体个人的爱。</p>
</blockquote>
<ul>
<li>我的天…醍醐灌顶！</li>
</ul>
<blockquote>
<p>可爱之人,人皆爱之,这种爱不过是自恋的一种表现形式。你欣赏他人的可爱之处,你不过是把对自己的爱投放在他人的身上。然而,<strong>只有当你在不可爱之人中看到值得爱的地方,你才能慢慢地走出自恋。</strong></p>
</blockquote>
<h3 id="圆圈正义与安提戈涅"><a href="#圆圈正义与安提戈涅" class="headerlink" title="圆圈正义与安提戈涅"></a>圆圈正义与安提戈涅</h3><blockquote>
<p>保守主义先驱伯克告诫我们:“伪善最喜欢崇高的思辨,因为它从不打算跨越到思辨的界限之外,它无须付出任何代价就能把自己装点得庄严高尚。”</p>
</blockquote>
<h3 id="从“刀把子”到“双刃剑”"><a href="#从“刀把子”到“双刃剑”" class="headerlink" title="从“刀把子”到“双刃剑”"></a>从“刀把子”到“双刃剑”</h3><blockquote>
<p>“欲加之罪,何患无辞”,这是用血和泪换来的经验总结。岳飞的冤屈告诉我们,比犯罪更可怕的是不受限制的国家权力。在所有的国家权力中,刑罚最为可怕,它直接针对公民的人身、财产和自由,甚至生命,如果这种权力腐化滥用,后果不堪设想。如培根所言,<strong>一次犯罪不过是污染了水流,而一次不公正的司法却是污染的水源。</strong>相比随时可能被滥用的刑罚权,犯罪对社会的危害其实微不足道。</p>
</blockquote>
<blockquote>
<p>只要将刑法作为工具,权力的滥用也就不可避免,人治可以打着法治的名义大行其道。<strong>任何事物一旦成为工具,就必须为使用者服务</strong>,当工具可以满足使用者的目的时,工具可以获得各种美赞,而当工具妨碍了使用者实现目的,自然也就会弃之如敝屣。无论将法律定义为何种工具,它都无法避免为人任意裁剪取舍的命运。</p>
</blockquote>
<blockquote>
<p>古话说:“刑不可知,威不可测,则民畏上也。”如果刑法的使命只是打击犯罪,其实没有必要制定成文刑法。正如有学者所指出的那样:一个国家对付犯罪并不需要刑事法律,没有刑法并不妨碍国家对犯罪的有效打击和镇压,而且没有立法的犯罪打击可能是更加灵活、有效、及时与便利的。如果从这个角度讲,刑法本身是多余和伪善的,它除了在宣传上与标榜上有美化国家权力的作用外,主要是束缚国家机器面对犯罪的反应速度与灵敏度。</p>
</blockquote>
<ul>
<li>这个思路新颖，原来刑法是为了保护大众的，防止权力者滥用。</li>
</ul>
<blockquote>
<p>在法治社会,刑法不再是“刀把子”,而是“双刃剑”:一刃针对犯罪,一刃针对国家权力。</p>
</blockquote>
<blockquote>
<p>正是基于刑法的双重使命,1997年我国刑法规定了罪刑法定原则——法无明文规定不为罪,法无明文规定不处罚。</p>
</blockquote>
<h3 id="天生犯罪人"><a href="#天生犯罪人" class="headerlink" title="天生犯罪人"></a>天生犯罪人</h3><blockquote>
<p>优生学兴起于19世纪末20世纪初期,优生优育的初衷听起来无限美好,但是这一思想很快就被借用并扩大化,将其用于解决困扰城市的惊人的社会问题——贫穷、犯罪和暴力。优生学家不再谴责经济和社会体制本身,而是谴责那些不幸的人,认为他们是天生没有能力适应现代社会的人。因此,优生学被可悲地打上了遗传学的烙印,也成为“基因的奴隶”。优生学包括两种倾向,一是积极地改良人类品种,二是消极地淘汰劣等人种。于是,我们看到,从被动优生到种族灭绝,仅一步之遥。</p>
<p>受优生学运动影响,美国许多州通过强制性绝育的法律,规定政府有权对罪犯、白痴、低能儿,或者州专家委员会批准的其他人实施强制性绝育手术。直到1942年,联邦最高法院在Skinnerv.Oklahoma案中(316U.S.535,1942)才宣告绝育法违宪。</p>
</blockquote>
<h3 id="法治的妥协"><a href="#法治的妥协" class="headerlink" title="法治的妥协"></a>法治的妥协</h3><blockquote>
<p>对中国的司法制度有了解的人都知道,法院一旦作出无罪判决,将会直接导致公安机关、检察机关承担一定的国家赔偿责任,甚至就连具体办案的警察、检察官也会受到“错案责任追究”。甚至,在司法机关内部还存在着一些成文或不成文的绩效考核规定,对刑事破案率、批捕率、无罪判决率、撤诉率等进行考核。检察机关往往把无罪判决率作为案件质量考核的硬指标,出现无罪判决,责任人要承担不利后果。一些时候,当事人权利与司法机关绩效考核发生了本不该有的联系。</p>
</blockquote>
<ul>
<li>好吧…</li>
</ul>
<blockquote>
<p>不得不说的是,一旦进入司法体系,涉案的当事人无论有罪还是无罪都会感到恐惧。是什么样的力量使得当事人如此的恐惧。如果司法是一种让人莫名恐惧的力量,那这一定是法家的幽灵,而绝非法治的精神。</p>
</blockquote>
<blockquote>
<p>每当遇到一个坚持无罪的当事人,即便内心认同他的辩解,但我依然会让他慎重考虑认罪换轻判的建议。如果对方仍然坚持自己的观点,我自然会尽力用平生所学不负所托。我不知道这种妥协是不是在损害法治的尊严。但是,我深知我没有资格用他人的勇敢去换取我所期待的法治进步。<strong>无论坚持多么崇高的抽象理念,我们都不要在自己的坚守上附加不着边际的价值,并让他人成为我们信念的牺牲品。</strong>我们只能期待自己有勇气去践行我们的法治信念。</p>
</blockquote>
<h3 id="燕园旧训-薪火相传"><a href="#燕园旧训-薪火相传" class="headerlink" title="燕园旧训 薪火相传"></a>燕园旧训 薪火相传</h3><blockquote>
<p>第一次世界大战期间,约有600万英国成年男性奔赴战场,其死亡率为12.5%。然而,参加作战的英国贵族(包括上院贵族和从男爵)的死亡率高达20%。在整个战争中,共有20名上院贵族战死,49名上院贵族第一顺位继承人战死。据说英国著名贵族学校——伊顿公学的参战贵族子弟伤亡率高达45%。有3家英国上院贵族在战争中完全灭亡,继承人全部战死。</p>
<p>真正的贵族不是财产上的富足,而是精神上的高贵,知道自己肩负的责任。</p>
<p>这样,即便一贫如洗,依然是贵族。</p>
</blockquote>
<blockquote>
<p>大学之大,不在大楼,不在大师,更不在大官,而在伟大的观念。</p>
</blockquote>
<h3 id="《枪支批复》的情理法"><a href="#《枪支批复》的情理法" class="headerlink" title="《枪支批复》的情理法"></a>《枪支批复》的情理法</h3><blockquote>
<p>客观归罪是法治不发达的产物。人类早期的刑法充满原始复仇的自然正义观念,基本上是根据客观损害结果来决定对行为人的处罚,丝毫不考虑主观罪过。这种客观归罪甚至会迁怒到无生命的物质。相传公元前480年,波斯王薛西斯(Xerxes)大举进攻希腊,大军行至赫勒斯邦海峡(今称达达尼尔海峡),薛西斯下令架桥。两座索桥很快被架好,不料突然狂风大作,把桥吹断。薛西斯大怒,不但杀掉了造桥工匠,还命令把铁索扔进海里,说是要把大海锁住,<strong>同时命人用鞭子痛击海水300下</strong>,惩戒大海阻止他前进的罪过。类似举动在人们的婴幼儿时期也常有发生,当蹒跚学步的孩子跌倒在地,他首先想到的是地板的错,如果大人也象征性地打一下地板,孩子就会转哭为笑。</p>
<p>我国当前的刑法既非客观主义,也非主观主义,而是主客观相统一,认定犯罪,既要考虑客观上的行为,也要考虑主观上的罪过。</p>
</blockquote>
<blockquote>
<p>日本有过类似判例,虽然法律对某种概念有过规定,但行为人却对事物的概念归属产生了错误,如著名的“狸、貉事件”和“鼹鼠事件”。在日本的《狩猎法》中,狸和鼹鼠都是被禁止捕获的保护动物,但行为人却对某种动物的归属产生了错误认识。在“狸、貉事件”中,行为人误认为当地通称为“貉”的动物与狸不同而加以捕获,但当地人大多都持这种见解。而在“鼹鼠事件”中,行为人不知道当地称为“貘玛”的动物就是“鼹鼠”,而当地人一般都知道“貘玛”就是“鼹鼠”。在第一个案件中,被告被判没有故意,不成立犯罪。而在第二个案件中,法官却认为被告成立故意犯罪。显然,这两个案件中的认识错误都是归类性错误,应当根据社会一般观念进行判断。在第一个案件中,行为人的认识没有偏离社会一般观念,故不成立故意,而在第二个案件中,行为人的认识有违社会一般观念,故不能排除犯罪故意的成立。</p>
<p>在我国司法实践中,归类性错误比比皆是,如购买宠物禽鸟,但却不知此鸟是法律意义上的珍稀鸟类。再如,随手采摘葡萄,不料此葡萄为科研用葡萄,价值连城,卖肾都赔不起。对此类案件,都应该和对枪支的认识错误一样,看社会一般人能否出现误判,如果你我普罗大众都会出现认识错误,那自然就可否定犯罪的故意。</p>
</blockquote>
<ul>
<li>有点意思，人和周围的社会是分不开的</li>
</ul>
<blockquote>
<p>斯蒂芬说:在任何情况下,立法都要适应一国当时的道德水准。如果社会没有毫不含糊地普遍谴责某事,那么你不可能对它进行惩罚,不然必会“引起严重的虚伪和公愤”。<strong>公正的法律惩罚必须取得在道德上占压倒优势的多数的支持</strong>,因为“法律不可能比它的民族更优秀,尽管它能够随着标准的提升而日趋严谨”。</p>
</blockquote>
<h3 id="何谓榜样"><a href="#何谓榜样" class="headerlink" title="何谓榜样"></a>何谓榜样</h3><blockquote>
<p>无论是作为人们效仿的“榜样”,还是印刷钞票的“版样”,它们的性质都是一样的,都具有<strong>可复制性</strong>,可以批量生产。如果一个榜样,不能复制,那他只可能是天才或者奇迹。</p>
</blockquote>
<ul>
<li>霍，榜样的意义就在于可复制。</li>
</ul>
<blockquote>
<p>让幸福感持续的唯一方法就是以感恩的心、谦卑的心接受一切成功与失败。</p>
</blockquote>
<ul>
<li>想起了宗儒对抗虚荣的办法，接纳感谢和赞美，也要接纳批评。</li>
</ul>
<h3 id="伟大的梦想依然在心中"><a href="#伟大的梦想依然在心中" class="headerlink" title="伟大的梦想依然在心中"></a>伟大的梦想依然在心中</h3><blockquote>
<p>关于好撒玛利亚人的故事</p>
<p>因为祭司和利未人首先想到的问题是:“如果我停下救这个人,我会怎么样?”</p>
<p>但是好撒玛利亚人经过的时候,他反过来问:“如果我不停下救这个人,他会怎么样?”</p>
</blockquote>
<h3 id="师生之道"><a href="#师生之道" class="headerlink" title="师生之道"></a>师生之道</h3><blockquote>
<p>让我意识到自己所得到的一切都并不是自己所配的,白白得来的祝福也应白白地传给他人。</p>
</blockquote>
<h3 id="不要轻易向他人抡起道德的杀威棒"><a href="#不要轻易向他人抡起道德的杀威棒" class="headerlink" title="不要轻易向他人抡起道德的杀威棒"></a>不要轻易向他人抡起道德的杀威棒</h3><blockquote>
<p>但是,动辄站在道德制高点教训他人的人,往往自己是败类中的败类,越高调往往越败坏。只要对历史有基本的熟悉,就不难明白这个道理。</p>
<p>因此,<strong>道德的使命首先是自律,而非他律</strong>,道德谴责的第一步永远是对自己发出的,我们必须先质问自己,在相似的情景下,我们会如何行为?</p>
<p>社会乱象,根源何在?《伦敦日报》就此议题向作家切斯特顿征稿。</p>
<p>他的回复只有两个字:“在我”。</p>
</blockquote>
<blockquote>
<p>老话说,一个手指指向他人,四只手指却指向自己。</p>
<p>我并不是说人们不能够进行道德谴责,而是说当我们进行道德谴责的时候,一定不要把自己先排除在道德判断之外。</p>
<p>道德判断,永远要先己后人。</p>
</blockquote>
<h3 id="道德谴责的打开方式"><a href="#道德谴责的打开方式" class="headerlink" title="道德谴责的打开方式"></a>道德谴责的打开方式</h3><blockquote>
<p>有人说,没有什么是绝对的对,也没有什么是绝对的错,所以我们没有资格对他人说三道四。这种“相对主义”的观点是错误的。相对主义告诉人们没有绝对的对错,存在的就是合理的。<strong>但这个世界一切的败坏,根源都是相对主义。</strong>相对主义让人完全失去了批判罪恶的能力。如果没有绝对对错,那么吃人也就只是一种口味问题,杀人也不过是一种娱乐方式。</p>
</blockquote>
<blockquote>
<p>很多时候,当我们在他人身上发现了自己也有的缺点,我们会竭力地批评论断。一方面,在批评他人的过程中,我们可以获得自以为是的快感,而这种快感会让我们根本无须为自己的过错悔改。另一方面,越是严厉批评,越是可以在众人面前掩盖我们自己同样的罪行。所以,贪腐分子往往对贪腐的指责是最严厉的,越是淫乱的人越是习惯于指责他人淫乱。</p>
</blockquote>
<blockquote>
<p>刑罚是国家最严厉的惩罚措施,但是它依然要在惩罚的同时让罪犯改过自新。因此,刑罚不仅不能亵渎罪犯作为人的尊严,反而要让罪犯重新体会到人的尊严,邀请“理性人”重新住进自己的心中。甚至死刑也是对罪犯的尊重,用黑格尔的话来说:“刑法被包含着犯人自己的法,所以处罚他,正是尊敬他是理性的存在。”杀人偿命,天经地义,杀人犯知道这种律令,却依然实施犯罪,那么如果不处死他,就是对他的不尊重。(“别人杀人都判死刑,为什么我杀人不判死刑?瞧不起我吗?把我当精神病人吗?”)在黑格尔看来,如果一个杀人犯能够勇敢地去接受死刑,并因为死刑而痛悔,那么他就重新找回自己的尊严。相反,如果他选择“好死不如赖活着”,则是对其尊严最大的亵渎。</p>
</blockquote>
<ul>
<li>霍 这逻辑</li>
</ul>
<blockquote>
<p>因此,所有的道德谴责都不应该随意侮辱他人的人格,诸如“人渣”“狗男女”“禽兽”这种情绪化的表达在亵渎他人的同时也侮辱了自己。同时,<strong>将他人在道德上彻底“批臭批死”也从此堵住了他人改过自新的可能。</strong></p>
</blockquote>
<blockquote>
<p>“当美国人民任其激情发作,陶醉于理想而忘形时,会感到法学家对他们施有一种无形的约束,使他们冷静和安定下来。法学家秘而不宣地用他们的贵族习性去对抗民主的本能,用他们对古老事物的崇敬去对抗民主对新鲜事物的热爱,用他们的谨慎观点去对抗民主的好大喜功,用他们对规范的爱好去对抗民主对制度的轻视,用他们处事沉着的习惯去对抗民主的急躁。”</p>
</blockquote>
<h3 id="律师为什么喜欢为“坏人”做辩护"><a href="#律师为什么喜欢为“坏人”做辩护" class="headerlink" title="律师为什么喜欢为“坏人”做辩护"></a>律师为什么喜欢为“坏人”做辩护</h3><blockquote>
<p>首先,律师必须在法律范围内维护当事人的合法权益。律师与其说是在捍卫当事人的利益,不如说是在通过捍卫当事人的利益维护法律的尊严。正如亚伯拉罕对上帝的质疑不是为了攻讦上帝的缺失,而是向上帝申明确保无辜者不受冤枉才能保证上帝惩罚的正当性。</p>
</blockquote>
<h3 id="大刀砍向同胞的第一步是对异族的仇恨"><a href="#大刀砍向同胞的第一步是对异族的仇恨" class="headerlink" title="大刀砍向同胞的第一步是对异族的仇恨"></a>大刀砍向同胞的第一步是对异族的仇恨</h3><blockquote>
<p>这种基于国别和民族的“同仇敌忾”的人总有一天也会将仇恨对准同胞,向着本国的民众大开杀戒。</p>
<p>当我们人为地将人区分为本国人、外国人,我们也就不可避免地会把本国人区分为富人、穷人,显贵、平民,本地人、外地人,城里人、乡下人,任何一个小群体又会形成一种新的“同仇敌忾”。</p>
</blockquote>
<ul>
<li>站队行为的开始。</li>
</ul>
<blockquote>
<p>到了大学,我们组织湖南老乡会。老乡们聚在一起,不断自夸身为湖南人的骄傲,批评外省人的粗鄙。直到有一天,老乡会居然没有叫我,我非常失落。后来才知道原来他们开的是长沙老乡会,我不是长沙人,所以没有资格参加。但是一位长沙同学居然也没有受邀,我感到非常奇怪。后来他郁闷地告诉我,“他们开的是长沙市的老乡会,我是长沙县的,所以没有资格。”</p>
<p>这一刻,我才知道我的偏见有多么的可笑和愚蠢!</p>
</blockquote>
<h3 id="城管抽梯-何罪之有和该当何罪"><a href="#城管抽梯-何罪之有和该当何罪" class="headerlink" title="城管抽梯: 何罪之有和该当何罪?"></a>城管抽梯: 何罪之有和该当何罪?</h3><blockquote>
<p>惩罚的根据是报应,而不是预防,是对已然之罪的报复,而不是对未然之罪的防控。如只以预防作为惩罚的导向,那么为了威慑犯罪,司法机关就可随意抓一个“替罪羊”顶罪,以树立司法机关凡案必破、法网严密的光辉形象,威慑普罗大众。但是,这显然是错误的,违反了无罪不罚这个最基本的常识。</p>
</blockquote>
<blockquote>
<p>张三叫李四来吃饭,结果李四在路上遭遇车祸。在经验法则中,李四是被车撞死的,而不是被张三杀害的,因此张三的邀请与李四的死亡充其量只有事实上的因果关系,而不存在法律上的因果关系。事实上,任何如张三一样的人也只会为此事略感愧疚,但不会愧疚到去公安机关投案自首的程度。</p>
</blockquote>
<blockquote>
<p>如甲故意伤害乙,乙在被送往医院过程中发生车祸身死。伤害行为(前行为)本来不会直接导致死亡,但由于介入因素(路上的车祸)使得前行为与死亡结果发生了联系。在这种情况下,前行为与危害结果之间是否还存在刑法上的因果关系呢?这就要从一般人的常识来看介入因素与前行为是否具有伴随关系,如果前行为会高概率导致介入因素,而介入因素又引起了最后的结果,那么前行为就与结果有刑法上的因果关系。再如,甲在张三身上泼油点火,张三为了灭火跳入深井而死,死亡结果自然可以归责于甲的点火行为。但若介入因素的出现与前行为并无伴随关系,那么就不能将结果归责于前行为。又如,张三被甲泼油点火,痛苦万分,李四为免张三之苦,将其击毙,这种介入因素就太过异常,与前面的点火行为没有伴随关系。</p>
</blockquote>
<ul>
<li>哈哈哈</li>
</ul>
<blockquote>
<p>鲁迅曾说:“勇者愤怒,抽刃向更强者;怯者愤怒,却抽刃向更弱者。”如果我们的法律不能约束人性中下坠的常态,严惩滥权之举,那么那些被滥用的权力永远无法学会尊重普通民众。</p>
</blockquote>
<h3 id="身负权力-各自珍重"><a href="#身负权力-各自珍重" class="headerlink" title="身负权力 各自珍重"></a>身负权力 各自珍重</h3><blockquote>
<p>在任何行业,如果人们信奉强者为大,也就不可能真正遵守规则,因为规则只对弱者有效,强者永远跳出规则之外。</p>
</blockquote>
<h3 id="规范执法-让雷洋案不再继续"><a href="#规范执法-让雷洋案不再继续" class="headerlink" title="规范执法, 让雷洋案不再继续"></a>规范执法, 让雷洋案不再继续</h3><blockquote>
<p>运动式执法犹如吸毒,一旦上瘾,就很难戒除。当运动的发动者看到执法在短期内的巨大成就,也就很容易忽视执法中的缺陷,更难想到这将会对法治带来何种摧毁性的后果。当执法人员习惯了运动式执法的简单粗暴,也就很难再培养起对规则的尊重和敬畏。</p>
</blockquote>
<h3 id="刑法规制网络水军应慎重"><a href="#刑法规制网络水军应慎重" class="headerlink" title="刑法规制网络水军应慎重"></a>刑法规制网络水军应慎重</h3><blockquote>
<p>总之,没有必要因为网络水军带来一些不良影响就全然禁止,切勿把洗澡水和孩子一起泼掉。</p>
</blockquote>
<ul>
<li>哈哈哈</li>
</ul>
<h3 id="思想、言论和惩罚的边界"><a href="#思想、言论和惩罚的边界" class="headerlink" title="思想、言论和惩罚的边界"></a>思想、言论和惩罚的边界</h3><blockquote>
<p>鲁定公十四年(公元前496年),孔子时来运转,受聘为鲁国最高司法官员(大司寇)并代理宰相一职(摄相事),上台仅七天,就诛杀了当时的著名学者少正卯。据荀子与东汉王充考证,少正卯和孔子一样,都系当时名重一方的著名学者,但两人学术观念迥然有别,两人同时都在讲学,而且少正卯的授课方式可能更受学生欢迎,以致孔子的学生也跑去旁听,孔子的课堂一度出现三满三空的现象。最绝的一次,课堂上只剩下颜渊一个人,其他人都跑了。孔子掌权之后,第一件事情就是拿这位学术对手开刀。孔子给少正卯罗织了五大罪名:其一,心达而险,为人通达但居心叵测;其二,行辟而坚,行为乖僻但意志坚强;其三,言伪而辩,观点不对但却善于狡辩;其四,记丑而博,宣扬歪理邪说但却非常博学;其五,顺非而泽,是顺从异端且大力赞赏。孔子说,这五种罪恶,有其中一种就应被诛杀,而少正卯五条全占齐了,是小人的奸雄,不杀不足以平民愤。最后,孔子用《诗经》的话总结道:“忧心悄悄,愠于群小”——宵小成群,让人担忧啦!</p>
</blockquote>
<ul>
<li>What？这孔子…</li>
</ul>
<blockquote>
<p>作为一个思想家,其第一个义务就是随其智力所知而不论它会导致什么结论……不是单单为着或者主要为着形成伟大的思想家才需要思想自由。相反<strong>为着使一般人都能获致他们所能达到的精神体量</strong>,思想自由是同样或者甚至更加必不可少。在精神奴役的一般气氛中,曾经有过而且也会再有伟大的思想家。可是在那种气氛中,从来没有而且永不会有一种智力活跃的人民。</p>
</blockquote>
<h3 id="莫某纵火与死刑适用"><a href="#莫某纵火与死刑适用" class="headerlink" title="莫某纵火与死刑适用"></a>莫某纵火与死刑适用</h3><blockquote>
<p>多年前,我曾反对死刑,但现在我的观点早已发生变化。那种忽视公义、滥施恩情的人道主义有着太多的伪善,他们经常会是为了假想的将来而忽视现在的利益,为了抽象的人类无视具体人的悲苦。对于那些极度邪恶的杀人重案,如果不处以极刑,如何能够抚慰仍存于世上之人的泪水?</p>
</blockquote>
<blockquote>
<p>至于邪恶,那更是与人类社会如影随形。科技的发展从来没有遏制邪恶,反而使得邪恶拥有更大的破坏力量。如果对历史有着基本的了解,今天的人类也无法夸口我们现今的邪恶水平会远低于千百年前。</p>
</blockquote>
<h3 id="法律人的理智和多数人的情感"><a href="#法律人的理智和多数人的情感" class="headerlink" title="法律人的理智和多数人的情感"></a>法律人的理智和多数人的情感</h3><blockquote>
<p>其次,规范评价可以摒弃多数人的偏见,将民众的情感引向至善。法律追求公平和正义,法律要做黑暗世界的明灯,让人心向善。比如,虚构他人遭受强暴并感染艾滋病是否构成诽谤罪?在事实上,这种诽谤必然会导致社会评价降低,但从规范角度来看,如果法律照搬事实的名誉概念,那法律就是强化社会对强奸受害人以及艾滋病患者的歧视。再如,在难以察觉的情况下冒充女方的男朋友与其发生性行为是否构成强奸?换言之,这种欺骗是否是实质性欺骗[16],女方是否必然会处分性权利。在当前的社会,非婚性行为虽然并不罕见,但如果法律认为这属于实质性欺骗,从而构成强奸,那显然是确认了非婚性行为的合理性。即便多数人认为非婚性行为司空见惯,法律也不能与这种偏见同流合污,法律永远要坚守一些基本的价值。</p>
</blockquote>
<ul>
<li>这两个例子有点东西…</li>
</ul>
<h3 id="性侵犯罪与不同意"><a href="#性侵犯罪与不同意" class="headerlink" title="性侵犯罪与不同意"></a>性侵犯罪与不同意</h3><blockquote>
<p>今天,如果谁告诉孩子们性在婚姻之内才是正当的,婚前性行为、婚外性行为都是不道德的。这种教导很容易被视为古董老套。事实上,我们根本不知道如何对孩子们进行合理的性教育:性是同意就行吗?有爱就能有性吗?只要采取保护措施,双方同意的性就是合理的吗?成年人对此问题很难回答,又如何去教导孩子?正是性观念的混乱,性道德的沦丧,我们无法对孩子们进行有效的性教育,于是干脆避而不谈。未成年人只能从别处获得对性的知识:网络、色情光盘以及朋友们的口耳相传。学校从来不是象牙塔,教书育人的先生们在性放纵的文化中耳濡目染,又有何种力量来抵抗内心的邪恶?</p>
</blockquote>
<ul>
<li>确实…这问题该如何作答？</li>
</ul>
<h3 id="无论多么伟大-终有一天谢幕"><a href="#无论多么伟大-终有一天谢幕" class="headerlink" title="无论多么伟大 终有一天谢幕"></a>无论多么伟大 终有一天谢幕</h3><blockquote>
<p>人在安宁时,总是会不时地想到自己的有限性(死亡、苦难与邪恶),因此我们需要用忙碌来转移对有限性的思考。</p>
</blockquote>
<blockquote>
<p>人无法忍受安宁,因为在安宁时,“我们不是想着现有的悲惨,就是想着可能在威胁我们的悲惨”。人在安宁时,总是会觉得无聊,即使没有任何让人觉得无聊的原因,他也会因为要转移对有限性的思考而觉得无聊。</p>
</blockquote>
<h3 id="人类的观念会崩溃吗"><a href="#人类的观念会崩溃吗" class="headerlink" title="人类的观念会崩溃吗?"></a>人类的观念会崩溃吗?</h3><blockquote>
<p>人类一直都是观念的产物。一种崇高的观念可以将人类高举,一种卑下的观念则会降低人的尊严。</p>
<p>一直以来,哲学家们认为,观念有高下之分。越接近永恒的观念,越是崇高。有人把这种最崇高观念称之为“绝对真理”“本体”或者“共相”,当然,还有更多人把其称之为“道”。</p>
<p>这种崇高的观念可以赋予人尊严,指导人们的生活,让人生活得有意义、有目的、有安全感,它能让人超越暂时的琐碎和有限,在一种更高级的意义上审视自己的日常生活,他更能像石头房子一般帮助人们抵御人生的艰难苦楚。</p>
<p>无论是帝国的兴衰、政权的腐败,还是瘟疫的流行、蛮族的入侵,人的肉体都很容易因之而毁灭,但这种伟大的观念却是万世长存。</p>
<p>站在伟大的观念之上,人越来越感到作为人的高贵与价值。伟大的观念创造伟大的人类。</p>
<p>有一天,一场运动开始了。伟大的人类开始觉得有必要用人自己的理性去审视观念,所有无法通过人类理性检视的观念都应该被抛弃。</p>
<p>他们认为,理性之光可以驱散黑暗,把人们引向光明。</p>
<p>我们知道,那场运动叫作启蒙运动。</p>
</blockquote>
<h3 id="今天-你刷存在感了吗"><a href="#今天-你刷存在感了吗" class="headerlink" title="今天, 你刷存在感了吗?"></a>今天, 你刷存在感了吗?</h3><blockquote>
<p>在克尔凯郭尔看来,人有三个阶段的存在。当然,你也可以把这些阶段看成一种生存方式。</p>
<p>第一个阶段叫作审美阶段,在这种阶段,人沉迷于短暂和当下的事物。感官的需要,欲望和冲动成为人唯一的向导。当然,这种感官上的享受不一定是粗俗的,它也可能表现为对艺术、学术、文学、哲学和宗教的热爱。在审美阶段,人的存在只追求相对的目的,并不关注人们对于绝对的需要。在克尔凯郭尔看来,因为当下的力量不能承担我们渴望永恒的重负,所以<strong>厌倦是不可避免的</strong>。审美阶段的厌倦,导致人深深的绝望,让我们不断更换各种时常翻新的当下“选择”。<strong>喜新厌旧是一种人生常态。</strong></p>
<p>如果跳出了审美阶段,那么人就进入第二个阶段,这个阶段也就是伦理阶段。在这个阶段中,我们开始认为其他人是有价值的,我们尊重他们的权利,并由此承认他们的价值。由于伦理本身是不变的,因此它适用于每一个人。但是,这样一种新的存在也会让人有一种深深的焦灼感。这种焦灼感在于,我们越是意识到普遍规律的命令,越是强烈地意识到我们不能坚持这些命令。在“知道”和“做到”之间,有一个天然的鸿沟。人每天都在立志行善,但总是无法做到。</p>
<p>在克尔凯郭尔看来,一个人真正的存在是进入第三个阶段的存在——能够跨越“知道”与“做到”之间的这个巨大的鸿沟。</p>
</blockquote>
<h3 id="爱要常觉亏欠-客要一味款待"><a href="#爱要常觉亏欠-客要一味款待" class="headerlink" title="爱要常觉亏欠 客要一味款待"></a>爱要常觉亏欠 客要一味款待</h3><blockquote>
<p>卢梭和女仆长期同居后结婚,后者为他生了五个孩子,卢梭把他们都送往了孤儿院。他在《忏悔录》中为自己辩护,说他忙着爱人类,以至于没有时间来关心自己的孩子。所以,这是为什么詹姆斯·斯蒂芬在《自由·平等·博爱》一书中说“我在读卢梭的《忏悔录》时发现,几乎很少有文学作品能像他对人类表达的爱那样让人恶心”。</p>
</blockquote>
<blockquote>
<p>真正的爱一定要是付出代价的,牺牲越大,爱心也就越大。无须付出代价的爱不是为了欺骗自己,就是为了欺骗他人。</p>
</blockquote>
<blockquote>
<p>我们越想按照既定的计划来规划时间,我们就越会对突如其来的事件心生怨恨。我们可以按照自己的主动安排来表达爱心,如有空时探访孤儿院,得闲时做做义工。但是<strong>我们不愿意未经规划地表达爱心</strong>。然而,后者也许更加重要。如果对未知之事保持一种开放之心,<strong>受到一种生活在愉悦的漠然之中的召唤</strong>,人生也许会无比的幸福。</p>
</blockquote>
<ul>
<li>哇…</li>
</ul>
<h3 id="春雪若盐-触地即化"><a href="#春雪若盐-触地即化" class="headerlink" title="春雪若盐 触地即化"></a>春雪若盐 触地即化</h3><blockquote>
<p>在浪漫主义看来,规则必须打破,只有突破规则的紧身衣,人才能获得最终的解放,获得自由。但是,仅仅拒绝规则也是不够的,因为拒绝会带来另一种保守,拒绝规则本身会成为一种新的规则。但规则必须被彻底破除。</p>
<p>浪漫主义有两个主要的继承人,一是政治上的法西斯主义,二是哲学上的存在主义。之所以说法西斯对浪漫主义有所借鉴是因为它们持有一个共同的概念,那就是一个人或一群人的无法预测的意志以无法组织、无法预知、无法理性化的方式前进。“领袖明天将发表什么言论,精神如何推定我们,我们去往何方,我们将做什么,一切都无法预言。”</p>
<p>而法国的存在主义抛弃了一切价值和归责,因此他们发现人完全在无意义的宇宙中生活,人的存在本身也毫无意义,人的“本质”即为没有本质,人已经无家可归。所以人的存在先于本质,人只有不断地进行选择来表明自己的自由。没有对错,没有价值判断,群婚也好,兽恋也罢,一切都只是你个人的选择,然后你勇敢地承担责任。</p>
<p>人的尊严总是先验的,在我们存在之前就早已有了这个概念。道德规则也不是人的发明,而是人的发现,否则人类社会必将沦为动物世界——强者通吃一切,强权即真理。</p>
</blockquote>
<h3 id="生命的尊严-未知死-焉知生"><a href="#生命的尊严-未知死-焉知生" class="headerlink" title="生命的尊严: 未知死, 焉知生?"></a>生命的尊严: 未知死, 焉知生?</h3><blockquote>
<p>一般说来,安乐死可以分为积极安乐死和消极安乐死,前者是采用积极的措施加速患者的死亡进程,如给患者注射或服用剧毒药品、麻醉药物让其迅速死亡;后者则是通过停止、放弃治疗,让患者自然死亡。包括我国在内的绝大多数国家和地区都对消极安乐死持容忍态度,但对积极安乐死则认为属于犯罪。</p>
</blockquote>
<blockquote>
<p>功利主义认为,人类由痛苦和快乐主宰,道德的最高原则就是使幸福最大化,使快乐总体上超过痛苦。法律的根本目的在于追求“最大多数人的最大幸福”。然而,这种立场最大的缺陷在于对个体权利和人类尊严的忽视。“最大多数人的最大幸福”不仅容易导致多数人的暴政,而且更为可怕的是,少数也往往假多数之名,肆意侵犯人权。</p>
<p>因此,今天的功利主义大多接受自由主义的修正,这主要拜穆勒所赐。穆勒认为,从长远来看,尊重个体自由会导向最大的人类幸福。</p>
</blockquote>
<ul>
<li>Ohno，让每个个体都向自己定义的幸福发展，不会导致社会整体的幸福。</li>
</ul>
<blockquote>
<p>更为可怕的是,如果根据快乐和痛苦来作为人生的福祉,当痛苦远超快乐,人就有权终止生命。那么,对某些人而言,出生本身就可能是一种严重的伤害。人可以选择死亡,但却无法选择出生。如果生来就是智力障碍、残疾,一生凄苦,这种人生值得度过吗?如果不值得度过,那么父母是否构成对子女的侵权呢?尤其当父母没有听从医生的建议,依然生产有缺陷的孩子。长大成人的孩子是否可以起诉父母,国家是否又可以追究父母的不当之举呢?甚至,国家是否可以基于功利主义而任意终止这些活在痛苦中的生命呢?</p>
</blockquote>
<blockquote>
<p>托克维尔在《旧制度与大革命》一书中早已警告我们:“谁要求过大的独立自由,谁就在寻求过大的奴役。”没有道义约束的自由往往开启的是一条通往奴役的道路。</p>
</blockquote>
<blockquote>
<p><strong>传统的道义论并不根据后果进行功利计算</strong>,而只考虑行为本身是否正当。如康德所言“道德本来就不教导我们如何使自己幸福,而是教导我们如何使自己无愧于幸福”。</p>
</blockquote>
<ul>
<li>论一个事是否道德，应该从出发点来考虑。</li>
</ul>
<blockquote>
<p>小说《莱博维茨的赞歌》讲了这样一个故事:核辐射给人们带来了巨大的痛苦,为了应对这种情况,政府成立了救助机构“绿星”,那些无法挽救的人可以到“绿星”让医生帮助结束生命,从痛苦中“解脱”。科斯医生是“绿星”的负责人,他要求泽而基修士利用修道院来协助他做这项工作。泽而基修士答应了他,但条件是不能在修道院内实施安乐死。但是科斯医生有着坚定的信念,他认为痛苦是唯一的恶,只要能够减轻痛苦,做什么都是应该的。冲突于是发生,一个未婚的母亲和她的孩子遭受了无法忍受的核辐射,承受了巨大的痛苦。在修道院,科斯医生劝这位母亲接受“绿星”的“治疗”。但泽而基修士却认为必须尽一切的可能阻止她们接受这种治疗。</p>
<p>面对这种冲突,有人可能会说,“我认为安乐死是错误的,但我永远不会把自己的价值观强加于人,每个人都应自主决定。”</p>
<p>故事是这样发展的:年轻的母亲不知该如何决定。一方面,科斯医生不能强迫她们接受“治疗”;另一方面,她也不确定是否听从泽而基修士的观点。</p>
<p>她该如何选择呢?科斯医生代表功利论,泽而基修士代表的则是道义论。</p>
<p>年轻的母亲决定去“绿星”再听听科斯医生的建议。但泽而基修士认为她们面临着生命的危险。在良心的煎熬下,泽而基修士把那位母亲和她的孩子带到自己的车里,想把她们带到修道院,以保证她们的安全。科斯医生却叫来了警察,警察让泽而基修士把车停到路边。</p>
<p>警察问这位年轻的母亲,“你准备怎么办?”她不知道如何抉择。</p>
<p>当泽而基修士想开动车辆时,警察却将钥匙拔了出来。这注定了年轻的母亲只有接受科斯医生的建议。</p>
<p>这个故事告诉我们,很多时候人们并不知道如何选择,<strong>你不是遵循道义的指引,就是按照国家意志来生活。</strong>无视道义约束的个人自由与漠视道义的国家意志不过是一体两面。</p>
</blockquote>
<h3 id="致法学新人的第一封信-关于读书"><a href="#致法学新人的第一封信-关于读书" class="headerlink" title="致法学新人的第一封信: 关于读书"></a>致法学新人的第一封信: 关于读书</h3><blockquote>
<p>功利性读书必然让你接受<strong>成功主义的价值观</strong>，魔鬼正是试图通过<strong>成功</strong>让我们放弃自己安身立命的美好价值。</p>
</blockquote>
<blockquote>
<p>功利性读书让你只想成功,无法接受失败。但我始终认为,一个人的真正成功不是在于你取得多少辉煌,而是在挫折中,你能不能勇敢地爬起来。在大量与功利无关的文学作品、名人传记中,主人公的失败、困苦、绝望比比皆是。那么多伟大的灵魂,他们也曾有跌倒的时候,你为什么不能跌倒?</p>
</blockquote>
<ul>
<li>嗯…无法接受失败，所以不如不开始。挫折后直接躺下吧。</li>
</ul>
<blockquote>
<p>孔门七十二贤,不乏博学多能,高官厚禄者,但孔子最欣赏的学生却是单纯的颜回。颜回心态平和,情绪稳定,善于改过自新,注重德行。这种内心的丰富在功利性阅读中不可能习得。</p>
</blockquote>
<blockquote>
<p>功利性读书会让人自高自大,孤标傲世。知识经常会让人骄傲,给人带来智力上的优越感,让你瞧不起人,无法与人建立正常的人际关系。</p>
</blockquote>
<ul>
<li>嗯…这和某些宗教徒如出一辙</li>
</ul>
<blockquote>
<p>一般的书籍都可以泛读,不要抱着读一本书要学多少东西的心态,否则就回到了功利主义的路子,很多同学经常向我抱怨“老师,我读书老记不住,读了后面就忘了前面”。其实为什么要记住呢?是为了写文章,还是为了在别人面前炫耀呢?读书就是为了读书而读书,陶渊明说“好读书,不求甚解;每有会意,便欣然忘食”。在读书过程中,有那么片刻你能达到与书同乐、欣然忘食的境界,那就达到读书的目的了。你的内心就在潜移默化中慢慢被洗涤了。</p>
</blockquote>
<ul>
<li>让读书回到一个“过程”，而不是一个目的。</li>
</ul>
<h3 id="致法学新人的第二封信-与人和睦相处"><a href="#致法学新人的第二封信-与人和睦相处" class="headerlink" title="致法学新人的第二封信: 与人和睦相处"></a>致法学新人的第二封信: 与人和睦相处</h3><blockquote>
<p>特蕾莎修女说:“我们以为贫穷就是饥饿、衣不蔽体和没有房屋,然而最大的贫穷却是不被需要、没有爱和不被关心。”</p>
</blockquote>
<blockquote>
<p>在小城镇中,人际关系是被选择的,我们必须被动地接受形形色色的邻居,你不喜欢小狗,但隔壁邻居养狗,而且还时常会牵着狗来你家串门,那你就必须忍受;他不喜欢小孩,但隔三岔五,会有邻居让他帮着照看孩子,他也就得学会如何去接受或者喜欢上小孩。总之,在一个小群体中的我们不得不去学会如何与人和谐相处,<strong>对于人的多样性、差异性的认识要比在大城市中深刻得多。</strong>在大城市,因为人多,有很多不同的群体,你可以根据你的偏好选择交往的圈子。于是,你可以按照自己的喜好去建立人际关系,而不是被动地去适应人际关系,你讨厌狗,你可以搬到一个没有人养狗的社区,<strong>于是你也就不可能真正了解养狗人的生活。</strong>只要你根据自己的偏好选择与人打交道,你也就无法建立真正的人际关系。这就相当于在网络世界,你可以参加很多小组、群体,网络上朋友遍天下,现实世界中却茕茕孑立、形影相吊。因为,在网络上,人们是按照自己的需要去选择朋友,自己的爱好、兴趣、偏见、缺陷<strong>都在自己选择的圈子中被强化</strong>,你永远都在向自己学习,而不是向他人学习。</p>
</blockquote>
<blockquote>
<p>如果舍友是可以选择的,我当年一定选择与我本乡本土、趣味相投、饮食相同的人住一个宿舍,如果真是那样,我永远无法根除自己内心的孤僻与偏见,估计我的普通话现在大家还是听不懂,也很难接受北方的食物。我很庆幸学生时代有住集体宿舍的经历,它让我开始学会如何去与人相处,与人沟通,如何妥协、宽容、尊重,如何去克服自己的种种缺陷。</p>
</blockquote>
<ul>
<li>有趣的是，很多时候我们分到的舍友和我们很合拍，我们会觉得很幸运。可能这时候，我们也就失去了学习和进步的机会。</li>
</ul>
<blockquote>
<p>人与人之间建立关系是需要投入感情的。无论是亲人之爱、爱人之爱、朋友之爱,都是要付出情感和时间的。人与人之间的关系就像存钱一样,你必须先存钱,然后才能取钱,如果只取钱,不存钱,那就是恶意透支,你要面临破产了。因此,如果你想从他人身上支取感情,你首先必须存入足够的感情。</p>
</blockquote>
<blockquote>
<p>很多同学都看过《小王子》,书中的小王子见到一只狐狸,想和狐狸交往,狐狸说,我不能和你玩耍,因为你还没有驯服我,还没有和我建立联系——“对我来说,你还只是一个小男孩,就像其他千万个小男孩一样。我不需要你。你也同样用不着我。对你来说,我也不过是一只狐狸,和其他千万只狐狸一样。但是,如果你驯服了我,我们就互相不可缺少了。对我来说,你就是世界上唯一的了;我对你来说,也是世界上唯一的了。”“如果你要是驯服了我,我的生活就一定会是欢快的。我会辨认出一种与众不同的脚步声。其他的脚步声会使我躲到地下去,而你的脚步声就会像音乐一样让我从洞里走出来。再说,你看!你看到那边的麦田没有?我不吃面包,麦子对我来说,一点用也没有。我对麦田无动于衷。而这,真使人扫兴。但是,你有着金黄色的头发。那么,一旦你驯服了我,这就会十分美妙。麦子,是金黄色的,它就会使我想起你。而且,我甚至会喜欢那风吹麦浪的声音……”狐狸遗憾地对小王子说:“现在的人们总是到商人那里去购买现成的东西,因为世界上还没有购买朋友的商店,所以人也就没有朋友。如果你想要一个朋友,那就驯服我吧!”于是,小王子开始学着如何投入时间和感情去与狐狸建立联系。慢慢地,小王子驯服了狐狸。当小王子要离开的时候,狐狸感到非常难过,它哭了,小王子说:“这是你的过错,我本不想给你造成任何痛苦,但你却让我驯服你。”狐狸说自己虽然难过,但却得到了很多好处,如当风吹麦浪,那金黄色的麦浪让它觉得从此与众不同。</p>
</blockquote>
<ul>
<li>当年初读心境不对，现在再看感慨良多…</li>
</ul>
<blockquote>
<p>每个人都喜欢和自己喜欢的人在一起,这是人之常情,但这种爱其实在很大程度是一种自私的爱,或者说是一种自恋。我们爱的其实只是自己投射在他人身上的影子,而如果这个影子在他人身上慢慢消失,你可能就失去对他的爱意。</p>
</blockquote>
<ul>
<li>正是。</li>
</ul>
<blockquote>
<p>大家都任凭情感的泛滥,当情感来袭,就结婚了;当情感消失,就离婚了。这种爱,更多的是一种自恋。很多人为了寻找爱情,在不同的情人中周旋探索,最后却是越来越觉得孤独。原因就在于,自恋的爱永远不能长久,任何一个人都无法达到你对他的全部预设。</p>
</blockquote>
<blockquote>
<p>一个可爱的人,人人都会爱他,但当他不再像以前那么可爱,你还爱他,并且愿意去发掘他的可爱之处,这可能就是真正的爱了,而要做到这一步,就必须有宽容的心。有人说,这样太难了,不可能实现。但你有没有发现,其实每天你都在这样宽容地爱着一个人,不论这个人是好是坏,你都爱他。你也许会恨他所犯下的错误,但你依然还爱着这个人本身,而且我相信你会爱他一辈子,这个人就是你自己。不管我可能多么讨厌自己的自负、贪婪、胆怯,我仍然爱我自己。实际上,我恨这些东西正是因为我爱这个人,正因为爱自己,我才会为自己干出这种事情而难过。</p>
</blockquote>
<ul>
<li>我靠，这逻辑… </li>
<li>爱一个人，所以会恨那些使自己堕落的东西。</li>
</ul>
<blockquote>
<p>大学的宿舍生活其实就是一个很好的地方——操练宽容之爱的场所,宿舍的同学都有各自的偏好以及缺陷,如果你能慢慢地接受他的缺陷,你也就会慢慢地喜欢上他。我在大学时非常讨厌我上铺,因为他睡觉老是翻来覆去,还会打鼾,我不止一次在脑海中想象出针对他的种种“恶毒计划”,当然最后都没有实施。后来我慢慢地习惯了他,才发现他还是很可爱的,而且最后我发现其实我的鼾声才是全宿舍最大的,他为什么睡觉翻来覆去,正是因为我的鼾声干扰了他。</p>
</blockquote>
<ul>
<li>这奇妙的结局</li>
</ul>
<h3 id="致法学新人的第三封信-与德相随"><a href="#致法学新人的第三封信-与德相随" class="headerlink" title="致法学新人的第三封信: 与德相随"></a>致法学新人的第三封信: 与德相随</h3><blockquote>
<p>有四种德行为文明人所认可,它们分别是谨慎、节制、公正、坚毅。</p>
</blockquote>
<blockquote>
<p>谨是言字旁,这其实就是提醒我们说话要慎重。繁体字的说(説)由“言”与“兑”组成,让我们在说话时要想想这句话能否兑现,能够兑现的言语才能说出来</p>
</blockquote>
<blockquote>
<p>比如抽烟,想抽什么烟就能抽什么烟,这是一种自由,但还有一种自由是有很多烟放在你面前,你可以抽但你愿意不抽。</p>
</blockquote>
<ul>
<li>Yeah. 想起了那本戒烟书</li>
</ul>
<blockquote>
<p>时间是宝贵的,我们唯一可以支配的最宝贵的财富就是我们的时间,因此一定要把时间投入在最重要的事情上。沉溺于网络游戏,你可能<strong>很难适应真实的世界。</strong></p>
</blockquote>
<blockquote>
<p>马丁·路德·金说:我们必须接受失望,因为失望是有限的,但我们永远不能放弃希望,因为希望是无限的。</p>
</blockquote>
<h3 id="心怀永恒-活在当下"><a href="#心怀永恒-活在当下" class="headerlink" title="心怀永恒 活在当下"></a>心怀永恒 活在当下</h3><blockquote>
<p>一种观点认为时间是循环的,它是一个封闭的环形,一圈一圈,周而复始,无始无终。在这样一种时间概念中,没有什么时刻特别,时间永远都是一样的。对于时间,无所谓珍惜与浪费,时间如环无端,历史没有意义。跳出时间的闭路循环,人生方有大的解脱。这种对时间的态度在相当程度上是冷漠甚至充满敌意的,在某种意义上它完全消解了时间这个概念。</p>
<p>另一种观点则认为时间是线性的 , 有始有终 。因此 , 时间的意义是非凡的 , 有许多特定的时间点都具有特定的意义 , 历史并不是虚无的 。</p>
<p>换言之 , 只有聚焦于永恒 , 现在才具有存在的意义 。</p>
</blockquote>
<ul>
<li>哇，前一种令人绝望，后一种令人产生希望。而这两种的区别，就是不同的永恒。</li>
</ul>
<blockquote>
<p>用奥古斯丁的话来说,过去是通过记忆而存在于我们的心中,将来则是通过已经存在而能看见的东西预言得到的。因此,“说时间分过去、现在和将来三类是不确当的。或许说,时间分过去的现在、现在的现在和将来的现在三类,比较确当”。而这三种“现在”,都要经过我们当下的意识。</p>
</blockquote>
<ul>
<li>只有“现在”才可以被感知到</li>
</ul>
<blockquote>
<p>但是,永恒这个概念是人的理性很难理解的,许多人因为它的不可理解,所以抛弃了永恒这个概念。当人们抛弃了永恒,但又希望获得现在存在的意义,于是就创造了未来这个概念。但<strong>未来只是永恒的赝品</strong>,它依然指向无尽的虚空,因此也就永远无法让人真正抵抗内心的虚无与焦虑。</p>
</blockquote>
<blockquote>
<p>C.S.路易斯告诉我们:“几乎一切罪恶都扎根于未来。感恩是在回顾过去,爱着眼于现在,恐惧、贪财、色欲和野心在眺望着未来。”</p>
<p>“把信心建立在一些计划的成败上面,而这些计划的结局可能是他们有生之年无法看到的。他们终其一生在追寻一些海市蜃楼,在当下永远不诚实,永远不良善,永远不快乐,<strong>只把现在赋予自己的一切真实恩赐充作燃料,堆积在为未来而设的祭坛上</strong>”。</p>
</blockquote>
<ul>
<li>霍！</li>
</ul>
<blockquote>
<p>时间指向永恒,因此生活于时间之中的男男女女,也都具有永恒的意义。C.S.路易斯说:“不存在普通人,<strong>我们嬉笑、共事、结婚、冷落、剥削的对象都是不朽的人。</strong>”每个不朽的个体也就超越一切<strong>必朽的文化</strong>与国族的价值。</p>
</blockquote>
<h3 id="不破楼兰终不还"><a href="#不破楼兰终不还" class="headerlink" title="不破楼兰终不还"></a>不破楼兰终不还</h3><blockquote>
<p>圣雄甘地说,有七样东西能够毁灭人类,其中之一就是没有是非观念的知识。1942年1月20日,柏林郊区,万湖别墅,漫天飞雪,第三帝国的最高级别官员召开了一场会议,史称“万湖会议”。在这场会议中,纳粹出台了针对犹太人的“最终解决方法”,与会者制定了一个详细的各国屠杀犹太人的分配清单,德国人以其特有的理性和严谨在这座风景秀美的别墅中勾圈划点,精心策划,分配指标,杀人居然精确到个数。与会的很多人拥有博士学位,而且大部分是法学博士。会议持续了90分钟,最终导致600万犹太人的生命终结。</p>
</blockquote>
<ul>
<li>魔鬼代言人：我们是否为有罪的人辩护？</li>
</ul>
<blockquote>
<p>法治与法家,一字之差,却谬之千里。正如八角是烹饪的常用调味品,莽草貌似八角,却有剧毒。</p>
<p>法治永远的命题是对权力的高度警惕,而法家的本质则是对权力的极端崇拜。法家好重刑,严刑峻法,残酷寡恩,好大喜功,急功近利,为达目的可以不择手段。因此,“法律”只是权力的工具,权力永远在“法律”之上。但法治却拒绝一蹴而就的高歌猛进,它本着对权力深深地不信任,认为一切权力都要受到法律严格的约束,为了公义宁可牺牲效率。</p>
</blockquote>
<h3 id="我们一生都走在回家的路上"><a href="#我们一生都走在回家的路上" class="headerlink" title="我们一生都走在回家的路上"></a>我们一生都走在回家的路上</h3><blockquote>
<p>过年回家,对于中国人而言,几乎是天经地义的。我们对于回家有种近乎宗教执着的情感。历尽千辛万苦,我们只有一个目的,那就是回家过年。</p>
</blockquote>
<ul>
<li>哎 有点感动</li>
</ul>
<blockquote>
<p>甚至是怠惰(acedia),其表现是“无所信,无所爱,无所恨,无所追寻,生无所求,<strong>仍旧活着的原因是因为死亦无所求</strong>”。(多萝西·塞耶斯语)</p>
<p>怠惰是“空虚灵魂之罪”,它最擅长的形式就是用风风火火的身体行动来自我粉饰。我们用忙碌来对抗我们虚无的怠惰,虽然我们知道这只是自欺欺人,<strong>忙碌本身就是心死(心亡)的表现。</strong></p>
</blockquote>
<h3 id="为了告别的聚会"><a href="#为了告别的聚会" class="headerlink" title="为了告别的聚会"></a>为了告别的聚会</h3><blockquote>
<p>当人随心所欲,无法预知自己下一刻会如何抉择,这种自由会让人无比苦恼。<strong>人们会想逃避自己的自由,但却无法逃避,因为我们是自由的。</strong></p>
</blockquote>
<ul>
<li>自由也无法逃避，因为我们是自由的。</li>
</ul>
<blockquote>
<p>伪善的人最喜欢空谈崇高的话题。他们活在崇高的理念之下,用这种理念逃避对具体个体的责任,为自己的虚伪披上神圣的外袍。</p>
</blockquote>
<blockquote>
<p>“一旦我占有了她,一种有弹性的力量会突然又把我弹回到(妻子)凯米蕾身边,有时我感到我追求这些女人,仅仅是为了弹回到妻子身边时那美妙的一瞬(这一瞬充满温柔、渴望和谦卑),随着每一次新的不忠,我反而越来越爱她了。”</p>
</blockquote>
<ul>
<li>过于真实。</li>
</ul>
<blockquote>
<p>荒诞不可能是世界的本相,因为这在逻辑上说不通。如果荒诞是本相,那么真实就是不存在的。如果不存在真实的对照,荒诞本身也就无法存在。</p>
</blockquote>
<ul>
<li>哈哈哈 想起了提摩太凯勒的循环论证。</li>
</ul>
<blockquote>
<p>不要因为行动与言论有不一之处就轻言放弃。只要你不是持续的故意言行不一,就不要给自己贴上“虚伪”的标签。<strong>如果我们所有的话语都必须与言论相符,那我们一生只能沉默。</strong>只要我们的行为比我们的言语相比更有说服力,我们就跳出了虚伪的牢笼。</p>
</blockquote>
<ul>
<li>所以关键在于，要让行为也有<strong>说服力。</strong></li>
</ul>
<blockquote>
<p>人在追求美善的同时很容易出现一种负斜率,那就是因着这种追求让我们陷入新的自恋。</p>
</blockquote>
<ul>
<li>是的，这种想法也常常令我陷入深刻的怀疑…是否该追求呢？</li>
</ul>
]]></content>
      <categories>
        <category>Books</category>
        <category>圆圈正义</category>
      </categories>
  </entry>
  <entry>
    <title>语文学习</title>
    <url>/2020/07/25/%E8%AF%AD%E6%96%87%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一个中文学习的积累本</p>
<a id="more"></a>



<h1 id="生字词"><a href="#生字词" class="headerlink" title="生字词"></a>生字词</h1><p>攻讦jie2：（因利害冲突）揭发并攻击别人的过失或阴私。</p>
<p>始乱终弃：开始加以玩弄，后来就遗弃了</p>
<p>狂狷juan4：狂者，志在兼济，锐意进取；狷者，独善其身，有所不为。（狷与狂相对）</p>
<p>莫须有：奸臣秦桧诬告岳飞谋反，韩世忠质问有没有证据，秦桧说「莫须有」。意思是「也许有」或「恐怕有」。后用「莫须有」指凭空捏造的（罪名）。</p>
<p>发明本心：每个人都可以通过正心、诚意等修养功夫得到真善美。毋须在读书穷理方面过多地费功夫，应该先挖掘自己的内心。</p>
<p>感念：感激怀念</p>
<p>桎梏 zhìgù∶ 像镣铐般约束、妨碍或阻止自由动作的事物</p>
<p>揶揄yé yú：耍笑、嘲弄、戏弄、侮辱之意。</p>
<p>阖闾[hé lǘ]：吴王</p>
<p>嗫嚅，指想说而又吞吞吐吐不敢说出来。</p>
<p>嗔(chen1)怪：多用在女性对爱人或曾经的爱人的一种责怪，略带一点撒娇的成分在其中.</p>
<p>膂力[lǚ lì]体力；力气</p>
<p>谆谆zhūn教诲</p>
<p>撷取xié：采取，摘取</p>
<p>血脉贲bēn张</p>
<p>狷介juan4一指拘谨小心；二指性情正直，洁身自好，不与人苟合。</p>
<p>氐惆 [dī chóu]：昏乱不安；郁闷不舒畅</p>
<p>同庚：同岁</p>
<p>蔡邕yong1 蔡文姬名琰yan3 李傕jue2 兖州yan3</p>
<p>张钧甯：ning4</p>
<p>餍yan4足 一是吃饱、饱足的意思；二是满足（多指私欲）的意思。</p>
<p>殁mo4:“殁”表示死来源于“没”。古人用沉没比喻死亡，“没”是死的委婉说法</p>
<p>不啻chi4：指不只；不止；不仅仅；不亚于。</p>
<p>褫chi3夺：意思是依法剥夺</p>
<p>揠ya4苗助长</p>
<p>择zhai2席：指换一个地方就睡不好觉</p>
<p>亲狎xia2： 亲近而不庄重 = 狎昵ni4</p>
<p>超验主义：主张人能超越感觉和理性而直接认识真理</p>
<h1 id="成语"><a href="#成语" class="headerlink" title="成语"></a>成语</h1><p>狮子搏兔，亦用全力：意思是通过陈述狮子捕杀兔子仍然用全力，比喻对小事情也拿出全部力量认真解决。</p>
<p>心有戚戚焉：出自《齐桓晋文之事章》，意思是我深有感触。</p>
<blockquote>
<p>《论语·述而》：“子曰：述而不作，信而好古，窃比于我老彭。”</p>
</blockquote>
<ul>
<li>述而不作：只叙述和阐明前人的学说，自己不随意创作；</li>
<li>信而好古：相信并爱好古代的物事。</li>
</ul>
<p>无远弗届：意思即不管多远之处，没有不到的。</p>
<p>俯拾皆是：注意是fu shi啊，</p>
<p>同仇敌忾kài：同仇：共同对敌；敌：对抗，抵拒；忾：愤怒。指全体一致痛恨敌人。</p>
<p>心存芥蒂jiè dì</p>
<p>吃拿卡要：卡（qia3）:拿了好处不办事。</p>
<p>色厉内荏rěn：人外表严厉而内心怯懦=外强中干</p>
<p>哑然失笑：感情激动得不能控制因而笑出声来。</p>
<p>其来有自：指事情的发生、发展有其来由，并非偶然。</p>
<p>盛名之下其实难副：名不副实</p>
<p>暗通款曲：用以比喻男女的私通「劈腿」。偷来暗去、偷偷摸摸、隐密隐藏、不让人知道的意思。 也有官商勾结</p>
<p>龙驭上宾：皇帝死了的委婉说法</p>
<p>恩同再造：比喻恩情极大，像救了自己的性命一样。</p>
<p>桑榆暮景：落日的余晖照在桑榆树梢上，比喻老年的时光。</p>
<p>深入浅出：指言论或文章的观点主题意义深刻，但在语言文字的表达方式上却浅显易懂。出自《湖楼笔谈》。</p>
<p>无独有偶：虽然罕见，但是不只有一个，还有一个可以成对儿（多用于贬义）。</p>
<p>缘木求鱼：缘木，爬树。爬到树上去找鱼。比喻方向或办法不对头，不可能达到目的。</p>
<p>大为光火：很生气</p>
<p>短兵相接：指作战时近距离厮杀。后来也比喻双方面对面进行尖锐的斗争。</p>
<p>眉毛胡子一把抓: 比喻做事不分轻重缓急。</p>
<p>踽踽独行ju3：孤零零地独自走着。形容非常孤独。</p>
<p>不知子午卯酉：就是说他不知昏暗连一日四时也不清楚，蒙蒙然不明事理</p>
<h1 id="诗词句"><a href="#诗词句" class="headerlink" title="诗词句"></a>诗词句</h1><p>相见争如不见，有情何似无情。笙歌散后酒初醒，深院月斜人静。—-司马光《西江月》</p>
<p>所求皆如愿，所行化坦途</p>
<p>少年乐新知，衰暮思故友。</p>
<blockquote>
<p>博观而约取，厚积而薄发</p>
</blockquote>
<ul>
<li>博约观取：广泛地阅览，扼要地选取。</li>
<li>厚积薄发：充分地积蓄，慢慢地放出。</li>
</ul>
<p>不如意事常八九，可与言者无二三。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>龙应台在《目送》里面使用了第二人称…？的手法。将他的母亲写成“你的母亲”…诸如此类</p>
<p>中国式的八大宽容：大过年的、人都死了、来都来了、都不容易、还是孩子、岁数大了、为了你好、习惯就好。 </p>
]]></content>
      <categories>
        <category>Study</category>
        <category>语文学习</category>
      </categories>
  </entry>
  <entry>
    <title>MOOC笔记</title>
    <url>/2020/08/11/MOOC/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>将学过的MOOC整理在这里</p>
<ul>
<li>公正 Justice by Havard</li>
<li>博弈论 Game Theory by Stanford</li>
</ul>
<a id="more"></a>



<h1 id="公正-What’s-the-Right-Thing-to-Do"><a href="#公正-What’s-the-Right-Thing-to-Do" class="headerlink" title="公正 / What’s the Right Thing to Do"></a>公正 / What’s the Right Thing to Do</h1><h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><p>电车的例子，治病救人的例子。</p>
<p><strong>后果/功利主义道德推理Consequentialist</strong>：一个道德的选择，取决于你的行为所导致的后果。所以结论是：牺牲一人保全五人是更好的选择。代表人：边沁。</p>
<p><strong>绝对主义道德推理Categorical</strong>：是否道德取决于特定的绝对道德准则，取决于绝对明确的义务与权力，而不管后果如何。代表人：康德。</p>
<p>哲学就是让我们面对自己熟知的事物，引导并动摇我们原有的认知。这些让我们对熟知的事物变得陌生，不是通过提供新的信息，而是通过引导并激发我们用全新方式看问题，但这正是风险所在。一旦所熟知的事物变得陌生，它将再也无法回复到从前。自我认知就像逝去的童真，不管你有多不安，你已经无法回到过去了。</p>
<p>因为哲学使人疏离现实，甚至可能弱化行动力。追溯到苏格拉底时代，就有这样一段对话。古希腊哲学家卡里克利斯，试图说服苏格拉底放弃哲学思考，他告诉苏格拉底:如果一个人在年轻时代，有节制地享受哲学的乐趣，那自然大有裨益。但倘若过分沉溺其中，那他必将走向毁灭。听我劝吧，卡里克利斯说，收起你的辩论，学个谋生的一技之长，别学那些满嘴谬论的人。要学那些生活富足，声名显赫及福泽深厚的人。</p>
<p>面对上述的哲学风险，有一种典型的回避方式，怀疑论：既然大佬们都想不出来，我肯定也想不出来，干脆不想了。康德曾很贴切地描述了怀疑论的不足（参见康德的《纯粹理性批判》）理性自省，是以伺将来做出正确抉择的地方，但绝非理性的永久定居地。简单地默许于怀疑论，永远无法平息内心渴望理性思考之不安。</p>
<h2 id="Lecture-2"><a href="#Lecture-2" class="headerlink" title="Lecture 2"></a>Lecture 2</h2><p>边沁对于功利主义道德论的定义：最大化功利（Utility）</p>
<ul>
<li>也有时候被总结为一句口号：为最多的人谋求最大的幸福</li>
</ul>
<p>功利主义认为快乐和痛苦都是可以计算的，功利 = 快乐 - 痛苦</p>
<p>课堂上举了达德利船长杀人案，产生了三个问题：</p>
<ol>
<li>某些基本权利我们有吗？</li>
<li>只要程序公平就可以不论结果吗？</li>
<li>征得同意到底有何道德作用？</li>
</ol>
<p>在飓风来临的时候，物价飞涨，那是否合理呢？自由市场自由贸易的人认为物价涨了之后可以吸引供应商把更多的东西运过来，是一件帮助恢复的好事。但是这样的话只有那批富人觉得OK，很多穷人的利益就被忽视了。资本主义也讲究一个社会整体福利。我们在计算社会整体福利的时候，不能忘记了那些基本生活必需品都拿不到的普通人。</p>
<blockquote>
<p>In times of trouble, a good society pulls together. Rather than press for maximum advantage, people look out for one another.</p>
</blockquote>
<blockquote>
<p>To acknowledge the moral force of the virtue argument is not to insist that it must always prevail over competing considerations. What’s important to notice, is about cultivating the attitudes and dispositions, the qualities of character, on which a good society depends.</p>
</blockquote>
<blockquote>
<p>So you might say that ancient theories of justice start with virtue, while modern theories start with freedom.</p>
</blockquote>
<blockquote>
<p>Thinking about justice seems inescapably to engage us in thinking about the best way to live.</p>
</blockquote>
<p>08年金融危机，170million的政府援助给AIG公司，最后160million分给了他的领导层。跟这次疫情期间简直一模一样。</p>
<blockquote>
<p>Wall Street traders, bankers, and hedge fund managers are a hard-charging lot. The pursuit of financial gain is what they do for a living. Whether or not their vocation taints their character, their virtue is unlikely to rise or fall with the stock market. So if it’s wrong to reward greed with big bailout bonuses, isn’t it also wrong to reward it with market largess?</p>
<p>One obvious difference is that bailout bonuses come from the taxpayer while the bonuses paid in good times come from company earnings. This takes us to the heart of the complaint. The American public’s real objection to the bonuses—and the bailout—<strong>is not that they reward greed but that they reward failure.</strong></p>
</blockquote>
<ul>
<li>霍</li>
</ul>
<blockquote>
<p>We sometimes think of moral reasoning as a way of persuading other people. But it is also a way of sorting out our own moral convictions, of figuring out what we believe and why.</p>
</blockquote>
<blockquote>
<p>As we encounter new situations, we move back and forth between our judgments and our principles, revising each in light of the other.</p>
<p>Moral reflection is not a solitary pursuit but a public endeavor. It requires an interlocutor—a friend, a neighbor, a comrade, a fellow citizen.</p>
</blockquote>
<ul>
<li>从我们的判断和原则这两方面来理清公正的问题。</li>
<li>我们还需要以为可以一起讨论的朋友，防止我们关注公正的看法只是一种自我强化的偏见。</li>
</ul>
<h2 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h2><p>功利主义逻辑现今的实践之一：成本效益分析（Cost-Benefit-Analysis）</p>
<p><strong>反对功利主义的两点异议：</strong></p>
<ol>
<li>是否尊重了个体/少数人的权力？</li>
<li>整个功利求和的加总方式是不是合理的/可能的？<ul>
<li>男女同校的例子</li>
<li>我们是否该考虑gaoji/低级快乐的区别</li>
</ul>
</li>
</ol>
<blockquote>
<p>Bentham arrives at his principle by the following line of reasoning: We are all governed by the feelings of pain and pleasure. They are our “sovereign masters.” They govern us in everything we do and also determine what we ought to do. The standard of right and wrong is “fastened to their throne.” </p>
</blockquote>
<ul>
<li>我们必不是我们情绪的奴隶，或者说本不应该。</li>
</ul>
<blockquote>
<p>All moral quarrels, properly understood, are disagreements about how to apply the utilitarian principle of maximizing pleasure and minimizing pain, not about the principle itself.</p>
</blockquote>
<ul>
<li>自我为中心的想法。对这些人来说，信仰也只是满足自己的工具罢了。</li>
</ul>
<h2 id="Lecture-4"><a href="#Lecture-4" class="headerlink" title="Lecture 4"></a>Lecture 4</h2><p>如何判断更高级别的快乐：穆勒：两种快乐都感受过的人，更偏好的就是高级快乐。</p>
<p>穆勒认为如果受到过培养、鉴赏和教育，不仅能够分辨出来两种快乐之间的差别，而且会真的偏好高级快乐：</p>
<ul>
<li>「当痛苦的人，胜过当快乐的猪」</li>
</ul>
<p>穆勒认为公正就像是高级快乐，长远角度来说是更好的，不过这并没有逃出功利主义的思考方式。</p>
<h2 id="Lecture-5"><a href="#Lecture-5" class="headerlink" title="Lecture 5"></a>Lecture 5</h2><p>穆勒认为长远来看，基于功利主义的演算，道德上对的事都是有好处的。</p>
<ul>
<li>在摘除健康人器官的例子中，如果摘除了，可能会导致社会上的人不再敢去体检，带来长远的负面影响。不过，医生不摘除健康人的器官，仅仅是担心以后没人到医院体检了吗？还是有其他的原因…</li>
</ul>
<p>自由主义：我们是独立存在的个体，我们享有自由的基本权利。我们有权自由选择，过自己喜欢的生活，只要尊重他人同等的权利。</p>
<p>自由主义下的政府错误行为：</p>
<ol>
<li>家长式的立法，即制定保护人们免受自身行为伤害的法律：安全带，摩托车头盔。<ul>
<li>戴头盔也许是件好事，但是需要人们自己做主</li>
</ul>
</li>
<li>道德式的立法：禁止同性恋行为。<ul>
<li>没人因同性恋行为而受到伤害，不该使徒立法弘扬道德。</li>
</ul>
</li>
<li>任何为了劫富济贫，进行收入或财富再分配。<ul>
<li>相当于政府实行的盗窃，其对象是工作出色而赚得大钱的人</li>
</ul>
</li>
</ol>
<p>自由主义认为：你无法根据财富分配的结局来判断财富分配是否公平，应该按照过程：</p>
<ol>
<li>最初占有的公正原则：人们是否公平的获得生产资料，如果厂房、土地都不是偷来的即可。</li>
<li>财富的分配是否基于自由达成的交易：分配的结果是出自于自由市场上个体的自由选择。</li>
</ol>
<p>诺齐克的逻辑链：征税 -&gt; 拿走了我的财富 -&gt; 强迫义务劳动 -&gt; 我变成奴隶 -&gt; 我对我自己没有控制权 -&gt; 征税不符合自由主义。</p>
<p>政府在制定反雇佣歧视法时，也同样侵犯了个人权利——歧视别人的权力</p>
<ul>
<li>乍一看挺合理，但是这其实有瑕疵…因为自由主义的一个根本点是尊重他人同等的权力。</li>
<li>同样的例子还有强制退休金、最低工资标准、行业执照的要求…</li>
</ul>
<p>关于乔丹的特殊例子：假设在乔丹离开NBA的第一年，芝加哥市政厅为了安抚芝加哥公牛球迷的心，而要求乔丹继续打下一个赛季1/3的比赛，大多数人会认为这样一个法律是不公正的，是对乔丹自由的一种侵犯。但是，如果国会不能强迫乔丹重返赛场，那么他又有什么权利强迫乔丹放弃他靠打篮球所得的1/3的收入呢？</p>
<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><p>博弈有三部分构成：玩家，行为，收益<br>博弈论分为两种基本形式：</p>
<ul>
<li>范式博弈（Normal）：假定所有玩家同时采取行动，</li>
<li>展开博弈（Extensive）：设计不同玩家之间的Timing&amp;Information，一般用树模型。</li>
</ul>
<p>n人的范式博弈：&lt;N,A,μ&gt;</p>
<ul>
<li>N：1~n 表示了参与人数</li>
<li>Ai：Action Set行为集合</li>
<li>μi：效用函数utility/payoff Function</li>
</ul>
<p>常用矩阵来描绘博弈：如果两个玩家的话，行是一个玩家，列是一个玩家，矩阵的元素是一个二维的向量，表示他们各自的收益</p>
<p>反抗政府的那个例子中我们发现，如果其他人的决策对个体的决策有影响的话，就不能用矩阵形式来表示了。</p>
<p>一个简单的常和博弈的例子——匹配硬币:pure competition 效用函数之和是0或是个常数</p>
<ul>
<li><p>两个人正反面相同：A给B一块钱</p>
</li>
<li><p>两个人正反面不同：B给A一块钱</p>
</li>
</ul>
<p>Pure cooperation：每个人的效用函数相同</p>
<p>夫妻两人看电影的例子：可以同时存在竞争和合作</p>
<p>纳什均衡考虑的步骤：</p>
<ol>
<li>其他人会怎么做</li>
<li>我要如何来应对</li>
</ol>
<p>纳什均衡就是每个人都作出最优解所形成的局面<br>纳什均衡是稳定的，因为不是纳什均衡的情况是不稳定的。（随着人们对问题的了解深入，他们会改变他们的主意）</p>
<p>凯恩斯的选美比赛（keynes’s beauty contest game）：英国的报纸上，在几幅美女图片中，选出来你认为最受其他人欢迎的美女。这就是一种要考虑其他人行为而不是单单考虑自己行为的博弈。</p>
<p>又一个game：每个人说出一个1-100的数字，然后最接近大家平均数的2/3的那个人获胜，下面开始解题：</p>
<ol>
<li>每个人猜平均是X，所以会出0.66X,但因为X&lt;=100,所以每个人的数字不会超过67</li>
<li>所以平均会是67及以下，所以会出0.66*67，所以无限循环下去</li>
<li>纳什均衡告诉我们，每个人该出1！</li>
<li>最后结果第一轮是23胜出，又做了一遍是4，结果向着纳什均衡（1）在发展</li>
</ol>
<p>我们将a(-i)定义为除了自己其他人的策略集，a<em>定义为自己的最优策略，最优策略可以不唯一，但一定是出自最优对策集BR(Best response)。最优对策集的假设是其他所有人都会使用策略a(-i),那么BR的定义：<br>ai</em> ∈ BR(a(-i)) iff 对任意ai∈Ai,Ui(ai*,a(-i))&gt;=Ui(ai,a(-i))<br>Best response 不一定只有一个</p>
<p>&lt;a1,…,an&gt; is called a pure strategy Nash equilibrium iff 任意i,ai ∈ BR(a(-i))</p>
<p>Si Strictlly dominate/Very weakly dominate Si’: 对于其他人的任何行为S-i,U(Si,S-i) &gt;(=) U(Si’,S-i)  如果有一个策略比任何其他策略都好，那么他叫dominant</p>
<p>纳什均衡：每个人都出自己的dominant</p>
<p>帕累托最优pareto optimality：</p>
<ul>
<li>因为在衡量全局好坏的时候，你不知道每个个体的效用函数是什么样子的，所以这就像你想提高你的回报，但是这回报是以一种你不知道汇率的不同外汇来分给每一个人。</li>
<li>如果一个outcome O at least as good as O’ 并且对于某些agent，他们strictly prefer O。这时我们就可以说O pareto-dominates O’ 如果一个outcome O 不能再被其他 O’pareto-dominates,那么就称他为帕累托最优。</li>
</ul>
<p>帕累托最优结果可能不唯一：可能有两个outcome谁也不比谁好<br>每个游戏至少有一个帕累托最优</p>
<p>mixed strategy：</p>
<ul>
<li>idea：confuse the opponent by play randomly</li>
<li>与pure strategy的区别就在于，同样是关于行动的分布，pure是只有一个行动的概率是1，其他都是零，而mixed则是有多个可能性大于0的行动</li>
<li>此时效用函数变成了多个小部分效用函数的加权均值</li>
</ul>
<p>纳什定律：Every Finite game has a Nash equilibrium. 有限的意思是总情况空间是有限的。有限的玩家*每人有着有限的行动集</p>
<p>mixed strategy equilibrium: 一个稳态，不过此时参与者并不是只选一种，而是按照某种概率选择多种方案。计算的方式是，先定其中一个人的概率，使得另一个人无论选哪种方案，都会得到一样的回报。（因为如果不一样的话，另一个人就没必要random，直接全部投入最优的解即可）解方程出来之后。再对剩下的人依次求解。最后获得一个平衡。</p>
<p>两个寻找纳什均衡的算法：</p>
<ol>
<li>LCP(Linear Complementarity) formulation(By Lemke-Howson)</li>
<li>Support Enumeration Method</li>
</ol>
<p>PPAD：Polynomial Parity Arguments on Directed graphs.<br>复杂度排序：P&lt;PPAD&lt;NP&lt;NP-complete</p>
<p>开始对支撑集做假设的时候，我们假设两个选手的可能取值差不多。而不是一人有两个方案，一个人有十七个方案。</p>
<p>correlated equilibrium</p>
<p>Rationality: A basic premise: Players maximize their payoffs</p>
<p>如何检查纳什均衡：看看两个玩家在当前条件下有没有动力改变自己的决策。纳什均衡=每个人都没有profitable deviation</p>
<h2 id="Iterative-Removal："><a href="#Iterative-Removal：" class="headerlink" title="Iterative Removal："></a>Iterative Removal：</h2><p>删去被最好行动压制的其他行动</p>
<p>A strictly dominated（被动） strategy can never be a best play, so we can remove it.</p>
<p>但是删掉一个被dominate之后，剩下的里面会再出来一个新的dominated，所以我们要不断的iterate。</p>
<p>不仅可以被pure strategy打败 被mixed打败也可以。所以在没有单纯的strictly dominant的时候，我们可以用组合策略来删除</p>
<p>dominant solvability：可以被最小迭代变成一个pure</p>
<p>对于strictly dominant来说 删除的order并不重要</p>
<p>但如果是weak的话，可能会在删的过程中也删掉一些纳什均衡，这时候order重要，但至少有一个纳什均衡会被保留下来。</p>
<p>两只猪的游戏：用来论证事实上猪也会博弈论</p>
<p>maxmin strategy: maximize worst-case payoff. </p>
<p>Maxmin value(safety level): the minimum payoff guarenteed by maxmin strategy.</p>
<p>minmax strategy: minimize enemy’s best-case payoff. 在零和游戏中，损人=利己</p>
<p>correlated equilibrium：A randomized assignments of (potential related) action ecommandations to agents, such that nobody wants to deviate.</p>
<h2 id="Extensive-Form"><a href="#Extensive-Form" class="headerlink" title="Extensive-Form"></a>Extensive-Form</h2><p>有时，时间也影响着决策。Game Tree:人们轮流采取行动，最后会终结在树的某一个节点上。</p>
<h3 id="Perfect-Information"><a href="#Perfect-Information" class="headerlink" title="Perfect Information"></a>Perfect Information</h3><ul>
<li>参数：N、A、H、Z、chi、rho、sigma、u</li>
<li>N：players。</li>
<li>A: Actions（这时每个人能采取的行动是一样的）</li>
<li>H：choice nodes:  non-terminal</li>
<li>chi: Action-function 将H映射到2^A assign actions to each node</li>
<li>rho: Player-function: assign player to non-terminal node</li>
<li>Z: terminal nodes</li>
<li>sigma: sucessor function 将H*A 映射到H并Z</li>
<li>u: utility function. 对每一个Z映射一个得分</li>
</ul>
<p>注意这棵树是单射。不存在多个节点或者一个节点的多个行为指向到同一个结果</p>
<p>在计算pure strategy 个数的时候，就连那些肯定到不了的节点也要算进去。因为博弈论认为到不了的A和到不了的B也是不一样的</p>
<p>定理：Every perfect information game in extensive form has a PSNE(Pure Strategy Nash Equilibrium)</p>
<h4 id="Induced-Normal-Form"><a href="#Induced-Normal-Form" class="headerlink" title="Induced Normal Form"></a>Induced Normal Form</h4><ul>
<li>将A与B的pure strategy做一个笛卡尔积。树的很多根节点被重复了多次，在树很大的时候会造成指数的数据上涨，不好</li>
<li>并且我们一般不能把一个Normal Form Game变成一个Extensive Form Game。因为有时候Game就是需要两个人同时发出动作，但是Extensive是有先后顺序的</li>
</ul>
<h4 id="Subgame-perfection"><a href="#Subgame-perfection" class="headerlink" title="Subgame perfection"></a>Subgame perfection</h4><ul>
<li>在一个perfect information game 的某个纳什均衡决策中，所有的子决策族都没有profitable deviation。</li>
<li>Backward Induction: 在零和游戏中又被称为minimax。在每个节点处以自己孩子点中最大值作为自己的值</li>
<li>Ultimate Bargaining：举得例子是10份东西两个人分。A提出一个分法，B同意的话就按照这个方法分，B不同意的话两个人都是0。这种情况下A的最好策略应该是9/1 但事实上很多人选择了5/5。有可能是因为总体太小了。当研究人员把总体调的越来越大的时候，人们倾向于给对方更小的比例，并且对方也倾向于接受更小的比例</li>
</ul>
<h3 id="Imperfect-Information"><a href="#Imperfect-Information" class="headerlink" title="Imperfect Information"></a>Imperfect Information</h3><p>玩家不知道对手的全部行动</p>
<ul>
<li>equivalence class：将不同的node分成几个类，这样虽然不知道具体是来自哪一个node，但是我们知道它们不来自于哪些nodes</li>
<li>可以将IIEF-NF-IIEF：开始的IIEF可能会很深，但是变成Normal-Form在变回IIEF的时候，IIEF只有两层了。虽然两个IIEF可能长得不同，但是它们的行动空间是一样的。</li>
</ul>
<h4 id="Imperfect-Recall"><a href="#Imperfect-Recall" class="headerlink" title="Imperfect Recall"></a>Imperfect Recall</h4><p>玩家无法回忆自己曾经选择的node具体是哪一个</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>MOOC</category>
      </categories>
  </entry>
  <entry>
    <title>travel</title>
    <url>/2020/08/17/travel/</url>
    <content><![CDATA[<p>这里记录曾旅游过的地方以及评价，按照首字母排序。</p>
<a id="more"></a>



<h1 id="麦迪逊"><a href="#麦迪逊" class="headerlink" title="麦迪逊"></a>麦迪逊</h1><h2 id="Pheasant-Branch-Conservancy"><a href="#Pheasant-Branch-Conservancy" class="headerlink" title="Pheasant Branch Conservancy"></a>Pheasant Branch Conservancy</h2><p><img src="https://i.imgur.com/WVScrK3.png" alt=""></p>
<p><img src="https://i.imgur.com/JeKQMGD.jpg" alt=""></p>
<ul>
<li>推荐指数6分</li>
<li>从中间的小路开始，，走了北部环线。刚下车迎面而来的就是屎的味道… 夏天的时候温泉池冒泡泡但是没太大意思。期间我们走了两条很窄的小路，地上还有一只死鸽子…小虫乱飞。用老姚的话说，这公园太野了。爬到山顶，豁然开朗，微风习习，算是今日的亮点</li>
<li>我感觉或许这才是自然的样子吧…有些公园环境过好，很舒适，不过有些不太真实。我喜欢说自己很热爱亲近自然，或许有些伪善在里面。这个公园就很「自然」，不过当我真正「亲近」的时候却又收回了手。希望会像爱情一样，终有一天，我会爱上她本来的模样。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
        <category>餐馆</category>
      </categories>
  </entry>
  <entry>
    <title>心理学</title>
    <url>/2020/08/18/%E5%BF%83%E7%90%86%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>读书笔记开的过多就有点看不过来了…所以想把读书笔记都放到一起来。我想，若是好好读书，iPad还是不如电脑，电脑还是不如纸质。</p>
<p><strong>书目名单：</strong></p>
<ol>
<li>自卑与超越</li>
</ol>
<a id="more"></a>



<h1 id="自卑与超越"><a href="#自卑与超越" class="headerlink" title="自卑与超越"></a>自卑与超越</h1><h2 id="第七章-学校的影响"><a href="#第七章-学校的影响" class="headerlink" title="第七章 学校的影响"></a>第七章 学校的影响</h2><blockquote>
<p>但是，工业革命的兴起，使社会对人类的要求越来越高，即使工计算、画图。也正是从那时开始，现代化的学校才有了雏形。</p>
</blockquote>
<ul>
<li>霍，所以是为了培养更好的工匠</li>
</ul>
<blockquote>
<p>如果对一个不想融入学校环境的孩子进行训斥和惩罚，就会给孩子一种错觉：我想的没错，学校果然是令人讨厌的地方。以我所见，如果我在学校常常受到老师的惩罚和训斥，肯定不会再愿意和老师碰面，也会尽力让自己逃脱这种环境，不受学校的束缚。</p>
</blockquote>
<blockquote>
<p>走出校园，他们就会和其他逃学的孩子混在一起，在这里他得到的赞扬总是多于在学校的。所以，和他们在一起，他会有一种成就感，认为能够显现自己价值的地方不是学校，而是在他们这个群体中。从中我们就了解了，那些在班里被人看成另类的孩子为什么总是容易被犯罪分子诱骗。</p>
</blockquote>
<blockquote>
<p>在现行的教育模式下，我们常常发现，孩子在刚刚进入学校之时，<strong>心理上对于竞争的准备远远比合作的准备充足。</strong>这种竞争的思想在孩子上学的全过程都会存在。这并不是一个好的现象，如果那些优秀的孩子超过了其他孩子，并不能代表他就比那些成绩不佳的孩子痛苦少。这都是由他们个人的自私心理造成的。他们的<strong>目的并不是合作和贡献，而是获得自己的利益。</strong></p>
</blockquote>
<blockquote>
<p>有的人可能怀疑孩子们是不是真的可以理解并帮助他人，<strong>但是我却认为，孩子们比长辈更能理解他们同龄人的心情。</strong>我曾接待过这样一家人，一个母亲带着一个三岁的男孩和一个两岁的女孩。女孩爬上了桌子，妈妈吓得不敢动弹，颤抖着声音说：“快点下来！”可是，女孩没有任何反应。这时，小男孩上前说道：“站在那里，不要乱动！”结果女孩却主动爬了下来。因为孩子更能理解自己需要的是什么，这种要求是不为长辈所知的。</p>
</blockquote>
<blockquote>
<p><strong>在学校里常常有这样一种现象，优等生、中等生和劣等生的成绩、名次总是在自己的范围内徘徊不变。其实这并不是什么天生遗传的因素所致，而是因为他们的思想束缚了自己的能力，他们以为自己就是这样的人，永不能进步，也永不会后退。</strong>我们也会看到这种情况，即原来的差生会在一段时间内突然间跃入优等生的行列。所以，我们应该让孩子明白，是自己的思想束缚了自己的发展，老师和孩子都不应该拿这句话来作为理由：遗传决定着一个人的智力和能力。</p>
</blockquote>
<blockquote>
<p>智力的遗传亦是如此。我们已经知道，<strong>兴趣是影响智力发展的最大因素，然而影响兴趣的因素并非遗传，而是缺乏自信和害怕失败。</strong></p>
</blockquote>
<blockquote>
<p>懒惰的孩子还有一点好处：即使取得一点小小的成功，也会得到别人的称赞。<strong>人人都希望这些赞扬成为激励他们取得更大成功的动力，所以不住地给予他们夸奖</strong>，但是如果同样的成就发生在勤奋的孩子身上，也许并没有人会在意。所以，<strong>懒惰的孩子就这样在别人的期待中生活。</strong>他们从小就形成依靠他人的习惯。</p>
</blockquote>
<blockquote>
<p>有时，一个孩子总是以领导的身份指派家人做这做那的时候，<strong>人们总是觉得很好玩，并任其发展下去。</strong>可是，我们很快就会发现，这种做法对培养良好的性格并无益处，也不利于他们融入社会。</p>
</blockquote>
<blockquote>
<p>我个人认为，在几年之内孩子都跟随一个老师，对孩子是极为有利的。有些学校，一个学期就要更换一次老师，<strong>这样就使得老师无法真正融入到孩子中间，也不能发现孩子身上的问题，纠正错误就更无从谈起了，这样对孩子的成长极为不利。</strong>如果在三四年的时间里孩子们都跟随一个老师，那么老师就可以纠正他们的错误并帮助他们培养正确的人生态度，这样的班级也会更加团结。</p>
</blockquote>
<blockquote>
<p>一般来说，跳级并不是一个好现象，这样会将更多超出现实的愿望压在孩子身上。如果班里的某位同学年龄长于他人或者智力发展较快，我们往往想到让他跳级。可是，如果这个班级原本很团结，<strong>这个凸显优秀的孩子就会对带动其他孩子有很大的益处，也会让其他孩子突飞猛进地发展。</strong>但是，如果将这个孩子调离班级，显然对班里的其他孩子并不公平。我想建议这些出类拔萃的孩子课外去参加一些其他的培训，比如画画等。他在这些方面取得成就的话也会带动其他孩子在这方面的兴趣，从而激励他们发展前进。</p>
</blockquote>
<h2 id="第八章-青春期的引导"><a href="#第八章-青春期的引导" class="headerlink" title="第八章 青春期的引导"></a>第八章 青春期的引导</h2><blockquote>
<p>青春期对每个孩子而言，最主要的就是证明自己已经长大。如果我们真正能够使他相信这是水到渠成之事，就可以减轻其很多压力。如果非要迫切证明自己的成熟，他们就会不可避免地将自己的意图强烈地表现出来。</p>
</blockquote>
<blockquote>
<p>那些在家中自认为被人忽视的孩子，如果与人建立了友谊，就非常希望得到别人的称赞。他们会不断寻求这种称赞。如果男孩子表现出这种情形，将是很危险的。如果是女孩，她们会失去自信，在她们看来，只有得到别人的称赞才能表现出自己的价值，她们很容易对那些大献殷勤的男人投怀送抱。我见过很多这样的事例，<strong>有些女孩在家中不受父母的宠爱，往往很早就有了性行为，这样做不仅表明自己已经长大，更表现了她们的爱慕虚荣，她认为这样可以赢得别人的关注和赞许。</strong></p>
</blockquote>
<blockquote>
<p>所以，我经常看到一些女孩子们和母亲吵架后跑出来发泄，和他遇到的第一个男人发生性关系。这些孩子平时表现得很乖，家教也不错，我们几乎不敢相信她们会有这样的行为。然而，错误也不能全归于女孩身上，只不过是思想上的误解：她们认为自己被家人忽视，低人一头，似乎只有这样才能体现出她的优势。</p>
</blockquote>
<ul>
<li>这些男人也觉得OK…些许离谱</li>
</ul>
<blockquote>
<p>不少孩子到几岁之后，还有些弄不明白，自己的性别以后会不会得到转变。所以，在孩子两岁的时候，你要明确地告诉他自己是男孩还是女孩，这是极其重要的。</p>
</blockquote>
<blockquote>
<p>父母对自己的孩子进行抚摸或亲吻是表达爱和关心的一种方法，但是不要去碰触孩子的敏感部位以免引起不正常的反应。所以在抚摸孩子的身体时，要多加小心。此外，有些孩子甚至成人会提到，在父亲的书房中发现了一些色情或露骨的图片，从而引起了某种情感。所以，如果不想让孩子产生我之前所讲的问题，就要避免让他们看这些色情图片或影片，不要引起他们的性欲望。</p>
</blockquote>
<h2 id="第九章-犯罪及预防"><a href="#第九章-犯罪及预防" class="headerlink" title="第九章 犯罪及预防"></a>第九章 犯罪及预防</h2>]]></content>
      <categories>
        <category>Books</category>
        <category>心理学</category>
      </categories>
  </entry>
</search>
