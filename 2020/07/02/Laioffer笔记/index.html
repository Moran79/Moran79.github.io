<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"moran79.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍参加了Laioffer 2018年底11月的Data班，整理了一下学习笔记。Laioffer学费不菲，但是提供的思路还行。像其他网课一样，我一如既往的虎头蛇尾，兴趣全无。">
<meta property="og:type" content="article">
<meta property="og:title" content="Laioffer笔记">
<meta property="og:url" content="https://moran79.github.io/2020/07/02/Laioffer%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="大家一起来">
<meta property="og:description" content="介绍参加了Laioffer 2018年底11月的Data班，整理了一下学习笔记。Laioffer学费不菲，但是提供的思路还行。像其他网课一样，我一如既往的虎头蛇尾，兴趣全无。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNbRwgy1fy2mq8lcomj31680kmtei.jpg">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Bucket_sort_1.svg/320px-Bucket_sort_1.svg.png">
<meta property="article:published_time" content="2020-07-02T15:19:20.000Z">
<meta property="article:modified_time" content="2020-07-02T16:43:55.079Z">
<meta property="article:author" content="大连铁板王">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ws4.sinaimg.cn/large/006tNbRwgy1fy2mq8lcomj31680kmtei.jpg">

<link rel="canonical" href="https://moran79.github.io/2020/07/02/Laioffer%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Laioffer笔记 | 大家一起来</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">大家一起来</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://moran79.github.io/2020/07/02/Laioffer%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="大连铁板王">
      <meta itemprop="description" content="分享笔记——实践费曼学习法">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大家一起来">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Laioffer笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-02 11:19:20 / 修改时间：12:43:55" itemprop="dateCreated datePublished" datetime="2020-07-02T11:19:20-04:00">2020-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study/Courses/" itemprop="url" rel="index"><span itemprop="name">Courses</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study/Courses/Laioffer/" itemprop="url" rel="index"><span itemprop="name">Laioffer</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参加了Laioffer 2018年底11月的Data班，整理了一下学习笔记。Laioffer学费不菲，但是提供的思路还行。像其他网课一样，我一如既往的虎头蛇尾，兴趣全无。</p>
<a id="more"></a>



<h1 id="课程问题"><a href="#课程问题" class="headerlink" title="课程问题"></a>课程问题</h1><p>课下时间：至少70%放在python coding。课下不需要看统计知识</p>
<p>机器学习：</p>
<ol>
<li>告诉老板，我们大概有5%的人要退订服务了</li>
<li>告诉老板，不知道有多少人会退订服务，但是可以告诉你为什么这些人要退订服务</li>
</ol>
<p>如果P值等于0.05：</p>
<ol>
<li>因为0.05是type1，所以可以反问为什么我们要把犯一型错误的概率定在0.05？如果很严重的话我们可以定的再小一点，如果不在乎的话可以定的大一点。</li>
</ol>
<p>MLE在什么时候不work:</p>
<ol>
<li>样本量太小会有问题。【100万人中求样本方差/样本均值，但是只有一个观测值】【均匀分布的估计】</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>问：选定模型需要理由吗？</p>
<p>答：根据不同的Assumption会有不同的模型</p>
<p>问：所有loss-function都是关于$\epsilon = y-\hat{y}$</p>
<p>答：有些模型写不出来loss-function（比如Tree-based）。但是如果能写出loss的，都是要优化xxx，就会跟error有关系。</p>
<p>问：均值和期望不同吗？</p>
<p>答：mean和expectation两者是完全不同的概念. 即使对应的数值一样，他们表达的意义是完全不同的. 简单地说, <strong>mean是针对实验样本来讨论的统计量, 是与具体数据有关的</strong>, 你的数据不同，Mean就不一样. 而<strong>expectation是对一个随机变量的数学特点的描述</strong>, 它更多表达的是在样本无穷的情况下会体现出的特点. 无论你某一次的样本数据是什么样，无论你某一次计算出来的mean多么不靠谱, 这个随机变量的expectation应该都是不变的. 但是如果你可以找到整个Population的所有情况来计算mean (这件事应该是不可能发生的), 那么它应该与expectation是一样的.</p>
<p>问：为什么线性回归的loss用平方？</p>
<p>答：直接对应线性方程<strong>噪声的高斯假设</strong> 。如果写出来似然函数然后用MLE的方法, joint pdf :<br>$$<br>f(y_1,…y_n|x_1,…x_n) = (\frac{1}{\sqrt{2\pi}\sigma})^nexp{-\frac{1}{2\sigma^2}\sum(y_i-x_i\beta)^2 }<br>$$<br>会发现最后的部分是平方损失，而MLE就是让那部分最小。</p>
<p>做题写代码之前，先想一些特殊的（test）case，让自己的code至少可以满足我们能想到的case。</p>
<p>一般的证明算法正确的方法：数学归纳法</p>
<p>问：<strong>L1 L2 loss的区别以及应用场景：</strong></p>
<p>字典的空间复杂度：key + value</p>
<p>Q: 如何解决Confounder：</p>
<p>A: 如果是regression model的话，要把可能的confounder都包含在model里；如果是two group test的话，要matching on confounder或者segment by confounder。</p>
<p><a href="https://joyeuserrance.wordpress.com/2011/04/22/proof-that-p-values-under-the-null-are-uniformly-distributed/" target="_blank" rel="noopener">P-values under the null are uniformly distributed</a></p>
<h1 id="广泛的知识"><a href="#广泛的知识" class="headerlink" title="广泛的知识"></a>广泛的知识</h1><p>机器学习的能力范围：</p>
<ul>
<li><p>给定一个x，并不能给定一个具体y【这也是为什么模型会犯错误】其实给的是y的一个分布【第一步】。然后我们再从y的分布中获得一个y的具体值【第二步】。</p>
</li>
<li><p>所以有的时候结果不好，可能模型是对的，并且已经做到了极限。是我们自己搞砸了第二步</p>
</li>
</ul>
<p>模型不能脱离与数据而存在【不能单独讨论好坏】</p>
<p>理解：考试成绩[error] = 平均水平[bias2]+某次具体发挥[var]</p>
<ul>
<li>Bias表示的是大量实验中的平均偏差[model在训练数据有稍微变化下的平均输出结果与真实值相比，得到的平均准确性]</li>
<li>Var更强调的是某一次出现的偏差[某一次model的数据结果与这个model的平均水平的差距 的平方的期望]</li>
<li>Bias和Variance是无法被计算的</li>
<li>模型越复杂，var越大。因为提取的信息不具有代表性，数据和模型之间的gap就会越来越大</li>
<li>女娲造人。先骨骼再填肉。骨骼就是model的assumption，填肉就是不同的training data. 每个靶图都是很多次不同的填肉，然后再观测眼睛的颜色。</li>
<li>Jason认为$\lambda$ 属于骨架的一部分，虽然他是个参数… </li>
</ul>
<p>我们最小化training error 是<strong>暗含了一个假设</strong>：最小化training error就是最小化testing error。但这个<strong>假设不成立</strong>，这也是过拟合的来源。我们发现过拟合的时候造成不稳的原因是var比较大，所以我们可以加一项来<strong>控制方差：Regularization</strong></p>
<p>Ridge Regression: L2-penalty    LASSO: L1-penalty<br>实际用的时候LASSO不是很稳定，作为最大缺点，二阶在工业界更常用</p>
<p>CV：</p>
<ol>
<li>可以用来hyperparameter tuning，来选$\lambda$ [grid search/ random search]</li>
<li>可以来 validate model selection 【只能选定某一种模型，而决定不了参数】</li>
</ol>
<p>Encoding 的方式：</p>
<ul>
<li>Label-Encoding 把factor变成数字 ordinal的情况</li>
<li>One-Hot-Encoding</li>
</ul>
<p>问：如何判断两个连续变量是否独立？</p>
<p>答：把连续变量离散化，根据range划分成小格子</p>
<p>问：如何判断一个连续一个离散变量是否独立？</p>
<p>答：试着去证明两个CDF是一样的。KL-divergence</p>
<p>Map-Reduce存在的问题：</p>
<ul>
<li>多个任务串联的时候，需要将中间文件写入磁盘，又得读出来。比较慢。</li>
</ul>
<h1 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h1><p>线性回归的线性到底如何定义？指数分类组？</p>
<p>问：为什么选择残差平方作为loss，为什么不是四次方？</p>
<p>答：好像跟什么高斯分布有关系？</p>
<p>问：为什么不用垂直距离做误差？</p>
<p>什么叫OA？</p>
<p>什么是Backtracking？公共课Class40讲了</p>
<h1 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h1><p>线性回归$y = ax+b$ </p>
<ol>
<li>如果给一个点，欠定方程under-determined equation</li>
<li>两个点：适定方程well-determined equation</li>
<li>多个点：<strong>超定方程over-determined equation</strong></li>
</ol>
<p><strong>五个Assumption: ？？？</strong></p>
<p>关于factor的coding有很多种，不仅有one-hot-coding.(Label encoding/<strong>target encoding</strong> 比较fancy)</p>
<p>One-hot-encoding: 保证了各个factor之间的距离都是一样的（$\sqrt{2}$）<br>    followup：等边三角形也保证了三个factor距离一样啊，并且还是二维的<br>    答案：one-hot-encoding 想要的更多的是方便interpret</p>
<pre><code>followup:出现了很多里面没有的新类别该怎么办
答案：1.新增一个other列

followup：如果有一个class有非常多的值，还可以做one-hot-encoding吗？
答案：产生原因：Feature过多的时候，overfitting（需要更多的数据）
    解决办法：1. 其他encoding（frequence-based encoding）
            2.做个聚类，重新用更小的类别数字代替原先的class</code></pre><p>问题：为什么不能直接将ABC三个班级code成为123？<br>答案：这个model基于距离的（线性模型就是）。但是概率模型（比如Tree-based）就没事</p>
<p><strong>朴素贝叶斯：</strong> 是否是花？ 给定feature (F1,…Fn) 现在要求花是哪一类？需要计算P(C|F1,…Fn) 但是这些Feature同时出现的情况可能不存在。<br>Assumption: P(Fi|C) 和 P(Fj|C)是独立的【条件独立】<br>实际例子：Fraud Activity Detection, 为了分类</p>
<p>统计中的随机性（randomness）：</p>
<ul>
<li>每一次出现都是随机的不可预测的</li>
<li>这些随机的背后<strong>存在着特定规律</strong> （所以如果一个参数属于某个参数空间，传统统计中认为就不属于随机变量）【参数不是随机变量】</li>
<li>不是所有不知道的量都是随机变量</li>
</ul>
<p>如何用random(5)[取值0,1,2,3,4]实现一个random(25)？</p>
<ul>
<li>可以把它写成一个方块，看成面积, $5X_1+X_2$</li>
<li><strong>random(7)怎么办?</strong></li>
</ul>
<p>CLT的来源背景：大量相互独立的叠加，并且<strong>每部分对在综合影响中所起的作用差不多</strong>。</p>
<p>为什么正态的误差服从正态分布？我觉得是因为好算F或者t之类的检验，Jason说有可能是因为我们认为大自然的噪声是独立同分布的，所以他们叠加是一个正态….</p>
<p>高斯假设是关于$\epsilon$ 的，或者是关于$y|x$ .</p>
<h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><p>当y是离散的时候，为什么不能用linear regression？<br>遇到的问题：</p>
<ul>
<li>y|x的分布不符合高斯分布</li>
</ul>
<p>解决办法：</p>
<ul>
<li>将y=0/1 变成0~1的概率p，再用线性拟合</li>
</ul>
<p>遇到的问题：</p>
<ul>
<li>很远的地方的数据会变成leverage point，将线拉的很扁。【可以思考赋予leverage点不同的权重】很确定的点可以小一些权重，而那些模糊区/0和1交叉点的地方需要给一些大的权重。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>变成一条折线，早早的就到了1然后一直是平的。【图形角度入手】发现logistic正好符合sigmoid形式，并且指数组也有很多好性质</li>
</ul>
<p>【从值域的角度理解】</p>
<p>开始的是离散的0和1，我们假设服从伯努利分布Ber(p)变成probability属于[0,1]，然后变成odds$\frac{p}{1-p}$ 属于[0,inf] ,然后$log(\frac{p}{1-p})$ 属于[-inf,inf] </p>
<p>多分类问题可以用</p>
<ol>
<li>one vs all</li>
<li><strong>softmax</strong></li>
</ol>
<p>局限性：仅支持一种非线性。</p>
<p>loss function，通过似然函数（joint pdf）计算出来：<br>$$<br>min\ log(p) = \sum_{i=1}^n[-y_ilog(\frac{1}{1+e^{-\beta x}})-(1-y_i)log(1- \frac{1}{1+e^{-\beta x}})]<br>$$<br>Sss</p>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>二分查找/折半搜索，针对已经排好序的序列。</p>
<p>用两个指针left和right进行操作，每次都比较mid = (left+right)/2 和目标值</p>
<p>时间复杂度log(N) 空间复杂度 constant（每次只在操作left right mid 三个指针）</p>
<ul>
<li>如果mid &lt; target, left = mid + 1</li>
<li>如果mid = target, 找到了</li>
<li>如果mid &gt; target, right = mid -1</li>
<li>如果left &gt;= right，就退出。如果left = right = target就返回left/right，如果不等于就退出。</li>
</ul>
<p>如果是多维的情况，也变成一维的情况，用两个指针来做。</p>
<p>Followup1: 寻找数列中最接近某个数值的数的index:</p>
<ul>
<li>此时，原本的 left = mid + 1/ right = mid -1 就要变成let = mid/ right = mid 因为保不齐目前这个mid虽然不是答案，但是是和答案最近的那个，所以不能轻易抛弃他</li>
<li>但是这样的话有时候会进入死循环，因为mid根本不变。所以至少保证三个数再开始跑，<strong>left &lt; right - 1</strong></li>
<li>并且需要<strong>postprocessing</strong>， 因为循环结束的时候，两个指针有可能不重合，而是距离为1，所有要对left和right再检测一遍</li>
<li>python三目运算符：<code>return left if 左小于右 else right</code></li>
</ul>
<p>Followup2: 寻找数列中最先出现某个数的index:</p>
<ul>
<li>要用followup1的判断方法: left &lt; right - 1 为什么呢？</li>
<li>如果mid &lt; target, left = mid。否则， right = mid</li>
<li>最后postprocessing, <strong>先检测left</strong>，再检测right。【反过来不行，因为我们要返回第一次出现的index】</li>
</ul>
<p>Classic判断方法：left &lt;= right. 变种：left &lt; right - 1. 判断是否可以用classic就是看循环中有没有mid = right 或者 mid = left 这种危险语句</p>
<p>Followup3: 寻找数列中最后出现某个数的index:</p>
<ul>
<li>跟2差不多</li>
<li>如果mid &gt; target, right = mid。否则， left = mid</li>
<li>最后postprocessing, <strong>先检测right</strong>，再检测left。</li>
</ul>
<p>Followup4：Search in rotated sorted array:</p>
<ul>
<li>rotated sorted array就是原本一个有序的数列，从中间砍成两半，然后调换他们的位置</li>
<li>有个好性质，那就是无论切掉几部分，剩下的拼起来还是一个rotated sorted array</li>
<li>通过left right 和mid的相对大小来确定mid左面/右面是一个sorted array</li>
</ul>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><p>线性数据结构</p>
<p>Linked List在内存中不一定是紧密相连的（不需要）</p>
<p>单链表：特点是链表的链接方向是单向的…只能访问下一位。单链表的定义还包括有头有尾，最后一个node.next = None 不会出现首尾相连的情况</p>
<p>Linked List 包含</p>
<ul>
<li>一个数据域，存放了数据</li>
<li>一个链域，存放了链表下一个地址位置</li>
</ul>
<p>刚开始创建的时候，self.next = None 因为还没有被链进链表…而在创建节点的时候肯定需要给一个val。所以init(self,val)就可以了</p>
<p>做swap的时候有时候想改变Node的val，但这样其实不符合职业操守，建议把val看成read-only</p>
<h2 id="Singly-Linked-List"><a href="#Singly-Linked-List" class="headerlink" title="Singly Linked List"></a>Singly Linked List</h2><h3 id="遍历Traverse"><a href="#遍历Traverse" class="headerlink" title="遍历Traverse"></a>遍历Traverse</h3><p>问：关于为什么这个函数要写成在class外面的free function而不写在class里面？</p>
<p>答：我的理解是因为Traverse这个功能<strong>并不是针对某一个具体的链表而设定的</strong>，所以不应该被定义在某个class的内部。定义成free function，也还可以遍历其他的链表。</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>添加元素的话一定要返回头结点head，要不然修改会找不到【如果在头前面加的话，没办法知道新的head】</p>
<p>要加fakehead，因为<strong>头结点不存在前驱节点</strong>，万一要在0位置操作的话</p>
<p>可以插入<strong>fake_head</strong>，整个代码清晰起来，因为所有节点都存在了前驱节点</p>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>如果删除之后将node.next = None,就会直接被Garbage collection清除掉。因为它没有被任何node指向，也没有指向任何node。</p>
<p>要加fakehead，因为<strong>头结点不存在前驱节点</strong>，万一要在0位置操作的话</p>
<h3 id="Merge-two-sorted-linked-list"><a href="#Merge-two-sorted-linked-list" class="headerlink" title="Merge two sorted linked list"></a>Merge two sorted linked list</h3><p>要添加fake_head 效果很棒</p>
<p>我开始想每次都新建一个listnode，但这样会使得空间复杂度为O(N1+N2)。所以用指针操作比较好，差距还是挺多的</p>
<p>时间复杂度O(N1+N2)；空间复杂度O(1) </p>
<h3 id="Find-middle-node-in-singly-linked-list"><a href="#Find-middle-node-in-singly-linked-list" class="headerlink" title="Find middle node in singly linked list"></a>Find middle node in singly linked list</h3><p>先问一下面试官，如果长度是2K，middle node的定义是什么？</p>
<h2 id="Doubly-linked-list"><a href="#Doubly-linked-list" class="headerlink" title="Doubly linked list"></a>Doubly linked list</h2><p>增添删除操作都是locally</p>
<p>但是还是需要fake_head 解决头结点不存在而需要特殊讨论的问题</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><code>fake_head.next = head; head.prev = fake_head</code> 注意一定要加上head.prev 这句话也要加上。并且在return之前要加上：<code>fake_head.next.prev = None; return fake_head.next</code></p>
<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><p>用<u><strong>归约</strong></u>来解决问题</p>
<p>一个小🌰：斐波那契Fibonacci Sequence：找第n位的元素</p>
<ol>
<li>建立一个list来存放所有的数据<ul>
<li>时间复杂度：O(n) 空间复杂度：O(n)</li>
</ul>
</li>
<li>用两个数字去模拟过程，a,b = b, a+b<ul>
<li>时间复杂度：O(n) 空间复杂度：O(1)</li>
</ul>
</li>
<li>Recursion：定义两个基础case F(0) = 0; F(1) = 1</li>
</ol>
<p>递归一个好处：</p>
<ul>
<li>平铺直叙，怎么想的，基本上代码就是怎么写，顺序都一样</li>
<li>有些问题用递归来写很清晰，实现起来很快</li>
<li>虽然一般来说性能可能没有直接写好，但是我们可以在实现之后再修改。</li>
</ul>
<p>Recursion 一个重要的点在于：找到<strong>Base Case</strong></p>
<p>对于递归传递参数我一直有个误区：<strong>结果传递到了哪里</strong></p>
<ul>
<li><p>其实无论是一个数还是一个数据类型，都需要准确的传递地址。一个数的话，一般在函数外先定义，然后函数内部加一行<code>global x</code> 。</p>
</li>
<li><p>如果是List的话应该不用global 因为地址是可以被查找的。</p>
<p><strong>一个有趣的错误：</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,y)</span>:</span></span><br><span class="line">        self.x += y</span><br><span class="line">        <span class="keyword">return</span> self.x</span><br><span class="line">s = Solution()</span><br><span class="line">s.add(<span class="number">3</span>) <span class="comment">#打印出来3</span></span><br><span class="line">s.add(<span class="number">5</span>) <span class="comment">#打印出来8</span></span><br></pre></td></tr></table></figure>

<p>这时候相当于用到了global变量，而global变量被存了起来。有一种解决办法是每次都重置这个global变量，但是如果频繁调用<code>s = Solution()</code> 看起来微蠢，可以写一个wrapper包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ResultWrapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max = <span class="number">-1</span></span><br><span class="line">        self.solution = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span>:</span></span><br><span class="line">    res = ResultWrapper()</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> res.solution</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>判断是否是二叉排序树：</p>
<ol>
<li>从上到下传递range</li>
<li>中序遍历 + 用一个global最大值</li>
<li>从下往上传递左右子树最大最小值 + 左右子树是不是BST</li>
</ol>
<h2 id="reverse-singly-linked-list"><a href="#reverse-singly-linked-list" class="headerlink" title="reverse singly linked list"></a>reverse singly linked list</h2><p><code>head.next.next = head</code> 这一步好强啊</p>
<p><strong>有一个重要思想</strong> 我们对于多个点的变量（比如<code>node.next.next.prev</code>），一定要看他会不会是None，如果可能会是的话，我们提前加一个判断，以及情况处理。</p>
<p>感觉这个算法厉害之处在于…recursive的部分不影响原来的head部分… 可以通过head.next 来获取<strong>recursive链表的最后一位</strong></p>
<h1 id="Non-linear-Models"><a href="#Non-linear-Models" class="headerlink" title="Non-linear Models"></a>Non-linear Models</h1><h3 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h3><ul>
<li>True Positive 这里的True指的是说的错没错。Positive指的是猜的是1还是0</li>
<li>Precision：在你说的正确里面，有多少是真正正确的。（你给出的答案，准确率是多少）</li>
<li>Recall：所有positive里面，有多少被找到了（召回了多少）。<strong>recall = 曹操</strong></li>
<li>accuracy：两种正确/四种情况</li>
<li>F1-value = precision 和 recall 的调和平均数</li>
</ul>
<p>如果是守旧的人，不希望的事情是spam folder里面有重要文件，而可以忍受spam进入邮箱。那么此时分类的时候就是重视recall而觉得precision没那么重要</p>
<h3 id="ROC-curve"><a href="#ROC-curve" class="headerlink" title="ROC curve"></a>ROC curve</h3><ul>
<li>用logistic的时候我们采用了人为的threshold。而采用这个可以直接反映数值</li>
<li>我们不想人为引入threshold</li>
<li>model不变，testing数据也不变。women画出一个随着threshold变化的准确率曲线</li>
<li>对于imbalance class也可以用</li>
<li>蓝色阴影面积决定了好坏。最差0.5（random），最好1。因为如果小于0.5的话，我们取个反就变成一个大于0.5的好分类器了</li>
<li>这个概率的解释：<strong>真实值排在错误值前面的概率</strong>（positive example is <strong>ranked</strong> more highly than a random chosen negative example）</li>
</ul>
<h3 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h3><p>以前机器学习，只能convex才可以做。现在non-convex也可以做（比如神经网络）</p>
<p>目的：使得总体混乱程度降低</p>
<p>ID3用了Entropy：$I_e = -log_2p_i$  ; $H = \sum_{i=1}^n p_iI_e$</p>
<p>C4.5用了GainRate </p>
<p>ID3倾向于对那些有很多分类的变量给更高的关注</p>
<p>CART：Gini impurity</p>
<p>为什么说决策树不是线性模型？$X_i$ 对y的影响只取决于$X_i$  的大小以及他前面的系数，与其他X都无关。但是决策树还与他的位置有关（也就是变量之间的关系也很重要spliting and priority）</p>
<p>问题：强烈过拟合。</p>
<p>解决办法：</p>
<ol>
<li>预剪枝/后剪枝（pre/post-prunning）</li>
<li>Ensemble: 好多棵树一起做 <u>Bagging</u>/boosting(有点复杂)</li>
</ol>
<h3 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h3><p>一棵树容易over-fitting</p>
<p>解决办法：向模型中加入随机性</p>
<p>有放回的抽样——保证每个元素分布一样。选取的K一般是总共feature的平方向下取整</p>
<p>一般来说不需要pruning</p>
<p>Feature importance value in Random Forest: 但从这个公式里面看不出来影响的正负<br>$$<br>Importance(i) = performance(RF) - performance(RF^{random(i)})<br>$$<br>这个performance可以是MSE/Miss classification cost(用OutOfBag的方法，而不是在添加了这个变量之后的entropy变化)</p>
<h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p>Maximize the minimum margin</p>
<p>也可以做regression，对应的loss：hinge loss</p>
<p><strong>Intuition</strong> : 希望边界直线处，分界更加清晰</p>
<p>缺点：</p>
<ul>
<li>sparse的情况没有logstic好</li>
<li>正常分类没有random forest好</li>
</ul>
<p>优点：</p>
<ul>
<li>没有维度灾难，高维上依旧work</li>
<li>数学上完备</li>
</ul>
<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>没有training stage，上来就开始test</p>
<p>也可以做regression，对最近的N个取均值，但正常一般用来classification</p>
<p>K可以被视作一个超参数，无法通过求出来</p>
<p>有个大问题：每一个预测需要O(N)的时间【计算N对距离】<br>解决办法：以空间换时间，先存好不同颜色的几个区域，local-sensitive-hashing。这是一个approximate的方法，在边界的时候容易出问题</p>
<h1 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h1><p>先用PCA，但是PCA破坏物理意义</p>
<p>目的：</p>
<ol>
<li>为了减少overfitting</li>
<li>为了找寻重要的变量，去掉useless variable</li>
</ol>
<p>有时候一个团队可能会选择解释性好而准确性差一点的模型，因为如果哪一天黑箱模型闹脾气不工作了，谁也没办法…</p>
<p>工业届还倾向于多个model来做一件事情，而不是一个model。这样可以多个team一起合作</p>
<p>一个做法：去除变量之间相关性</p>
<ul>
<li>有人用correlation</li>
</ul>
<p>Ridge 倾向于把几个相关性高的变量系数取的一样。因为在a+b= constant 的时候，$a^2+b^2$ 最小就是a = b 的情况。 </p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>协方差越大能够增加信息量，在很容易变化的一个量上面，如果我们能给出一个具体的值，那么对不确定性的影响降得会最多</p>
<p>首先保证了原信息损失最小，副产品是去除了相关性。并不是奔着去除相关性去的</p>
<p>记得要scale</p>
<h1 id="K-means-聚类"><a href="#K-means-聚类" class="headerlink" title="K-means 聚类"></a>K-means 聚类</h1><p>分类问题：原来有类别，现在新的数据，我们需要知道它是属于哪一类</p>
<p>聚类问题：原先没类别，想知道谁和谁更加接近</p>
<p>具体操作过程：不停地更换中心</p>
<p>另一种LDA（Latent Dirichlet Allocation）</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序Bubble-Sort"><a href="#冒泡排序Bubble-Sort" class="headerlink" title="冒泡排序Bubble Sort"></a>冒泡排序Bubble Sort</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fy2mq8lcomj31680kmtei.jpg" alt=""></p>
<p>从第一位开始，相邻的比较大小并交换。第一次一定会将最大的数字移到队列最后面。比较了n-1次，第二次开始要比较n-2次…以此类推</p>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<h2 id="选择排序Selection-Sort"><a href="#选择排序Selection-Sort" class="headerlink" title="选择排序Selection Sort"></a>选择排序Selection Sort</h2><ul>
<li>In-place comparison sort. 不需要额外空间/需要很少额外空间</li>
<li>It has O(n^2) 复杂度，最好最坏都一样，但是比bubble需要的swap的次数更少</li>
<li>甚至比插入排序insertion sort 还要糟糕</li>
<li>When auxiliary memory is limited, 就可以选它了</li>
</ul>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><p>把第一个数字看成一个有序数列。从第二个数字开始，每次都在有序数列中找到自己的位置并插入。一个一个插入，直到原先全部的数字都被插入到了数列中。</p>
<p>原本硬写，时间复杂度：O(n^2) 空间复杂度：O(n)</p>
<h3 id="改进1："><a href="#改进1：" class="headerlink" title="改进1："></a>改进1：</h3><p>具体code的时候，关键点在于，要提前给那个等待插入的数字<strong>预留一个位置</strong>。所以如果想不增加额外的空间复杂度的话：</p>
<ul>
<li>循环从第二位开始走，<code>cur = lst[idx]; k = idx</code> k标记了预留位置</li>
<li>进入一个while loop：每次让lst[k] 跟lst[k - 1]比，如果发现前面更小就跳出while循环</li>
<li>如果前面更大，就把k-1位置的数字移动到k位置，此时空出来的位置是k-1位，所以我们令 k = k - 1</li>
</ul>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<p>这里的时间复杂度：需要n的时间找位置，需要n的时间来做swap： (n+n) * n个数字</p>
<h3 id="改进2："><a href="#改进2：" class="headerlink" title="改进2："></a>改进2：</h3><p>用binary search找插入的位置</p>
<p>时间复杂度：O(n^2) 空间复杂度：O(1)</p>
<p>这里的时间复杂度：需要log(n)的时间找位置，需要n的时间来做swap： (n+log(n)) * n个数字</p>
<h2 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序 Quicksort"></a>快速排序 Quicksort</h2><ul>
<li>When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.</li>
<li>It is not a stable sort, meaning that the relative order of equal sort items is not preserved.</li>
<li>Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</li>
<li>On average, the algorithm takes O(n log n) comparisons to sort n items. <strong>In the worst case, it makes O(n2) comparisons</strong>, though this behavior is rare.</li>
<li>Quicksort is a divide and conquer algorithm.</li>
<li>The pivot selection and partitioning steps can be done in several different ways; <strong>the choice of specific implementation schemes greatly affects the algorithm’s performance.</strong></li>
</ul>
<p>如何选择pivot？</p>
<ul>
<li>Lomuto partition scheme：选择最后一个<ul>
<li>This scheme degrades to O(n2) when the array is already in order.</li>
</ul>
</li>
<li>用随机数，然后跟最后一位换一下。防止一直出现最差情况</li>
</ul>
<p>优势在于：inplace-sort 每次return都是None 因为不需要创建新空间</p>
<p>时间复杂度：平均/最好 是O(Nlog(N)) 最差：O(N2) 但是概率超小【每次pivot都选出极值】</p>
<p>空间复杂度：O(log(N)) 都来自于recursion 最差情况是O(N) 【概率超小】</p>
<p><strong>写代码分为三步：</strong></p>
<ol>
<li>主函数quickSort(self, alist, left, right)，接受array 传递出quicksort(self, array,0, len-1) 并且还可以用来return </li>
<li>quicksort(self, alist, left, right): 接受左右位置，从partition函数中获得pivot，递归的主函数</li>
<li>partition(self, alist, left, right)：用random.randint(left, right) 来随机产生pivot的位置，进行分类，然后传递pivot的正确位置</li>
</ol>
<h2 id="归并排序-Mergesort"><a href="#归并排序-Mergesort" class="headerlink" title="归并排序 Mergesort"></a>归并排序 Mergesort</h2><p>排序中的王者</p>
<p>核心问题在于，两个长度为N的有序数列合并，复杂度的讨论:</p>
<ul>
<li>时间复杂度O(2*N) 遍历所有元素</li>
<li>空间复杂度O(2*N) 新建了一个数列</li>
</ul>
<p>归并排序的合并过程：每一次合并操作，都涉及到n个元素的合并，所以时间复杂度和空间复杂度都是O(N)。但是总共会合并log(N)次[层数]，所以时间空间复杂度都是O(Nlog(N))</p>
<p>归并排序的拆分过程：每个数字都被跑了一遍，产生了新的长度为N的array。总共有log(N)层</p>
<p><strong>空间复杂度：O(N+log(N)) = O(N)</strong> 来自于recursion和新产生的数组</p>
<ul>
<li><p>N来自于每一层产生的新数组，至于为什么不是Nlog(N) 因为每一层新产生的空间都会被回收掉，空间复杂度指的是 在程序运行的时候 某个时刻需要的最大空间 而不是累计使用了多大的空间【因为这种情况下累积不起来】</p>
</li>
<li><p>log(N)是来自于recursion。每深入一层，就会多一个O(1) 可以理解为【找个地方来存放要运行的代码】其实是存的是地址，要知道每个递归的开始点和结束点。从哪里出来的/回到哪里</p>
</li>
</ul>
<p><strong>Linked-List 版本的sort没有任何的优势</strong> 老师说只是为了让我们练练写代码</p>
<h2 id="Bucket-Sort-Bin-Sort"><a href="#Bucket-Sort-Bin-Sort" class="headerlink" title="Bucket Sort/ Bin Sort"></a>Bucket Sort/ Bin Sort</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Bucket_sort_1.svg/320px-Bucket_sort_1.svg.png" alt=""></p>
<h1 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h1><p>进队enqueue【安Q】 出队dequeue【弟Q】</p>
<p>实际意义：排队</p>
<p>用链表比较好，因为如果用list的话，deque时间复杂度是O(N)</p>
<p>定义了一个ADT（Abstract Data Type）High-level上面带来的好处是：</p>
<ol>
<li>Seperation of Concerns: 使用者开发者不需要互相关心</li>
<li>Readability and maintainability</li>
</ol>
<p>Python有个内置的队列：deque 这个可以支持两端进两端出</p>
<h2 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h2><p>开始想只增添一个属性min 但是如果dequeue的时候把最小值删除了，就麻烦了。所以这个min可以用<strong>另外一个队列</strong>来维护。时间复杂度amortized O(1) <strong>均摊时间</strong></p>
<h1 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h1><p>入栈 push 出栈pop</p>
<p>实际意义：浏览器回退/编辑文档撤销/邮件列表最新出现在最上面/<strong>函数的调用本身</strong></p>
<p>可以直接用list</p>
<h1 id="Binary-Tree二叉树"><a href="#Binary-Tree二叉树" class="headerlink" title="Binary Tree二叉树"></a>Binary Tree二叉树</h1><p><strong>平衡二叉树Balanced</strong>： 每一个节点的左右子节点深度差 &lt;=1</p>
<p><strong>完全二叉树Complete</strong>：除了最后一层，其它层都是满的。并且最后一层是从左往右排的</p>
<p><strong>二叉搜索树Binary Search Tree</strong>：左子树都小于node，右子树都大于node，不考虑相等情况</p>
<p>递归中的BaseCase都是叶子节点的下一层：<code>If not root: return</code></p>
<p>想逐层打印的话：建一个queue每次pop出一个并且把左右节点push进去</p>
<p>发现BFS可以用stack写，DFS可以用queue写</p>
<h1 id="A-B-Testing"><a href="#A-B-Testing" class="headerlink" title="A/B Testing"></a>A/B Testing</h1><p>Quality control in the product iteration 比如说新上线一个功能想测试</p>
<h1 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h1><p>目的：快速找到极值</p>
<p>结构：Complete Binary Tree 分为min/maxheap</p>
<p>创建一个heap：从头元素开始不停地sift up（O(Nlog(N))）。Sift up 能保证前面一直是一个heap，sift down只能保证后面一直是heap，所以可以从最后一个开始不停的sift down(O(N))。</p>
<ul>
<li>时间复杂度小了很多，因为最后一层原来贡献了$\frac{N}{2}logN$ , 它们现在只贡献了0</li>
<li>并且实际操作的话，可以忽略最后一行，从最后一个有孩子的开始sift down. </li>
</ul>
<p>Pop的时候先交换array的最前最后，在那个大元素下降的时候，必须要跟左右孩子中较小的那个换，如果跟那个较大的换，会导致root比孩子数值大的问题</p>
<h1 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h1><p>时间复杂度最多是4logN 不能cover连续的四个Node</p>
<h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><strong>正常存法</strong>：是用list分别存储顶点和连线，缺点：</p>
<ul>
<li>一个很简单的问题都回答不了：给定两个定点A, B。是否存在一条路径连接他们呢？</li>
</ul>
<p><strong>Adjacency Matrix</strong>: 用一个n*n的矩阵存储边的信息，如果直接相连即为1。缺点：</p>
<ul>
<li>如果是个Sparse矩阵的话，浪费空间</li>
<li>添加一个新顶点会变得很难</li>
</ul>
<p>优点：</p>
<ul>
<li>可以自己乘自己，获得是否存在长度为K的路径（以及几条）</li>
</ul>
<p><strong>Adjacency List</strong>: 用字典来存储，每个节点是一个key，每一个与该节点相邻的节点是value。优点：</p>
<ul>
<li>我们不会为那些不存在的边浪费存储空间</li>
<li>查询一条边是否存在很快速</li>
<li>添加一条边也很简单</li>
</ul>
<p><strong>一些常见的问题</strong>：</p>
<ol>
<li>给定两点，是否存在通路？</li>
<li>给定一点，找到所有可达点以及所有邻边</li>
<li>给定一幅图，遍历所有点</li>
</ol>
<h3 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h3><p><strong>BFS遍历</strong>：Gab的例子：找眼镜，一点点摸</p>
<p>对于一个给定的节点，先遍历所有距离为1的节点，再遍历对所有新节点来说距离为1的节点。</p>
<ul>
<li>Time Complexity: 对于所有节点V，我们入栈一次出栈一次，并且我们遍历一次他们的邻边。O(V+E)</li>
</ul>
<p>可以用来找最短路径</p>
<p><strong>DFS遍历</strong>：Gab举了个例子：走迷宫。</p>
<p>通过递归来实现，从过一个点出发，算所有能从这个点走到的点。</p>
<p>可以找到所有连通分量</p>
<p><strong>状态</strong>：</p>
<p>对于有向图，有四种边的类型：Tree/Forward/Backward/Cross edge</p>
<p>对于无向图，有两种边的类型：Tree/Backward edge</p>
<p>所以在编程的时候我们要对每种情况进行分类讨论，是一个很便捷的思路。</p>
<p>无向图寻找环：找是否有Backward Edge。注意要记录一个父亲</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/02/Java%E5%BF%83%E5%BE%97/" rel="prev" title="Java心得">
      <i class="fa fa-chevron-left"></i> Java心得
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/02/Latex%E5%BF%83%E5%BE%97/" rel="next" title="Latex心得">
      Latex心得 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#课程问题"><span class="nav-text">课程问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见问题"><span class="nav-text">常见问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#广泛的知识"><span class="nav-text">广泛的知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未解决问题"><span class="nav-text">未解决问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linear-Regression"><span class="nav-text">Linear Regression</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Logistic-Regression"><span class="nav-text">Logistic Regression</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Search"><span class="nav-text">Binary Search</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linked-List"><span class="nav-text">Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Singly-Linked-List"><span class="nav-text">Singly Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历Traverse"><span class="nav-text">遍历Traverse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Add"><span class="nav-text">Add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remove"><span class="nav-text">Remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merge-two-sorted-linked-list"><span class="nav-text">Merge two sorted linked list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-middle-node-in-singly-linked-list"><span class="nav-text">Find middle node in singly linked list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Doubly-linked-list"><span class="nav-text">Doubly linked list</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#add"><span class="nav-text">add</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Recursion"><span class="nav-text">Recursion</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#reverse-singly-linked-list"><span class="nav-text">reverse singly linked list</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Non-linear-Models"><span class="nav-text">Non-linear Models</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Confusion-Matrix"><span class="nav-text">Confusion Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROC-curve"><span class="nav-text">ROC curve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decision-Tree"><span class="nav-text">Decision Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Random-Forest"><span class="nav-text">Random Forest</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SVM"><span class="nav-text">SVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KNN"><span class="nav-text">KNN</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Feature-Selection"><span class="nav-text">Feature Selection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PCA"><span class="nav-text">PCA</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#K-means-聚类"><span class="nav-text">K-means 聚类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法"><span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序Bubble-Sort"><span class="nav-text">冒泡排序Bubble Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序Selection-Sort"><span class="nav-text">选择排序Selection Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序-Insertion-Sort"><span class="nav-text">插入排序 Insertion Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#改进1："><span class="nav-text">改进1：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进2："><span class="nav-text">改进2：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序-Quicksort"><span class="nav-text">快速排序 Quicksort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序-Mergesort"><span class="nav-text">归并排序 Mergesort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bucket-Sort-Bin-Sort"><span class="nav-text">Bucket Sort&#x2F; Bin Sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Queue-队列"><span class="nav-text">Queue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#求最小值"><span class="nav-text">求最小值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stack-栈"><span class="nav-text">Stack 栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Tree二叉树"><span class="nav-text">Binary Tree二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-B-Testing"><span class="nav-text">A&#x2F;B Testing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆Heap"><span class="nav-text">堆Heap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Segment-Tree"><span class="nav-text">Segment Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Search"><span class="nav-text">Search</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-Search"><span class="nav-text">Graph Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储方式"><span class="nav-text">存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索方式"><span class="nav-text">搜索方式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大连铁板王"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">大连铁板王</p>
  <div class="site-description" itemprop="description">分享笔记——实践费曼学习法</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="http://douban.com/people/49183240" title="豆瓣 → http:&#x2F;&#x2F;douban.com&#x2F;people&#x2F;49183240" rel="noopener" target="_blank"><i class="fa fa-film fa-fw"></i>豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/siyu79" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;siyu79" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>Linkedin</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kehuiyao.github.io/" title="https:&#x2F;&#x2F;kehuiyao.github.io&#x2F;" rel="noopener" target="_blank">姚可辉's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大连铁板王</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">141k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  var disqus_config = function() {
    this.page.url = "https://moran79.github.io/2020/07/02/Laioffer%E7%AC%94%E8%AE%B0/";
    this.page.identifier = "2020/07/02/Laioffer笔记/";
    this.page.title = "Laioffer笔记";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://iamwangsiyu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
