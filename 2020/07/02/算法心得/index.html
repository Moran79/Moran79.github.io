<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"moran79.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍以下知识来自于：  普林斯顿在Coursera上面的algorithm网课 python算法书 算法导论 算法图解【一本书】  希望有朝一日能够继续学习。在上CS577的时候应该会更新这个文档">
<meta property="og:type" content="article">
<meta property="og:title" content="算法心得">
<meta property="og:url" content="https://moran79.github.io/2020/07/02/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/index.html">
<meta property="og:site_name" content="大家一起来">
<meta property="og:description" content="介绍以下知识来自于：  普林斯顿在Coursera上面的algorithm网课 python算法书 算法导论 算法图解【一本书】  希望有朝一日能够继续学习。在上CS577的时候应该会更新这个文档">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tKfTcly1frk8va07k3j31860yc0ti.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frng0jikt8j30ua0oqjuz.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frng24qffuj311c0rsn26.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frngs9k2d7j30wo0lqgq6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frnh4vnyhhj319a0zon2v.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frpywugxnuj30y80kg41s.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frpzbnkc5ej30xa0h8jtt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frpzy363p5j30xg09440q.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1frteyli23mj31260s07qh.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006CO3nzly1fs87tgwbsrj30ge0fiq7x.jpg">
<meta property="article:published_time" content="2020-07-02T16:18:27.000Z">
<meta property="article:modified_time" content="2020-08-18T18:49:46.485Z">
<meta property="article:author" content="大连铁板王">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ws2.sinaimg.cn/large/006tKfTcly1frk8va07k3j31860yc0ti.jpg">

<link rel="canonical" href="https://moran79.github.io/2020/07/02/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法心得 | 大家一起来</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">大家一起来</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-belief">

    <a href="/belief/" rel="section"><i class="fas fa-cross fa-fw"></i>信仰</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book/" rel="section"><i class="fas fa-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-music">

    <a href="/music/" rel="section"><i class="fas fa-music fa-fw"></i>音乐</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="far fa-laugh fa-fw"></i>生活</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://moran79.github.io/2020/07/02/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="大连铁板王">
      <meta itemprop="description" content="分享笔记——实践费曼学习法">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大家一起来">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法心得
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-02 11:18:27" itemprop="dateCreated datePublished" datetime="2020-07-02T11:18:27-05:00">2020-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-18 13:49:46" itemprop="dateModified" datetime="2020-08-18T13:49:46-05:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study/Others/" itemprop="url" rel="index"><span itemprop="name">Others</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study/Others/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>以下知识来自于：</p>
<ul>
<li>普林斯顿在Coursera上面的algorithm网课</li>
<li>python算法书</li>
<li>算法导论</li>
<li>算法图解【一本书】</li>
</ul>
<p>希望有朝一日能够继续学习。在上CS577的时候应该会更新这个文档</p>
<a id="more"></a>



<h1 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>作为一个好的算法工程师，在对具体问题进行优化的时候，甚至要考虑使用插入排序还是堆排序…</p>
<p>二分查找居然是O(logn)时间…天哪，在我使用bisect的时候我一直以为是O(n)，以为要走一遍。</p>
<p><strong>大O表示法：</strong></p>
<ul>
<li>表示的是「<strong>操作数</strong>」</li>
<li>用来描述的是「<strong>增速</strong>」<ul>
<li>增速：算法的操作数，随着数据量增加的<strong>时间上升斜率</strong>。</li>
</ul>
</li>
<li>防备的是「<strong>最差情况</strong>」<ul>
<li>很多时候我们也要评估一下<strong>平均时间</strong></li>
</ul>
</li>
</ul>
<p>一个O(n!)的例子：旅行商问题。</p>
<ul>
<li>给定五个城市，以什么样的顺序走一遍，所用的路程最短？ </li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数组因为元素都是挨在一起的，所以如果知道大小的话，最好事先安排好空间。</p>
<p><strong>比较数组和链表：</strong></p>
<ol>
<li>数组的存储位置是连续的，链表没有要求</li>
<li>读取数据：数组支持「<strong>随机访问</strong>」，链表必须跑一遍。O(1) v.s. O(n)</li>
<li>插入数据：数组必须要移动插入位置之后的所有数据（如果地方不够还要把所有数据都挪一遍）链表只需要改地址。 O(n) v.s. O(1)</li>
<li>删除数据：数组必须要移动插入位置之后的所有数据，链表只需要改地址。 O(n) v.s. O(1)</li>
<li>所以如果是频繁插入，很少读取，那么应该用链表。</li>
<li>数组内部的元素类型必须都相同。</li>
</ol>
<p>大O表示法一般会忽略前面的常数。</p>
<p><strong>新的数据结构，关于Facebook如何存储用户名：</strong></p>
<ul>
<li>有一个功能是判断当前用户名是否被注册。可以用二分法来寻找，这就需要支持随机访问。可以使用数组</li>
<li>但是使用数组会带来一个问题，那就是当新用户注册完之后，需要把当前用户名插入进去，这一步就要挪动O(n)个数据，听起来太恐怖了。</li>
<li>作者提出了个新想法：将A-Z分成24个不同的链表。而每个链表的头放在一个数组里</li>
<li>这个方法告诉我们，<strong>其实数据结构并不是那几个定式，很多时候可以自由组合</strong>，特殊情况特殊对待。</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的一种替代法是将要执行的东西放入一个list中，一个挨一个的去执行，就像维持一个栈。</p>
<blockquote>
<p>如果使用循环，<strong>程序的性能可能更高</strong>。如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。</p>
</blockquote>
<p>递归函数包含两部分：base case基线条件和recursive case递归条件。前者是针对的是什么时候函数不在调用自己。</p>
<p>栈的一个使用场景：讲一个栈顶的任务弹出，把其分为好多个小人物，重新压入栈顶。</p>
<p><strong>调用栈</strong>：函数的调用使用的是调用栈</p>
<ul>
<li>调用另一个函数的时候，当前函数暂停并处于未完成状态。</li>
<li>书中提到的盒子堆（栈）代替法其实是把递归函数的调用栈具象化了。</li>
<li>当递<strong>归层数过多的时候</strong>，可以考虑尾递归优化。Python不支持尾递归优化，不过可以用知乎老哥的next和Trampline模拟出类似结果。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>分而治之的思路：</strong> Divide and Conquor</p>
<ol>
<li>找到基线情况</li>
<li>如何将问题规模缩小，直到基线情况</li>
</ol>
<p>快速排序（找pivot） v.s. 合并排序（两两分组 -&gt; 四四分组 -&gt; …）：</p>
<ul>
<li>快速排序的最糟情况是O(n^2)，但合并排序最糟情况也是O(nlogn)，为何我们还用快排？<ul>
<li>因为其实运行时间是O(c * nlogn) 在n的函数不同的时候，常量一般影响不大。但是n的函数相近的时候，c这个常量就显得很重要了。而快排的c比合并的c小。所以平均情况下快排更好。</li>
</ul>
</li>
<li>快排每层操作都是n个元素，如果分的得当，一共会有logn层。</li>
</ul>
<h2 id="散列表-Hash-Table"><a href="#散列表-Hash-Table" class="headerlink" title="散列表 Hash Table"></a>散列表 Hash Table</h2><p>散列表将数据映射成索引——存储数据的列表索引</p>
<p><strong>散列函数的要求：</strong></p>
<ul>
<li>一致性：每次输入一个数据，返回的数字都相同</li>
<li>最大可能防止冲突</li>
</ul>
<p>散列表适用于「大海捞针似」的查找</p>
<p><strong>散列表的应用：</strong></p>
<ul>
<li>DNS解析：将输入的网址转换成对应的IP地址，散列表是提供这种功能的方式之一。</li>
<li>网页的缓存：大型互联网公司将一些主页什么的早早存在自己的服务器，而不是重复的生成同样的主页。</li>
</ul>
<p>常量时间：<strong>并不意味着马上</strong>，而是说不管数据n多大，需要的时间都相同。【导数的含义】</p>
<p><strong>关于冲突：</strong></p>
<ul>
<li>冲突的一个简单的解决办法就是在对应的索引上面开一个新的链表。</li>
<li>填装因子：总数据/位置总数。当填装因子 &gt; 0.7的时候就要考虑整体迁移到一个更大的空间上了。虽然迁移很慢，但是平均下来速度还是O(1)。</li>
</ul>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>在我所知道的算法中，<strong>图算法应该是最有用的。</strong></p>
<p>一个节点可能与众多节点直接相连，这些节点被称为<strong>邻居</strong>。</p>
<p><strong>BFS解决两类问题：</strong></p>
<ol>
<li>路径存在与否？</li>
<li>路径是否最短？【如果单纯的以层数来划分的话…】</li>
</ol>
<p>BFS包含了queue的结构，把第一层放进queue，一个一个取出。满足条件则停止，不满足条件则把新的candidate放在queue的最后。通常·，为了防止重复查找，我们会建立一个set来记录查找过的人。防止有两个点互相指着对方，则陷入无限循环。</p>
<p>BFS的运行时间：O(V+E) 每一条边E都要走, 每一个顶点V都会被放入queue一次。</p>
<p><strong>拓扑排序：</strong> 比如说先刷牙才能吃饭，先打开电视才能看电视。打开电视和刷牙的顺序随意，但是看电视必不能在打开电视之前。【对这种问题，用BFS可以找到一个possible solution？不懂为何把这两个放在一起讲     】</p>
<p>树是一种特殊的图，没有指向前面的边。</p>
<h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><p>加权图中找最短距离。</p>
<p><strong>基本思路：</strong></p>
<ol>
<li>找到目前可达的最短距离的点。</li>
<li>更新这个点的邻居们的距离。（如果多走一步其实更短的话）<ul>
<li>如果更新了的话，记得也更新表中的父节点。</li>
</ul>
</li>
<li>将当前点从遍历中去掉，如果还有剩余点没有检查过，则返回1步。</li>
<li>从表中的终点开始，一步一步找父节点，输出最终路径。</li>
</ol>
<p>如果有负权边的话，狄克斯特拉算法无法使用，可以用<strong>贝尔曼福特算法。</strong></p>
<p><strong>贝尔曼福特算法：</strong> 复杂度很大O(V*E)。思路是对边不停地进行松弛操作，</p>
<ul>
<li>第一步是出发点到所有点的一步最短距离，第二步是出发点到所有点的两步最短距离。</li>
<li>因为出发点到终点，最多只要走n-1条边。所以第n-1步就可以结束了。</li>
<li>如果途中包含了负环，些许尴尬。更新就无法停止了。</li>
</ul>
<h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><p>对于NP完全问题，只能用近似算法来做。评估近似算法：</p>
<ol>
<li>速度快不快</li>
<li>得到的近似解和最优解的近似程度</li>
</ol>
<p>一些简易的判断是否为NP问题的方法：</p>
<ul>
<li>发现速度大概是O(n!)</li>
<li>涉及「所有组合」</li>
<li>不能将问题分成小问题</li>
<li>涉及序列（旅行商）</li>
<li>涉及集合（集合覆盖）</li>
<li>如果问题可以转化成已知的NP问题（旅行商、集合覆盖）</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>每次求解都可以画出一个表格：</p>
<ul>
<li>列从左到右分别是限制条件的越来越大</li>
<li>行从上到下分别是增添进不同的元素</li>
<li>方格里的元素就是要优化的对象</li>
<li>有时答案出现在最后一列，有时候也可能是表中的极值</li>
<li>当前方格的值常常取决于上一行的值（子问题可能是上面的行）</li>
<li>各行的排列顺序与结果无关</li>
</ul>
<p>动态规划不能处理的问题：</p>
<ul>
<li>比如说偷盗例子中，不能偷一个商品的一部分。背包剩40g地方，有100g的大米，动态规划只能处理0g/100g，无法处理只偷40g大米。可以考虑使用贪婪算法。</li>
<li>处理的子问题无法相互依赖，也被称为离散子问题。</li>
</ul>
<p>著名的费曼算法：</p>
<ol>
<li>把问题写下来</li>
<li>仔细思考</li>
<li>把答案写下来</li>
</ol>
<p>常见动态规划问题：</p>
<ul>
<li>最长公共子串</li>
<li>最长公共子序列</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>二叉搜索树的优点：插入删除元素需要的时间都是<code>O(log(N))</code><br>其他的数据结构：B树、红黑树、堆、伸展树</p>
<p>并行算法的开销：</p>
<ol>
<li>并行管理开销</li>
<li>负载均衡：不能一个机器忙得要命，一个机器闲着</li>
</ol>
<p>布隆过滤器 &amp; HyperLoglog：</p>
<ul>
<li>一种概率型数据结构。给出的答案有可能不对，但是很有可能是对的。很适合用于不要求答案绝对准确的情况。</li>
</ul>
<p>SHA散列算法：</p>
<ul>
<li>默认局部不敏感（原文动一点，密文动好多），也可以用Simhash这种局部敏感的散列算法。</li>
<li>Diffie-Hellman密钥交换，优雅、不难理解并被广泛使用</li>
</ul>
<p>线性规划：</p>
<ul>
<li>一个很宽泛的框架，图问题只是其中的一个子集</li>
<li>使用复杂的Simplex算法</li>
</ul>
<h1 id="Backtracking-放弃法"><a href="#Backtracking-放弃法" class="headerlink" title="Backtracking 放弃法"></a>Backtracking 放弃法</h1><p>backtracking（回溯算法）也叫试探法，它是一种系统地<strong>搜索问题的解</strong>的方法。回溯算法的基本思想是：<u>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</u></p>
<p>“回溯”的具体意思就是<strong>将不可能解或者部分解的候选尽早的舍弃掉</strong></p>
<p>深度优先算法DFS就是一种Backtracking的实例。</p>
<p>回溯算法说白了就是穷举法。不过回溯算法使用<strong>剪枝函数</strong>，剪去一些不可能到达最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</p>
<p>遍历过当前节点后，为了回溯到上一步，要去掉已经加入到结果list中的当前节点。</p>
<ul>
<li>这一步有时候可以用list的append和pop实现</li>
</ul>
<p>回溯法是一个既带有<strong>系统性</strong>又带有<strong>跳跃性</strong>的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，<u>总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索</u>，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<ul>
<li>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。</li>
<li>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<p>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/crystal6918/article/details/51924665">https://blog.csdn.net/crystal6918/article/details/51924665</a></p>
<p>待做的题：</p>
<ol start="51">
<li>N-Queens</li>
<li>N-Queens II</li>
<li>Combination Sum</li>
<li>Combination Sum II</li>
<li>Combination Sum III</li>
<li>Permutations</li>
<li>Permutations II</li>
<li>Subsets</li>
<li>Subsets II</li>
<li>Palindrome Partitioning</li>
</ol>
<h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><p>Union Find 是用来解决动态连通性（Dynamic Connectivity）问题的算法，是并查集的一种数据结构。</p>
<p>现在学的知识只能告诉我们是否联通，算法第二部分则会给出具体的联通路径。</p>
<p>API：Application Programming Interface 应用程序编程接口</p>
<p>等价性（Equivalence Relation）:</p>
<ol>
<li>Reflexive: 自反性</li>
<li>Symmetric：对称性</li>
<li>Transitive：传递性</li>
</ol>
<p>Dynamic Connectivity包含两部分：</p>
<ol>
<li>Find Query: 给定两个点，判断他们是否联通</li>
<li>Union Command: 给定两个点，将他们联通（属于生成过程）</li>
</ol>
<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>建立一个长度为n的列表，连通的点在列表中有着相同的元素。</p>
<p>Find: 当我们想知道p和q是否相通的时候我们只需要判断列表的第q和p位是否具有相同的数字即可。</p>
<p>Union: 将其中一个数字全部变为另一个。具体变的时候Union(a,b)我们将a位置的数字变为b位置的数字</p>
<p>Quick-Find 太慢啦！初始化需要跑完n, union操作需要跑完n, find操作需要1。</p>
<p>复杂度是$n^2$，我们不能接受这样的算法</p>
<p>Quadratic algorithm does not scale with technology.</p>
<h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>建立一个树结构。还是一个长度为n的列表。每个位置对应的数值表示他的父亲节点是谁。</p>
<p>Find：只要p和q有相同的根节点就可以了</p>
<p>Union：将其中一个数字的根节点变成另一个数字的根节点的孩子节点。</p>
<p>Quick-Union 也不快！初始化需要跑完n, union操作需要跑完n, find操作需要n。</p>
<h3 id="Weighted-Quick-Union"><a href="#Weighted-Quick-Union" class="headerlink" title="Weighted Quick Union"></a>Weighted Quick Union</h3><p>我们记录树的size，确保每次都将小树连接到大树的上面</p>
<p>每个根节点的深度不超过logn.初始化需要跑完n, union操作需要跑完logn, find操作需要logn。</p>
<h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>在我们从一个节点回溯找根节点的时候，只要当前停留的节点不是根节点，我们就将这个节点指向根节点。压缩整个树的深度，因为就是深度才带来了时间的长度。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>给定N个点，M个Union。在最极端的情况下：</p>
<table>
<thead>
<tr>
<th>Quick-Find</th>
<th>Quick-Union</th>
<th>Weighted QU</th>
<th>QU+Path CP</th>
<th>WQU+Path CP</th>
</tr>
</thead>
<tbody><tr>
<td>MN</td>
<td>MN</td>
<td>N + M*logN</td>
<td>N + M*logN</td>
<td>N + M*log*N</td>
</tr>
<tr>
<td>Log* 是迭代对数函数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Applications——Percolation"><a href="#Applications——Percolation" class="headerlink" title="Applications——Percolation"></a>Applications——Percolation</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1frk8va07k3j31860yc0ti.jpg" alt=""></p>
<p>很明显，概率越小越不容易渗透。</p>
<p>Phase Transition: 在能不能渗透的某个临界值p，图像会变得十分陡峭。</p>
<p>用蒙特卡洛模拟来找出临界值p：先给一个黑色方块。将其中的黑块一个一个的变成白块，直至渗透。</p>
<p>将每一个方块用一个点来表示。每次一个点亮的白块会call function 0~4次。<br>在第一行上面建立一个虚拟点，连接了第一行的每一个点。在最后一行下面建立一个虚拟点，连接最后一行的每一个点。反复判断这两个创建的虚拟点之间是否存在通路即可。</p>
<p>最后答案是0.592746</p>
<h1 id="Analysis-of-Algorithms"><a href="#Analysis-of-Algorithms" class="headerlink" title="Analysis of Algorithms"></a>Analysis of Algorithms</h1><h2 id="观察法"><a href="#观察法" class="headerlink" title="观察法"></a>观察法</h2><p>Example: 3-Sum: Given N integers, how many triples sum to exactly zero?<br>Brute Force：三层for循环</p>
<p>很常见的一种画时间T和数据量N的图是log-log图。$T = aN^b$</p>
<p>满足指数时间增长的算法可以通过一种方法检验：Doubling Hypothesis<br>用2N的时间除于N的时间来获得一个Ratio。如果这个Ratio趋近于一个常数，就说明差不多是指数增长（log(Ratio) = b），也可以画出log-log图然后进行拟合。</p>
<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>我们首先要记住一些基本操作的耗时。比如说分配一个长度为n的向量时间是O(n)，连接两个字符串的时间也是O(n)</p>
<p>我们一般只算最耗时的那些步骤都被重复了多少次</p>
<p>所以在k-sum的例子中，最耗时的一步是$C_N^k$这一步，O($n^k$)</p>
<p>但是这种获得explcit的方式有点太难了，所以一般也不采用这种方法</p>
<h2 id="Order-Of-Growth"><a href="#Order-Of-Growth" class="headerlink" title="Order Of Growth"></a>Order Of Growth</h2><p>1, log(N), N, Nlog(N), N^2, N^3, 2^N…</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frng0jikt8j30ua0oqjuz.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frng24qffuj311c0rsn26.jpg" alt=""></p>
<h3 id="四种记号"><a href="#四种记号" class="headerlink" title="四种记号"></a>四种记号</h3><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frngs9k2d7j30wo0lqgq6.jpg" alt=""></p>
<p><strong>Common mistake：</strong> Interpreting big-Oh as an approximate model. </p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frnh4vnyhhj319a0zon2v.jpg" alt=""></p>
<h1 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h1><p>Stack: LIFO 后进先出<br>Queue: FIFO 先进先出<br>这两个都可以用linked-list / array来实现</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Resizing-Array"><a href="#Resizing-Array" class="headerlink" title="Resizing Array"></a>Resizing Array</h3><p>在Java实现中，我们需要用户给出array的默认长度。所以更灵活的，我们可以用resizing array。但是可变长度的array会有一个问题，那就是我们每向array末尾添加一个元素的时候，我们需要把之前所有元素都复制一遍，连同最新的元素放到一起。这样的话需要的操作为：$1+2+3+…+N = N(N+1)/2$. 所以我们需要一个更简单的方法来做这个事情。</p>
<h4 id="Repeated-Doubling"><a href="#Repeated-Doubling" class="headerlink" title="Repeated Doubling"></a>Repeated Doubling</h4><p>Q. How to grow array?</p>
<p>A. If array is full, create a new array of <u>twice the size</u>, and copy items.</p>
<p>Cost of inserting first N items: $N + (2^1 + 2^2 + 2^3 + … + N) \sim 3N$.</p>
<p>Q. How to shrink array?</p>
<p>A. halve size of array s[] when array is one-quarter full.</p>
<h3 id="Stack-considerations"><a href="#Stack-considerations" class="headerlink" title="Stack considerations"></a>Stack considerations</h3><p>Overflow and underflow: </p>
<ul>
<li>Underflow: <u>throw exception</u> if pop from an empty stack.</li>
<li>Overflow: use <u>resizing array</u> for array implementation.</li>
</ul>
<p>Null items:</p>
<ul>
<li>We allow null items to be inserted.</li>
</ul>
<p>Loitering:</p>
<ul>
<li>Holding a reference to an object when it is no longer needed.</li>
<li>解决方法是每次在pop之后，将不用的元素设为NULL</li>
</ul>
<h3 id="Linked-List-or-Resizing-Array"><a href="#Linked-List-or-Resizing-Array" class="headerlink" title="Linked-List or Resizing Array"></a>Linked-List or Resizing Array</h3><p>如果我们希望总时间变少而不在乎单个插入/删除的操作时间的话，选择Resizing-Array。如果我们想避免某一个添加/删除很慢很慢的情况，选择Linked-List，因为每一步操作耗时基本是相同的。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Stack里面的push和pop在Queue里面被称为enqueue和dequeue</p>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>有时候元素不是数字或字符这么好操作的东西（Generic Type），就有点麻烦。在各个语言里面实现的时候，Liknked-List比Array更容易实现</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>在Python里面是用dict来实现</p>
<p>The <u>MutableMapping</u> abstract base class, from Python’s <strong>collections</strong> module and discussed in the preceding pages, is a valuable tool when implementing a map.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpywugxnuj30y80kg41s.jpg" alt=""></p>
<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><p>Python的dict功能是用Hash Table实现的，因此查找才辣么快。</p>
<p>The novel concept for a hash table is the use of a <u>hash function to map general keys to corresponding indices</u> in a table.</p>
<p>The <strong>goal</strong> of a hash function, h, is to <u>map each key k to an integer in the range [0,N − 1]</u>, where N is the capacity of the bucket array for a hash table.</p>
<p>If there are two or more keys with the same hash value, then two different items will be mapped to the same bucket in A. In this case, we say that a collision has occurred.</p>
<p>We say that a hash function is “good” if it maps the keys in our map so as to sufﬁciently minimize collisions. For practical reasons, we also would like a hash function to be fast and easy to compute.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpzbnkc5ej30xa0h8jtt.jpg" alt=""></p>
<p>The advantage of separating the hash function into two such components is that the hash code portion of that computation is independent of a speciﬁc hash table size. This allows the development of a general hash code for each object that can be used for a hash table of any size; only the compression function depends upon the table size. This is particularly convenient, <u>because the underlying bucket array for a hash table may be dynamically resized</u>, depending on the number of items currently stored in the map.</p>
<h3 id="几种常见Hash编码方法"><a href="#几种常见Hash编码方法" class="headerlink" title="几种常见Hash编码方法"></a>几种常见Hash编码方法</h3><h4 id="Treating-the-Bit-Representation-as-an-Integer"><a href="#Treating-the-Bit-Representation-as-an-Integer" class="headerlink" title="Treating the Bit Representation as an Integer"></a>Treating the Bit Representation as an Integer</h4><p>Python relies on 32-bit hash codes. If a ﬂoating-point number uses a 64-bit representation, its bits cannot be viewed directly as a hash code.（如果当前信息不超过32-bit，那么他本身就是编码后的hash-code）如果是64-bit可以用32+32/去掉其中一个32/两个32做异或</p>
<h4 id="Polynomial-Hash-Codes"><a href="#Polynomial-Hash-Codes" class="headerlink" title="Polynomial Hash Codes"></a>Polynomial Hash Codes</h4><p>用Bit-representaion会出现的问题：The summation and exclusive-or hash codes, described above, are not good choices for character strings or other variable-length objects that can be viewed as tuples of the form $(x_0,x_1,…,x_{n-1})$, where <strong>the order of the x i ’s is signiﬁcant</strong>.</p>
<p>An alternative hash code, which does exactly this, is to choose a nonzero constant, a = 1, and use as a hash code the value:<br>$$<br>x_0a^{n-1}+x_1a^{n-2}+…+x_{n-2}a+x_{n-1}<br>$$<br>By Horner’s rule (see Exercise C-3.50), this polynomial can be computed as:<br>$$<br>x_{n-1}+a(x_{n-2}+a(x_{n-3}+…+a(x_2+a(x_1+ax_0))))<br>$$<br>We have done some experimental studies that suggest that <u>33, 37, 39, and 41</u> are particularly good choices for a when working with character strings that are English words.</p>
<h4 id="Cyclic-Shift-Hash-Codes"><a href="#Cyclic-Shift-Hash-Codes" class="headerlink" title="Cyclic-Shift Hash Codes"></a>Cyclic-Shift Hash Codes</h4><p>A variant of the polynomial hash code replaces multiplication by a with a cyclic shift of a partial sum by a certain number of bits.</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frpzy363p5j30xg09440q.jpg" alt=""></p>
<p>python里面的hash(x)可以计算一个x的hash值，However, only <u>immutable data types</u> are deemed hashable in Python. This restriction is meant to ensure that a particular object’s hash code remains constant during that object’s lifespan. Among Python’s built-in data types, <u>the immutable int, ﬂoat, str, tuple, and frozenset</u> classes produce robust hash codes via the hash function. Instances of <u>user-deﬁned classes</u> are treated as unhashable by default, with a TypeError raised by the hash function.</p>
<p>An important rule to obey is that if x == y, then hash(x) == hash(y).</p>
<h3 id="Compression-Functions"><a href="#Compression-Functions" class="headerlink" title="Compression Functions"></a>Compression Functions</h3><p>mapping the hash code integer into the range [0,N −1]. A good compression function is one that <u>minimizes the number of collisions for a given set of distinct hash codes.</u></p>
<h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><p>分治方法将问题划为互不相交的子问题，递归的求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题有公共的子子问题。在这种情况下，DP对每个子子问题只会求解一次，将其<u>保存在一个表格</u>中。动态规划常用来解决<strong>最优化问题</strong></p>
<p>动态规划的四个步骤：</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归的定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造最优解</li>
</ol>
<p>计算一个p*q矩阵和一个q*r矩阵的成绩，需要计算p*q*r个标量乘法</p>
<p>钢条切割中每一个分段都是相同的，所有长度为k的钢条都属于一个子问题。但是矩阵链乘法每一个长度为k的子链都不相同，不属于一个子问题。</p>
<p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1frteyli23mj31260s07qh.jpg" alt=""></p>
<h1 id="Numeric-Optimization"><a href="#Numeric-Optimization" class="headerlink" title="Numeric Optimization"></a>Numeric Optimization</h1><h3 id="Newton’s-Method"><a href="#Newton’s-Method" class="headerlink" title="Newton’s Method"></a>Newton’s Method</h3><p>算法</p>
<p>优点</p>
<ul>
<li>fast convergence (under some condition)</li>
</ul>
<p>缺点</p>
<ul>
<li>Need second order derivative （二阶连续可导，为了防止出现切线斜率为0从而与x轴没有交点，如果此时找到了二阶导数为0的点，就是一个极值点）</li>
<li>Only 1-D</li>
</ul>
<h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>算法</p>
<p>优点</p>
<ul>
<li>n-D</li>
<li>only need first order derivative</li>
</ul>
<p>缺点</p>
<ul>
<li>Speed depends</li>
<li>Rosenbrock函数效果不太好，出现锯齿状（jag）</li>
</ul>
<h3 id="Golden-Section"><a href="#Golden-Section" class="headerlink" title="Golden Section"></a>Golden Section</h3><p>算法</p>
<p>用secant line (割线) 代替 tangent line（切线）</p>
<p>优点</p>
<ul>
<li>No derivative required</li>
<li>Fast</li>
</ul>
<p>缺点</p>
<ul>
<li>Only works on U-shape function. (可以考虑将一个大的函数切成几个小的U-shape部分)</li>
<li>1-D</li>
</ul>
<h3 id="Nelder-Mead"><a href="#Nelder-Mead" class="headerlink" title="Nelder-Mead"></a>Nelder-Mead</h3><p>算法</p>
<p>用一个三角形来估计切线</p>
<p>优点</p>
<ul>
<li>n-D</li>
</ul>
<p>缺点</p>
<ul>
<li>converge slowly</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="http://ww1.sinaimg.cn/large/006CO3nzly1fs87tgwbsrj30ge0fiq7x.jpg" alt=""></p>
<h1 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h1><p>对称性+传递性无法推出自反性的例子：平行关系</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/02/The-Reason-for-God/" rel="prev" title="Timothy Keller">
      <i class="fa fa-chevron-left"></i> Timothy Keller
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/02/Java%E5%BF%83%E5%BE%97/" rel="next" title="Java心得">
      Java心得 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3"><span class="nav-text">算法图解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="nav-text">算法简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8-Hash-Table"><span class="nav-text">散列表 Hash Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">广度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-text">狄克斯特拉算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95"><span class="nav-text">贪婪算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Backtracking-%E6%94%BE%E5%BC%83%E6%B3%95"><span class="nav-text">Backtracking 放弃法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Union-Find"><span class="nav-text">Union Find</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Quick-Find"><span class="nav-text">Quick Find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quick-Union"><span class="nav-text">Quick Union</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Weighted-Quick-Union"><span class="nav-text">Weighted Quick Union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path-Compression"><span class="nav-text">Path Compression</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary"><span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applications%E2%80%94%E2%80%94Percolation"><span class="nav-text">Applications——Percolation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Analysis-of-Algorithms"><span class="nav-text">Analysis of Algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E6%B3%95"><span class="nav-text">观察法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E6%B3%95"><span class="nav-text">数学法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Order-Of-Growth"><span class="nav-text">Order Of Growth</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%B0%E5%8F%B7"><span class="nav-text">四种记号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="nav-text">内存使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stack-amp-Queue"><span class="nav-text">Stack &amp; Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack"><span class="nav-text">Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Resizing-Array"><span class="nav-text">Resizing Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Repeated-Doubling"><span class="nav-text">Repeated Doubling</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack-considerations"><span class="nav-text">Stack considerations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linked-List-or-Resizing-Array"><span class="nav-text">Linked-List or Resizing Array</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generic"><span class="nav-text">Generic</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-Table"><span class="nav-text">Hash Table</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81Hash%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-text">几种常见Hash编码方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Treating-the-Bit-Representation-as-an-Integer"><span class="nav-text">Treating the Bit Representation as an Integer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Polynomial-Hash-Codes"><span class="nav-text">Polynomial Hash Codes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cyclic-Shift-Hash-Codes"><span class="nav-text">Cyclic-Shift Hash Codes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compression-Functions"><span class="nav-text">Compression Functions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP"><span class="nav-text">动态规划DP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Numeric-Optimization"><span class="nav-text">Numeric Optimization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Newton%E2%80%99s-Method"><span class="nav-text">Newton’s Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gradient-Descent"><span class="nav-text">Gradient Descent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golden-Section"><span class="nav-text">Golden Section</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nelder-Mead"><span class="nav-text">Nelder-Mead</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">数学基础知识</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大连铁板王"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">大连铁板王</p>
  <div class="site-description" itemprop="description">分享笔记——实践费曼学习法</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="http://douban.com/people/49183240" title="豆瓣 → http:&#x2F;&#x2F;douban.com&#x2F;people&#x2F;49183240" rel="noopener" target="_blank"><i class="fa fa-film fa-fw"></i>豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/siyu79" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;siyu79" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>Linkedin</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kehuiyao.github.io/" title="https:&#x2F;&#x2F;kehuiyao.github.io&#x2F;" rel="noopener" target="_blank">姚可辉's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://jerryliu20d.github.io/" title="https:&#x2F;&#x2F;jerryliu20d.github.io&#x2F;" rel="noopener" target="_blank">刘理杰's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大连铁板王</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">234k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
  var disqus_config = function() {
    this.page.url = "https://moran79.github.io/2020/07/02/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/";
    this.page.identifier = "2020/07/02/算法心得/";
    this.page.title = "算法心得";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://iamwangsiyu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
